{"ast":null,"code":"/**\n * @licstart The following is the entire license notice for the\n * Javascript code in this page\n *\n * Copyright 2021 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * Javascript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define(\"pdfjs-dist/build/pdf\", [], factory);else if (typeof exports === 'object') exports[\"pdfjs-dist/build/pdf\"] = factory();else root[\"pdfjs-dist/build/pdf\"] = root.pdfjsLib = factory();\n})(this, function () {\n  return /******/(() => {\n    // webpackBootstrap\n    /******/\n    \"use strict\";\n\n    /******/\n    var __webpack_modules__ = [\n      /* 0 */\n    , (/* 1 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.LinkTarget = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = void 0;\n      exports.addLinkAttributes = addLinkAttributes;\n      exports.deprecated = deprecated;\n      exports.getFilenameFromUrl = getFilenameFromUrl;\n      exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;\n      exports.getXfaPageViewport = getXfaPageViewport;\n      exports.isDataScheme = isDataScheme;\n      exports.isPdfFile = isPdfFile;\n      exports.isValidFetchUrl = isValidFetchUrl;\n      exports.loadScript = loadScript;\n      var _util = __w_pdfjs_require__(2);\n      var _base_factory = __w_pdfjs_require__(5);\n      const DEFAULT_LINK_REL = \"noopener noreferrer nofollow\";\n      const SVG_NS = \"http://www.w3.org/2000/svg\";\n      const PixelsPerInch = {\n        CSS: 96.0,\n        PDF: 72.0,\n        get PDF_TO_CSS_UNITS() {\n          return (0, _util.shadow)(this, \"PDF_TO_CSS_UNITS\", this.CSS / this.PDF);\n        }\n      };\n      exports.PixelsPerInch = PixelsPerInch;\n      class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {\n        constructor({\n          ownerDocument = globalThis.document\n        } = {}) {\n          super();\n          this._document = ownerDocument;\n        }\n        _createCanvas(width, height) {\n          const canvas = this._document.createElement(\"canvas\");\n          canvas.width = width;\n          canvas.height = height;\n          return canvas;\n        }\n      }\n      exports.DOMCanvasFactory = DOMCanvasFactory;\n      async function fetchData(url, asTypedArray = false) {\n        if (isValidFetchUrl(url, document.baseURI)) {\n          const response = await fetch(url);\n          if (!response.ok) {\n            throw new Error(response.statusText);\n          }\n          return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());\n        }\n        return new Promise((resolve, reject) => {\n          const request = new XMLHttpRequest();\n          request.open(\"GET\", url, true);\n          if (asTypedArray) {\n            request.responseType = \"arraybuffer\";\n          }\n          request.onreadystatechange = () => {\n            if (request.readyState !== XMLHttpRequest.DONE) {\n              return;\n            }\n            if (request.status === 200 || request.status === 0) {\n              let data;\n              if (asTypedArray && request.response) {\n                data = new Uint8Array(request.response);\n              } else if (!asTypedArray && request.responseText) {\n                data = (0, _util.stringToBytes)(request.responseText);\n              }\n              if (data) {\n                resolve(data);\n                return;\n              }\n            }\n            reject(new Error(request.statusText));\n          };\n          request.send(null);\n        });\n      }\n      class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n        _fetchData(url, compressionType) {\n          return fetchData(url, this.isCompressed).then(data => {\n            return {\n              cMapData: data,\n              compressionType\n            };\n          });\n        }\n      }\n      exports.DOMCMapReaderFactory = DOMCMapReaderFactory;\n      class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n        _fetchData(url) {\n          return fetchData(url, true);\n        }\n      }\n      exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;\n      class DOMSVGFactory extends _base_factory.BaseSVGFactory {\n        _createSVG(type) {\n          return document.createElementNS(SVG_NS, type);\n        }\n      }\n      exports.DOMSVGFactory = DOMSVGFactory;\n      class PageViewport {\n        constructor({\n          viewBox,\n          scale,\n          rotation,\n          offsetX = 0,\n          offsetY = 0,\n          dontFlip = false\n        }) {\n          this.viewBox = viewBox;\n          this.scale = scale;\n          this.rotation = rotation;\n          this.offsetX = offsetX;\n          this.offsetY = offsetY;\n          const centerX = (viewBox[2] + viewBox[0]) / 2;\n          const centerY = (viewBox[3] + viewBox[1]) / 2;\n          let rotateA, rotateB, rotateC, rotateD;\n          rotation %= 360;\n          if (rotation < 0) {\n            rotation += 360;\n          }\n          switch (rotation) {\n            case 180:\n              rotateA = -1;\n              rotateB = 0;\n              rotateC = 0;\n              rotateD = 1;\n              break;\n            case 90:\n              rotateA = 0;\n              rotateB = 1;\n              rotateC = 1;\n              rotateD = 0;\n              break;\n            case 270:\n              rotateA = 0;\n              rotateB = -1;\n              rotateC = -1;\n              rotateD = 0;\n              break;\n            case 0:\n              rotateA = 1;\n              rotateB = 0;\n              rotateC = 0;\n              rotateD = -1;\n              break;\n            default:\n              throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n          }\n          if (dontFlip) {\n            rotateC = -rotateC;\n            rotateD = -rotateD;\n          }\n          let offsetCanvasX, offsetCanvasY;\n          let width, height;\n          if (rotateA === 0) {\n            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n            width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n            height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n          } else {\n            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n            width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n            height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n          }\n          this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n          this.width = width;\n          this.height = height;\n        }\n        clone({\n          scale = this.scale,\n          rotation = this.rotation,\n          offsetX = this.offsetX,\n          offsetY = this.offsetY,\n          dontFlip = false\n        } = {}) {\n          return new PageViewport({\n            viewBox: this.viewBox.slice(),\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n          });\n        }\n        convertToViewportPoint(x, y) {\n          return _util.Util.applyTransform([x, y], this.transform);\n        }\n        convertToViewportRectangle(rect) {\n          const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n          const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n          return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n        }\n        convertToPdfPoint(x, y) {\n          return _util.Util.applyInverseTransform([x, y], this.transform);\n        }\n      }\n      exports.PageViewport = PageViewport;\n      class RenderingCancelledException extends _util.BaseException {\n        constructor(msg, type) {\n          super(msg, \"RenderingCancelledException\");\n          this.type = type;\n        }\n      }\n      exports.RenderingCancelledException = RenderingCancelledException;\n      const LinkTarget = {\n        NONE: 0,\n        SELF: 1,\n        BLANK: 2,\n        PARENT: 3,\n        TOP: 4\n      };\n      exports.LinkTarget = LinkTarget;\n      function addLinkAttributes(link, {\n        url,\n        target,\n        rel,\n        enabled = true\n      } = {}) {\n        (0, _util.assert)(url && typeof url === \"string\", 'addLinkAttributes: A valid \"url\" parameter must provided.');\n        const urlNullRemoved = (0, _util.removeNullCharacters)(url);\n        if (enabled) {\n          link.href = link.title = urlNullRemoved;\n        } else {\n          link.href = \"\";\n          link.title = `Disabled: ${urlNullRemoved}`;\n          link.onclick = () => {\n            return false;\n          };\n        }\n        let targetStr = \"\";\n        switch (target) {\n          case LinkTarget.NONE:\n            break;\n          case LinkTarget.SELF:\n            targetStr = \"_self\";\n            break;\n          case LinkTarget.BLANK:\n            targetStr = \"_blank\";\n            break;\n          case LinkTarget.PARENT:\n            targetStr = \"_parent\";\n            break;\n          case LinkTarget.TOP:\n            targetStr = \"_top\";\n            break;\n        }\n        link.target = targetStr;\n        link.rel = typeof rel === \"string\" ? rel : DEFAULT_LINK_REL;\n      }\n      function isDataScheme(url) {\n        const ii = url.length;\n        let i = 0;\n        while (i < ii && url[i].trim() === \"\") {\n          i++;\n        }\n        return url.substring(i, i + 5).toLowerCase() === \"data:\";\n      }\n      function isPdfFile(filename) {\n        return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n      }\n      function getFilenameFromUrl(url) {\n        const anchor = url.indexOf(\"#\");\n        const query = url.indexOf(\"?\");\n        const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\n        return url.substring(url.lastIndexOf(\"/\", end) + 1, end);\n      }\n      function getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n        if (typeof url !== \"string\") {\n          return defaultFilename;\n        }\n        if (isDataScheme(url)) {\n          (0, _util.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n          return defaultFilename;\n        }\n        const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n        const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n        const splitURI = reURI.exec(url);\n        let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n        if (suggestedFilename) {\n          suggestedFilename = suggestedFilename[0];\n          if (suggestedFilename.includes(\"%\")) {\n            try {\n              suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n            } catch (ex) {}\n          }\n        }\n        return suggestedFilename || defaultFilename;\n      }\n      class StatTimer {\n        constructor() {\n          this.started = Object.create(null);\n          this.times = [];\n        }\n        time(name) {\n          if (name in this.started) {\n            (0, _util.warn)(`Timer is already running for ${name}`);\n          }\n          this.started[name] = Date.now();\n        }\n        timeEnd(name) {\n          if (!(name in this.started)) {\n            (0, _util.warn)(`Timer has not been started for ${name}`);\n          }\n          this.times.push({\n            name,\n            start: this.started[name],\n            end: Date.now()\n          });\n          delete this.started[name];\n        }\n        toString() {\n          const outBuf = [];\n          let longest = 0;\n          for (const time of this.times) {\n            const name = time.name;\n            if (name.length > longest) {\n              longest = name.length;\n            }\n          }\n          for (const time of this.times) {\n            const duration = time.end - time.start;\n            outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\\n`);\n          }\n          return outBuf.join(\"\");\n        }\n      }\n      exports.StatTimer = StatTimer;\n      function isValidFetchUrl(url, baseUrl) {\n        try {\n          const {\n            protocol\n          } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n          return protocol === \"http:\" || protocol === \"https:\";\n        } catch (ex) {\n          return false;\n        }\n      }\n      function loadScript(src, removeScriptElement = false) {\n        return new Promise((resolve, reject) => {\n          const script = document.createElement(\"script\");\n          script.src = src;\n          script.onload = function (evt) {\n            if (removeScriptElement) {\n              script.remove();\n            }\n            resolve(evt);\n          };\n          script.onerror = function () {\n            reject(new Error(`Cannot load script at: ${script.src}`));\n          };\n          (document.head || document.documentElement).appendChild(script);\n        });\n      }\n      function deprecated(details) {\n        console.log(\"Deprecated API usage: \" + details);\n      }\n      let pdfDateStringRegex;\n      class PDFDateString {\n        static toDateObject(input) {\n          if (!input || !(0, _util.isString)(input)) {\n            return null;\n          }\n          if (!pdfDateStringRegex) {\n            pdfDateStringRegex = new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n          }\n          const matches = pdfDateStringRegex.exec(input);\n          if (!matches) {\n            return null;\n          }\n          const year = parseInt(matches[1], 10);\n          let month = parseInt(matches[2], 10);\n          month = month >= 1 && month <= 12 ? month - 1 : 0;\n          let day = parseInt(matches[3], 10);\n          day = day >= 1 && day <= 31 ? day : 1;\n          let hour = parseInt(matches[4], 10);\n          hour = hour >= 0 && hour <= 23 ? hour : 0;\n          let minute = parseInt(matches[5], 10);\n          minute = minute >= 0 && minute <= 59 ? minute : 0;\n          let second = parseInt(matches[6], 10);\n          second = second >= 0 && second <= 59 ? second : 0;\n          const universalTimeRelation = matches[7] || \"Z\";\n          let offsetHour = parseInt(matches[8], 10);\n          offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n          let offsetMinute = parseInt(matches[9], 10) || 0;\n          offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n          if (universalTimeRelation === \"-\") {\n            hour += offsetHour;\n            minute += offsetMinute;\n          } else if (universalTimeRelation === \"+\") {\n            hour -= offsetHour;\n            minute -= offsetMinute;\n          }\n          return new Date(Date.UTC(year, month, day, hour, minute, second));\n        }\n      }\n      exports.PDFDateString = PDFDateString;\n      function getXfaPageViewport(xfaPage, {\n        scale = 1,\n        rotation = 0\n      }) {\n        const {\n          width,\n          height\n        } = xfaPage.attributes.style;\n        const viewBox = [0, 0, parseInt(width), parseInt(height)];\n        return new PageViewport({\n          viewBox,\n          scale,\n          rotation\n        });\n      }\n\n      /***/\n    }), (/* 2 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;\n      exports.arrayByteLength = arrayByteLength;\n      exports.arraysToBytes = arraysToBytes;\n      exports.assert = assert;\n      exports.bytesToString = bytesToString;\n      exports.createObjectURL = createObjectURL;\n      exports.createPromiseCapability = createPromiseCapability;\n      exports.createValidAbsoluteUrl = createValidAbsoluteUrl;\n      exports.escapeString = escapeString;\n      exports.getModificationDate = getModificationDate;\n      exports.getVerbosityLevel = getVerbosityLevel;\n      exports.info = info;\n      exports.isArrayBuffer = isArrayBuffer;\n      exports.isArrayEqual = isArrayEqual;\n      exports.isAscii = isAscii;\n      exports.isBool = isBool;\n      exports.isNum = isNum;\n      exports.isSameOrigin = isSameOrigin;\n      exports.isString = isString;\n      exports.objectFromMap = objectFromMap;\n      exports.objectSize = objectSize;\n      exports.removeNullCharacters = removeNullCharacters;\n      exports.setVerbosityLevel = setVerbosityLevel;\n      exports.shadow = shadow;\n      exports.string32 = string32;\n      exports.stringToBytes = stringToBytes;\n      exports.stringToPDFString = stringToPDFString;\n      exports.stringToUTF16BEString = stringToUTF16BEString;\n      exports.stringToUTF8String = stringToUTF8String;\n      exports.unreachable = unreachable;\n      exports.utf8StringToString = utf8StringToString;\n      exports.warn = warn;\n      __w_pdfjs_require__(3);\n      const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\n      exports.IDENTITY_MATRIX = IDENTITY_MATRIX;\n      const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\n      exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\n      const RenderingIntentFlag = {\n        ANY: 0x01,\n        DISPLAY: 0x02,\n        PRINT: 0x04,\n        ANNOTATIONS_FORMS: 0x10,\n        ANNOTATIONS_STORAGE: 0x20,\n        ANNOTATIONS_DISABLE: 0x40,\n        OPLIST: 0x100\n      };\n      exports.RenderingIntentFlag = RenderingIntentFlag;\n      const AnnotationMode = {\n        DISABLE: 0,\n        ENABLE: 1,\n        ENABLE_FORMS: 2,\n        ENABLE_STORAGE: 3\n      };\n      exports.AnnotationMode = AnnotationMode;\n      const PermissionFlag = {\n        PRINT: 0x04,\n        MODIFY_CONTENTS: 0x08,\n        COPY: 0x10,\n        MODIFY_ANNOTATIONS: 0x20,\n        FILL_INTERACTIVE_FORMS: 0x100,\n        COPY_FOR_ACCESSIBILITY: 0x200,\n        ASSEMBLE: 0x400,\n        PRINT_HIGH_QUALITY: 0x800\n      };\n      exports.PermissionFlag = PermissionFlag;\n      const TextRenderingMode = {\n        FILL: 0,\n        STROKE: 1,\n        FILL_STROKE: 2,\n        INVISIBLE: 3,\n        FILL_ADD_TO_PATH: 4,\n        STROKE_ADD_TO_PATH: 5,\n        FILL_STROKE_ADD_TO_PATH: 6,\n        ADD_TO_PATH: 7,\n        FILL_STROKE_MASK: 3,\n        ADD_TO_PATH_FLAG: 4\n      };\n      exports.TextRenderingMode = TextRenderingMode;\n      const ImageKind = {\n        GRAYSCALE_1BPP: 1,\n        RGB_24BPP: 2,\n        RGBA_32BPP: 3\n      };\n      exports.ImageKind = ImageKind;\n      const AnnotationType = {\n        TEXT: 1,\n        LINK: 2,\n        FREETEXT: 3,\n        LINE: 4,\n        SQUARE: 5,\n        CIRCLE: 6,\n        POLYGON: 7,\n        POLYLINE: 8,\n        HIGHLIGHT: 9,\n        UNDERLINE: 10,\n        SQUIGGLY: 11,\n        STRIKEOUT: 12,\n        STAMP: 13,\n        CARET: 14,\n        INK: 15,\n        POPUP: 16,\n        FILEATTACHMENT: 17,\n        SOUND: 18,\n        MOVIE: 19,\n        WIDGET: 20,\n        SCREEN: 21,\n        PRINTERMARK: 22,\n        TRAPNET: 23,\n        WATERMARK: 24,\n        THREED: 25,\n        REDACT: 26\n      };\n      exports.AnnotationType = AnnotationType;\n      const AnnotationStateModelType = {\n        MARKED: \"Marked\",\n        REVIEW: \"Review\"\n      };\n      exports.AnnotationStateModelType = AnnotationStateModelType;\n      const AnnotationMarkedState = {\n        MARKED: \"Marked\",\n        UNMARKED: \"Unmarked\"\n      };\n      exports.AnnotationMarkedState = AnnotationMarkedState;\n      const AnnotationReviewState = {\n        ACCEPTED: \"Accepted\",\n        REJECTED: \"Rejected\",\n        CANCELLED: \"Cancelled\",\n        COMPLETED: \"Completed\",\n        NONE: \"None\"\n      };\n      exports.AnnotationReviewState = AnnotationReviewState;\n      const AnnotationReplyType = {\n        GROUP: \"Group\",\n        REPLY: \"R\"\n      };\n      exports.AnnotationReplyType = AnnotationReplyType;\n      const AnnotationFlag = {\n        INVISIBLE: 0x01,\n        HIDDEN: 0x02,\n        PRINT: 0x04,\n        NOZOOM: 0x08,\n        NOROTATE: 0x10,\n        NOVIEW: 0x20,\n        READONLY: 0x40,\n        LOCKED: 0x80,\n        TOGGLENOVIEW: 0x100,\n        LOCKEDCONTENTS: 0x200\n      };\n      exports.AnnotationFlag = AnnotationFlag;\n      const AnnotationFieldFlag = {\n        READONLY: 0x0000001,\n        REQUIRED: 0x0000002,\n        NOEXPORT: 0x0000004,\n        MULTILINE: 0x0001000,\n        PASSWORD: 0x0002000,\n        NOTOGGLETOOFF: 0x0004000,\n        RADIO: 0x0008000,\n        PUSHBUTTON: 0x0010000,\n        COMBO: 0x0020000,\n        EDIT: 0x0040000,\n        SORT: 0x0080000,\n        FILESELECT: 0x0100000,\n        MULTISELECT: 0x0200000,\n        DONOTSPELLCHECK: 0x0400000,\n        DONOTSCROLL: 0x0800000,\n        COMB: 0x1000000,\n        RICHTEXT: 0x2000000,\n        RADIOSINUNISON: 0x2000000,\n        COMMITONSELCHANGE: 0x4000000\n      };\n      exports.AnnotationFieldFlag = AnnotationFieldFlag;\n      const AnnotationBorderStyleType = {\n        SOLID: 1,\n        DASHED: 2,\n        BEVELED: 3,\n        INSET: 4,\n        UNDERLINE: 5\n      };\n      exports.AnnotationBorderStyleType = AnnotationBorderStyleType;\n      const AnnotationActionEventType = {\n        E: \"Mouse Enter\",\n        X: \"Mouse Exit\",\n        D: \"Mouse Down\",\n        U: \"Mouse Up\",\n        Fo: \"Focus\",\n        Bl: \"Blur\",\n        PO: \"PageOpen\",\n        PC: \"PageClose\",\n        PV: \"PageVisible\",\n        PI: \"PageInvisible\",\n        K: \"Keystroke\",\n        F: \"Format\",\n        V: \"Validate\",\n        C: \"Calculate\"\n      };\n      exports.AnnotationActionEventType = AnnotationActionEventType;\n      const DocumentActionEventType = {\n        WC: \"WillClose\",\n        WS: \"WillSave\",\n        DS: \"DidSave\",\n        WP: \"WillPrint\",\n        DP: \"DidPrint\"\n      };\n      exports.DocumentActionEventType = DocumentActionEventType;\n      const PageActionEventType = {\n        O: \"PageOpen\",\n        C: \"PageClose\"\n      };\n      exports.PageActionEventType = PageActionEventType;\n      const StreamType = {\n        UNKNOWN: \"UNKNOWN\",\n        FLATE: \"FLATE\",\n        LZW: \"LZW\",\n        DCT: \"DCT\",\n        JPX: \"JPX\",\n        JBIG: \"JBIG\",\n        A85: \"A85\",\n        AHX: \"AHX\",\n        CCF: \"CCF\",\n        RLX: \"RLX\"\n      };\n      exports.StreamType = StreamType;\n      const FontType = {\n        UNKNOWN: \"UNKNOWN\",\n        TYPE1: \"TYPE1\",\n        TYPE1STANDARD: \"TYPE1STANDARD\",\n        TYPE1C: \"TYPE1C\",\n        CIDFONTTYPE0: \"CIDFONTTYPE0\",\n        CIDFONTTYPE0C: \"CIDFONTTYPE0C\",\n        TRUETYPE: \"TRUETYPE\",\n        CIDFONTTYPE2: \"CIDFONTTYPE2\",\n        TYPE3: \"TYPE3\",\n        OPENTYPE: \"OPENTYPE\",\n        TYPE0: \"TYPE0\",\n        MMTYPE1: \"MMTYPE1\"\n      };\n      exports.FontType = FontType;\n      const VerbosityLevel = {\n        ERRORS: 0,\n        WARNINGS: 1,\n        INFOS: 5\n      };\n      exports.VerbosityLevel = VerbosityLevel;\n      const CMapCompressionType = {\n        NONE: 0,\n        BINARY: 1,\n        STREAM: 2\n      };\n      exports.CMapCompressionType = CMapCompressionType;\n      const OPS = {\n        dependency: 1,\n        setLineWidth: 2,\n        setLineCap: 3,\n        setLineJoin: 4,\n        setMiterLimit: 5,\n        setDash: 6,\n        setRenderingIntent: 7,\n        setFlatness: 8,\n        setGState: 9,\n        save: 10,\n        restore: 11,\n        transform: 12,\n        moveTo: 13,\n        lineTo: 14,\n        curveTo: 15,\n        curveTo2: 16,\n        curveTo3: 17,\n        closePath: 18,\n        rectangle: 19,\n        stroke: 20,\n        closeStroke: 21,\n        fill: 22,\n        eoFill: 23,\n        fillStroke: 24,\n        eoFillStroke: 25,\n        closeFillStroke: 26,\n        closeEOFillStroke: 27,\n        endPath: 28,\n        clip: 29,\n        eoClip: 30,\n        beginText: 31,\n        endText: 32,\n        setCharSpacing: 33,\n        setWordSpacing: 34,\n        setHScale: 35,\n        setLeading: 36,\n        setFont: 37,\n        setTextRenderingMode: 38,\n        setTextRise: 39,\n        moveText: 40,\n        setLeadingMoveText: 41,\n        setTextMatrix: 42,\n        nextLine: 43,\n        showText: 44,\n        showSpacedText: 45,\n        nextLineShowText: 46,\n        nextLineSetSpacingShowText: 47,\n        setCharWidth: 48,\n        setCharWidthAndBounds: 49,\n        setStrokeColorSpace: 50,\n        setFillColorSpace: 51,\n        setStrokeColor: 52,\n        setStrokeColorN: 53,\n        setFillColor: 54,\n        setFillColorN: 55,\n        setStrokeGray: 56,\n        setFillGray: 57,\n        setStrokeRGBColor: 58,\n        setFillRGBColor: 59,\n        setStrokeCMYKColor: 60,\n        setFillCMYKColor: 61,\n        shadingFill: 62,\n        beginInlineImage: 63,\n        beginImageData: 64,\n        endInlineImage: 65,\n        paintXObject: 66,\n        markPoint: 67,\n        markPointProps: 68,\n        beginMarkedContent: 69,\n        beginMarkedContentProps: 70,\n        endMarkedContent: 71,\n        beginCompat: 72,\n        endCompat: 73,\n        paintFormXObjectBegin: 74,\n        paintFormXObjectEnd: 75,\n        beginGroup: 76,\n        endGroup: 77,\n        beginAnnotations: 78,\n        endAnnotations: 79,\n        beginAnnotation: 80,\n        endAnnotation: 81,\n        paintJpegXObject: 82,\n        paintImageMaskXObject: 83,\n        paintImageMaskXObjectGroup: 84,\n        paintImageXObject: 85,\n        paintInlineImageXObject: 86,\n        paintInlineImageXObjectGroup: 87,\n        paintImageXObjectRepeat: 88,\n        paintImageMaskXObjectRepeat: 89,\n        paintSolidColorImageMask: 90,\n        constructPath: 91\n      };\n      exports.OPS = OPS;\n      const UNSUPPORTED_FEATURES = {\n        unknown: \"unknown\",\n        forms: \"forms\",\n        javaScript: \"javaScript\",\n        signatures: \"signatures\",\n        smask: \"smask\",\n        shadingPattern: \"shadingPattern\",\n        font: \"font\",\n        errorTilingPattern: \"errorTilingPattern\",\n        errorExtGState: \"errorExtGState\",\n        errorXObject: \"errorXObject\",\n        errorFontLoadType3: \"errorFontLoadType3\",\n        errorFontState: \"errorFontState\",\n        errorFontMissing: \"errorFontMissing\",\n        errorFontTranslate: \"errorFontTranslate\",\n        errorColorSpace: \"errorColorSpace\",\n        errorOperatorList: \"errorOperatorList\",\n        errorFontToUnicode: \"errorFontToUnicode\",\n        errorFontLoadNative: \"errorFontLoadNative\",\n        errorFontBuildPath: \"errorFontBuildPath\",\n        errorFontGetPath: \"errorFontGetPath\",\n        errorMarkedContent: \"errorMarkedContent\",\n        errorContentSubStream: \"errorContentSubStream\"\n      };\n      exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\n      const PasswordResponses = {\n        NEED_PASSWORD: 1,\n        INCORRECT_PASSWORD: 2\n      };\n      exports.PasswordResponses = PasswordResponses;\n      let verbosity = VerbosityLevel.WARNINGS;\n      function setVerbosityLevel(level) {\n        if (Number.isInteger(level)) {\n          verbosity = level;\n        }\n      }\n      function getVerbosityLevel() {\n        return verbosity;\n      }\n      function info(msg) {\n        if (verbosity >= VerbosityLevel.INFOS) {\n          console.log(`Info: ${msg}`);\n        }\n      }\n      function warn(msg) {\n        if (verbosity >= VerbosityLevel.WARNINGS) {\n          console.log(`Warning: ${msg}`);\n        }\n      }\n      function unreachable(msg) {\n        throw new Error(msg);\n      }\n      function assert(cond, msg) {\n        if (!cond) {\n          unreachable(msg);\n        }\n      }\n      function isSameOrigin(baseUrl, otherUrl) {\n        let base;\n        try {\n          base = new URL(baseUrl);\n          if (!base.origin || base.origin === \"null\") {\n            return false;\n          }\n        } catch (e) {\n          return false;\n        }\n        const other = new URL(otherUrl, base);\n        return base.origin === other.origin;\n      }\n      function _isValidProtocol(url) {\n        if (!url) {\n          return false;\n        }\n        switch (url.protocol) {\n          case \"http:\":\n          case \"https:\":\n          case \"ftp:\":\n          case \"mailto:\":\n          case \"tel:\":\n            return true;\n          default:\n            return false;\n        }\n      }\n      function createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n        if (!url) {\n          return null;\n        }\n        try {\n          if (options && typeof url === \"string\") {\n            if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n              const dots = url.match(/\\./g);\n              if (dots && dots.length >= 2) {\n                url = `http://${url}`;\n              }\n            }\n            if (options.tryConvertEncoding) {\n              try {\n                url = stringToUTF8String(url);\n              } catch (ex) {}\n            }\n          }\n          const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n          if (_isValidProtocol(absoluteUrl)) {\n            return absoluteUrl;\n          }\n        } catch (ex) {}\n        return null;\n      }\n      function shadow(obj, prop, value) {\n        Object.defineProperty(obj, prop, {\n          value,\n          enumerable: true,\n          configurable: true,\n          writable: false\n        });\n        return value;\n      }\n      const BaseException = function BaseExceptionClosure() {\n        function BaseException(message, name) {\n          if (this.constructor === BaseException) {\n            unreachable(\"Cannot initialize BaseException.\");\n          }\n          this.message = message;\n          this.name = name;\n        }\n        BaseException.prototype = new Error();\n        BaseException.constructor = BaseException;\n        return BaseException;\n      }();\n      exports.BaseException = BaseException;\n      class PasswordException extends BaseException {\n        constructor(msg, code) {\n          super(msg, \"PasswordException\");\n          this.code = code;\n        }\n      }\n      exports.PasswordException = PasswordException;\n      class UnknownErrorException extends BaseException {\n        constructor(msg, details) {\n          super(msg, \"UnknownErrorException\");\n          this.details = details;\n        }\n      }\n      exports.UnknownErrorException = UnknownErrorException;\n      class InvalidPDFException extends BaseException {\n        constructor(msg) {\n          super(msg, \"InvalidPDFException\");\n        }\n      }\n      exports.InvalidPDFException = InvalidPDFException;\n      class MissingPDFException extends BaseException {\n        constructor(msg) {\n          super(msg, \"MissingPDFException\");\n        }\n      }\n      exports.MissingPDFException = MissingPDFException;\n      class UnexpectedResponseException extends BaseException {\n        constructor(msg, status) {\n          super(msg, \"UnexpectedResponseException\");\n          this.status = status;\n        }\n      }\n      exports.UnexpectedResponseException = UnexpectedResponseException;\n      class FormatError extends BaseException {\n        constructor(msg) {\n          super(msg, \"FormatError\");\n        }\n      }\n      exports.FormatError = FormatError;\n      class AbortException extends BaseException {\n        constructor(msg) {\n          super(msg, \"AbortException\");\n        }\n      }\n      exports.AbortException = AbortException;\n      const NullCharactersRegExp = /\\x00+/g;\n      const InvisibleCharactersRegExp = /[\\x01-\\x1F]/g;\n      function removeNullCharacters(str, replaceInvisible = false) {\n        if (typeof str !== \"string\") {\n          warn(\"The argument for removeNullCharacters must be a string.\");\n          return str;\n        }\n        if (replaceInvisible) {\n          str = str.replace(InvisibleCharactersRegExp, \" \");\n        }\n        return str.replace(NullCharactersRegExp, \"\");\n      }\n      function bytesToString(bytes) {\n        assert(bytes !== null && typeof bytes === \"object\" && bytes.length !== undefined, \"Invalid argument for bytesToString\");\n        const length = bytes.length;\n        const MAX_ARGUMENT_COUNT = 8192;\n        if (length < MAX_ARGUMENT_COUNT) {\n          return String.fromCharCode.apply(null, bytes);\n        }\n        const strBuf = [];\n        for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n          const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n          const chunk = bytes.subarray(i, chunkEnd);\n          strBuf.push(String.fromCharCode.apply(null, chunk));\n        }\n        return strBuf.join(\"\");\n      }\n      function stringToBytes(str) {\n        assert(typeof str === \"string\", \"Invalid argument for stringToBytes\");\n        const length = str.length;\n        const bytes = new Uint8Array(length);\n        for (let i = 0; i < length; ++i) {\n          bytes[i] = str.charCodeAt(i) & 0xff;\n        }\n        return bytes;\n      }\n      function arrayByteLength(arr) {\n        if (arr.length !== undefined) {\n          return arr.length;\n        }\n        assert(arr.byteLength !== undefined, \"arrayByteLength - invalid argument.\");\n        return arr.byteLength;\n      }\n      function arraysToBytes(arr) {\n        const length = arr.length;\n        if (length === 1 && arr[0] instanceof Uint8Array) {\n          return arr[0];\n        }\n        let resultLength = 0;\n        for (let i = 0; i < length; i++) {\n          resultLength += arrayByteLength(arr[i]);\n        }\n        let pos = 0;\n        const data = new Uint8Array(resultLength);\n        for (let i = 0; i < length; i++) {\n          let item = arr[i];\n          if (!(item instanceof Uint8Array)) {\n            if (typeof item === \"string\") {\n              item = stringToBytes(item);\n            } else {\n              item = new Uint8Array(item);\n            }\n          }\n          const itemLength = item.byteLength;\n          data.set(item, pos);\n          pos += itemLength;\n        }\n        return data;\n      }\n      function string32(value) {\n        return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n      }\n      function objectSize(obj) {\n        return Object.keys(obj).length;\n      }\n      function objectFromMap(map) {\n        const obj = Object.create(null);\n        for (const [key, value] of map) {\n          obj[key] = value;\n        }\n        return obj;\n      }\n      function isLittleEndian() {\n        const buffer8 = new Uint8Array(4);\n        buffer8[0] = 1;\n        const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n        return view32[0] === 1;\n      }\n      const IsLittleEndianCached = {\n        get value() {\n          return shadow(this, \"value\", isLittleEndian());\n        }\n      };\n      exports.IsLittleEndianCached = IsLittleEndianCached;\n      function isEvalSupported() {\n        try {\n          new Function(\"\");\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n      const IsEvalSupportedCached = {\n        get value() {\n          return shadow(this, \"value\", isEvalSupported());\n        }\n      };\n      exports.IsEvalSupportedCached = IsEvalSupportedCached;\n      const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, \"0\"));\n      class Util {\n        static makeHexColor(r, g, b) {\n          return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n        }\n        static transform(m1, m2) {\n          return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n        }\n        static applyTransform(p, m) {\n          const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n          const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n          return [xt, yt];\n        }\n        static applyInverseTransform(p, m) {\n          const d = m[0] * m[3] - m[1] * m[2];\n          const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n          const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n          return [xt, yt];\n        }\n        static getAxialAlignedBoundingBox(r, m) {\n          const p1 = Util.applyTransform(r, m);\n          const p2 = Util.applyTransform(r.slice(2, 4), m);\n          const p3 = Util.applyTransform([r[0], r[3]], m);\n          const p4 = Util.applyTransform([r[2], r[1]], m);\n          return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n        }\n        static inverseTransform(m) {\n          const d = m[0] * m[3] - m[1] * m[2];\n          return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n        }\n        static apply3dTransform(m, v) {\n          return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n        }\n        static singularValueDecompose2dScale(m) {\n          const transpose = [m[0], m[2], m[1], m[3]];\n          const a = m[0] * transpose[0] + m[1] * transpose[2];\n          const b = m[0] * transpose[1] + m[1] * transpose[3];\n          const c = m[2] * transpose[0] + m[3] * transpose[2];\n          const d = m[2] * transpose[1] + m[3] * transpose[3];\n          const first = (a + d) / 2;\n          const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n          const sx = first + second || 1;\n          const sy = first - second || 1;\n          return [Math.sqrt(sx), Math.sqrt(sy)];\n        }\n        static normalizeRect(rect) {\n          const r = rect.slice(0);\n          if (rect[0] > rect[2]) {\n            r[0] = rect[2];\n            r[2] = rect[0];\n          }\n          if (rect[1] > rect[3]) {\n            r[1] = rect[3];\n            r[3] = rect[1];\n          }\n          return r;\n        }\n        static intersect(rect1, rect2) {\n          function compare(a, b) {\n            return a - b;\n          }\n          const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);\n          const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);\n          const result = [];\n          rect1 = Util.normalizeRect(rect1);\n          rect2 = Util.normalizeRect(rect2);\n          if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {\n            result[0] = orderedX[1];\n            result[2] = orderedX[2];\n          } else {\n            return null;\n          }\n          if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {\n            result[1] = orderedY[1];\n            result[3] = orderedY[2];\n          } else {\n            return null;\n          }\n          return result;\n        }\n        static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n          const tvalues = [],\n            bounds = [[], []];\n          let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n          for (let i = 0; i < 2; ++i) {\n            if (i === 0) {\n              b = 6 * x0 - 12 * x1 + 6 * x2;\n              a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n              c = 3 * x1 - 3 * x0;\n            } else {\n              b = 6 * y0 - 12 * y1 + 6 * y2;\n              a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n              c = 3 * y1 - 3 * y0;\n            }\n            if (Math.abs(a) < 1e-12) {\n              if (Math.abs(b) < 1e-12) {\n                continue;\n              }\n              t = -c / b;\n              if (0 < t && t < 1) {\n                tvalues.push(t);\n              }\n              continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = Math.sqrt(b2ac);\n            if (b2ac < 0) {\n              continue;\n            }\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n              tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n              tvalues.push(t2);\n            }\n          }\n          let j = tvalues.length,\n            mt;\n          const jlen = j;\n          while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n            bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n            bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n          }\n          bounds[0][jlen] = x0;\n          bounds[1][jlen] = y0;\n          bounds[0][jlen + 1] = x3;\n          bounds[1][jlen + 1] = y3;\n          bounds[0].length = bounds[1].length = jlen + 2;\n          return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];\n        }\n      }\n      exports.Util = Util;\n      const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];\n      function stringToPDFString(str) {\n        const length = str.length,\n          strBuf = [];\n        if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n          for (let i = 2; i < length; i += 2) {\n            strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));\n          }\n        } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n          for (let i = 2; i < length; i += 2) {\n            strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i)));\n          }\n        } else {\n          for (let i = 0; i < length; ++i) {\n            const code = PDFStringTranslateTable[str.charCodeAt(i)];\n            strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n          }\n        }\n        return strBuf.join(\"\");\n      }\n      function escapeString(str) {\n        return str.replace(/([()\\\\\\n\\r])/g, match => {\n          if (match === \"\\n\") {\n            return \"\\\\n\";\n          } else if (match === \"\\r\") {\n            return \"\\\\r\";\n          }\n          return `\\\\${match}`;\n        });\n      }\n      function isAscii(str) {\n        return /^[\\x00-\\x7F]*$/.test(str);\n      }\n      function stringToUTF16BEString(str) {\n        const buf = [\"\\xFE\\xFF\"];\n        for (let i = 0, ii = str.length; i < ii; i++) {\n          const char = str.charCodeAt(i);\n          buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));\n        }\n        return buf.join(\"\");\n      }\n      function stringToUTF8String(str) {\n        return decodeURIComponent(escape(str));\n      }\n      function utf8StringToString(str) {\n        return unescape(encodeURIComponent(str));\n      }\n      function isBool(v) {\n        return typeof v === \"boolean\";\n      }\n      function isNum(v) {\n        return typeof v === \"number\";\n      }\n      function isString(v) {\n        return typeof v === \"string\";\n      }\n      function isArrayBuffer(v) {\n        return typeof v === \"object\" && v !== null && v.byteLength !== undefined;\n      }\n      function isArrayEqual(arr1, arr2) {\n        if (arr1.length !== arr2.length) {\n          return false;\n        }\n        for (let i = 0, ii = arr1.length; i < ii; i++) {\n          if (arr1[i] !== arr2[i]) {\n            return false;\n          }\n        }\n        return true;\n      }\n      function getModificationDate(date = new Date()) {\n        const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n        return buffer.join(\"\");\n      }\n      function createPromiseCapability() {\n        const capability = Object.create(null);\n        let isSettled = false;\n        Object.defineProperty(capability, \"settled\", {\n          get() {\n            return isSettled;\n          }\n        });\n        capability.promise = new Promise(function (resolve, reject) {\n          capability.resolve = function (data) {\n            isSettled = true;\n            resolve(data);\n          };\n          capability.reject = function (reason) {\n            isSettled = true;\n            reject(reason);\n          };\n        });\n        return capability;\n      }\n      function createObjectURL(data, contentType = \"\", forceDataSchema = false) {\n        if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) {\n          return URL.createObjectURL(new Blob([data], {\n            type: contentType\n          }));\n        }\n        const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        let buffer = `data:${contentType};base64,`;\n        for (let i = 0, ii = data.length; i < ii; i += 3) {\n          const b1 = data[i] & 0xff;\n          const b2 = data[i + 1] & 0xff;\n          const b3 = data[i + 2] & 0xff;\n          const d1 = b1 >> 2,\n            d2 = (b1 & 3) << 4 | b2 >> 4;\n          const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n          const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n          buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n        }\n        return buffer;\n      }\n\n      /***/\n    }), (/* 3 */\n    /***/(__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n      var _is_node = __w_pdfjs_require__(4);\n      ;\n\n      /***/\n    }), (/* 4 */\n    /***/(__unused_webpack_module, exports) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.isNodeJS = void 0;\n      const isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\n      exports.isNodeJS = isNodeJS;\n\n      /***/\n    }), (/* 5 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;\n      var _util = __w_pdfjs_require__(2);\n      class BaseCanvasFactory {\n        constructor() {\n          if (this.constructor === BaseCanvasFactory) {\n            (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n          }\n        }\n        create(width, height) {\n          if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n          }\n          const canvas = this._createCanvas(width, height);\n          return {\n            canvas,\n            context: canvas.getContext(\"2d\")\n          };\n        }\n        reset(canvasAndContext, width, height) {\n          if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n          }\n          if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n          }\n          canvasAndContext.canvas.width = width;\n          canvasAndContext.canvas.height = height;\n        }\n        destroy(canvasAndContext) {\n          if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n          }\n          canvasAndContext.canvas.width = 0;\n          canvasAndContext.canvas.height = 0;\n          canvasAndContext.canvas = null;\n          canvasAndContext.context = null;\n        }\n        _createCanvas(width, height) {\n          (0, _util.unreachable)(\"Abstract method `_createCanvas` called.\");\n        }\n      }\n      exports.BaseCanvasFactory = BaseCanvasFactory;\n      class BaseCMapReaderFactory {\n        constructor({\n          baseUrl = null,\n          isCompressed = false\n        }) {\n          if (this.constructor === BaseCMapReaderFactory) {\n            (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n          }\n          this.baseUrl = baseUrl;\n          this.isCompressed = isCompressed;\n        }\n        async fetch({\n          name\n        }) {\n          if (!this.baseUrl) {\n            throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n          }\n          if (!name) {\n            throw new Error(\"CMap name must be specified.\");\n          }\n          const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n          const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n          return this._fetchData(url, compressionType).catch(reason => {\n            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n          });\n        }\n        _fetchData(url, compressionType) {\n          (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n        }\n      }\n      exports.BaseCMapReaderFactory = BaseCMapReaderFactory;\n      class BaseStandardFontDataFactory {\n        constructor({\n          baseUrl = null\n        }) {\n          if (this.constructor === BaseStandardFontDataFactory) {\n            (0, _util.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n          }\n          this.baseUrl = baseUrl;\n        }\n        async fetch({\n          filename\n        }) {\n          if (!this.baseUrl) {\n            throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n          }\n          if (!filename) {\n            throw new Error(\"Font filename must be specified.\");\n          }\n          const url = `${this.baseUrl}${filename}`;\n          return this._fetchData(url).catch(reason => {\n            throw new Error(`Unable to load font data at: ${url}`);\n          });\n        }\n        _fetchData(url) {\n          (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n        }\n      }\n      exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;\n      class BaseSVGFactory {\n        constructor() {\n          if (this.constructor === BaseSVGFactory) {\n            (0, _util.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n          }\n        }\n        create(width, height) {\n          if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid SVG dimensions\");\n          }\n          const svg = this._createSVG(\"svg:svg\");\n          svg.setAttribute(\"version\", \"1.1\");\n          svg.setAttribute(\"width\", `${width}px`);\n          svg.setAttribute(\"height\", `${height}px`);\n          svg.setAttribute(\"preserveAspectRatio\", \"none\");\n          svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n          return svg;\n        }\n        createElement(type) {\n          if (typeof type !== \"string\") {\n            throw new Error(\"Invalid SVG element type\");\n          }\n          return this._createSVG(type);\n        }\n        _createSVG(type) {\n          (0, _util.unreachable)(\"Abstract method `_createSVG` called.\");\n        }\n      }\n      exports.BaseSVGFactory = BaseSVGFactory;\n\n      /***/\n    }), (/* 6 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.build = exports.RenderTask = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;\n      exports.getDocument = getDocument;\n      exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;\n      exports.version = void 0;\n      var _util = __w_pdfjs_require__(2);\n      var _display_utils = __w_pdfjs_require__(1);\n      var _font_loader = __w_pdfjs_require__(7);\n      var _node_utils = __w_pdfjs_require__(8);\n      var _annotation_storage = __w_pdfjs_require__(9);\n      var _canvas = __w_pdfjs_require__(10);\n      var _worker_options = __w_pdfjs_require__(12);\n      var _is_node = __w_pdfjs_require__(4);\n      var _message_handler = __w_pdfjs_require__(13);\n      var _metadata = __w_pdfjs_require__(14);\n      var _optional_content_config = __w_pdfjs_require__(15);\n      var _transport_stream = __w_pdfjs_require__(16);\n      var _xfa_text = __w_pdfjs_require__(17);\n      const DEFAULT_RANGE_CHUNK_SIZE = 65536;\n      const RENDERING_CANCELLED_TIMEOUT = 100;\n      const DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\n      exports.DefaultCanvasFactory = DefaultCanvasFactory;\n      const DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\n      exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\n      const DefaultStandardFontDataFactory = _is_node.isNodeJS ? _node_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;\n      exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;\n      let createPDFNetworkStream;\n      function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\n        createPDFNetworkStream = pdfNetworkStreamFactory;\n      }\n      function getDocument(src) {\n        const task = new PDFDocumentLoadingTask();\n        let source;\n        if (typeof src === \"string\" || src instanceof URL) {\n          source = {\n            url: src\n          };\n        } else if ((0, _util.isArrayBuffer)(src)) {\n          source = {\n            data: src\n          };\n        } else if (src instanceof PDFDataRangeTransport) {\n          source = {\n            range: src\n          };\n        } else {\n          if (typeof src !== \"object\") {\n            throw new Error(\"Invalid parameter in getDocument, \" + \"need either string, URL, Uint8Array, or parameter object.\");\n          }\n          if (!src.url && !src.data && !src.range) {\n            throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n          }\n          source = src;\n        }\n        const params = Object.create(null);\n        let rangeTransport = null,\n          worker = null;\n        for (const key in source) {\n          const value = source[key];\n          switch (key) {\n            case \"url\":\n              if (typeof window !== \"undefined\") {\n                try {\n                  params[key] = new URL(value, window.location).href;\n                  continue;\n                } catch (ex) {\n                  (0, _util.warn)(`Cannot create valid URL: \"${ex}\".`);\n                }\n              } else if (typeof value === \"string\" || value instanceof URL) {\n                params[key] = value.toString();\n                continue;\n              }\n              throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n            case \"range\":\n              rangeTransport = value;\n              continue;\n            case \"worker\":\n              worker = value;\n              continue;\n            case \"data\":\n              if (_is_node.isNodeJS && typeof Buffer !== \"undefined\" && value instanceof Buffer) {\n                params[key] = new Uint8Array(value);\n              } else if (value instanceof Uint8Array) {\n                break;\n              } else if (typeof value === \"string\") {\n                params[key] = (0, _util.stringToBytes)(value);\n              } else if (typeof value === \"object\" && value !== null && !isNaN(value.length)) {\n                params[key] = new Uint8Array(value);\n              } else if ((0, _util.isArrayBuffer)(value)) {\n                params[key] = new Uint8Array(value);\n              } else {\n                throw new Error(\"Invalid PDF binary data: either typed array, \" + \"string, or array-like object is expected in the data property.\");\n              }\n              continue;\n          }\n          params[key] = value;\n        }\n        params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;\n        params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;\n        params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;\n        params.ignoreErrors = params.stopAtErrors !== true;\n        params.fontExtraProperties = params.fontExtraProperties === true;\n        params.pdfBug = params.pdfBug === true;\n        params.enableXfa = params.enableXfa === true;\n        if (typeof params.docBaseUrl !== \"string\" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {\n          params.docBaseUrl = null;\n        }\n        if (!Number.isInteger(params.maxImageSize)) {\n          params.maxImageSize = -1;\n        }\n        if (typeof params.useWorkerFetch !== \"boolean\") {\n          params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;\n        }\n        if (typeof params.isEvalSupported !== \"boolean\") {\n          params.isEvalSupported = true;\n        }\n        if (typeof params.disableFontFace !== \"boolean\") {\n          params.disableFontFace = _is_node.isNodeJS;\n        }\n        if (typeof params.useSystemFonts !== \"boolean\") {\n          params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;\n        }\n        if (typeof params.ownerDocument === \"undefined\") {\n          params.ownerDocument = globalThis.document;\n        }\n        if (typeof params.disableRange !== \"boolean\") {\n          params.disableRange = false;\n        }\n        if (typeof params.disableStream !== \"boolean\") {\n          params.disableStream = false;\n        }\n        if (typeof params.disableAutoFetch !== \"boolean\") {\n          params.disableAutoFetch = false;\n        }\n        (0, _util.setVerbosityLevel)(params.verbosity);\n        if (!worker) {\n          const workerParams = {\n            verbosity: params.verbosity,\n            port: _worker_options.GlobalWorkerOptions.workerPort\n          };\n          worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n          task._worker = worker;\n        }\n        const docId = task.docId;\n        worker.promise.then(function () {\n          if (task.destroyed) {\n            throw new Error(\"Loading aborted\");\n          }\n          const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);\n          const networkStreamPromise = new Promise(function (resolve) {\n            let networkStream;\n            if (rangeTransport) {\n              networkStream = new _transport_stream.PDFDataTransportStream({\n                length: params.length,\n                initialData: params.initialData,\n                progressiveDone: params.progressiveDone,\n                contentDispositionFilename: params.contentDispositionFilename,\n                disableRange: params.disableRange,\n                disableStream: params.disableStream\n              }, rangeTransport);\n            } else if (!params.data) {\n              networkStream = createPDFNetworkStream({\n                url: params.url,\n                length: params.length,\n                httpHeaders: params.httpHeaders,\n                withCredentials: params.withCredentials,\n                rangeChunkSize: params.rangeChunkSize,\n                disableRange: params.disableRange,\n                disableStream: params.disableStream\n              });\n            }\n            resolve(networkStream);\n          });\n          return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {\n            if (task.destroyed) {\n              throw new Error(\"Loading aborted\");\n            }\n            const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n            const transport = new WorkerTransport(messageHandler, task, networkStream, params);\n            task._transport = transport;\n            messageHandler.send(\"Ready\", null);\n          });\n        }).catch(task._capability.reject);\n        return task;\n      }\n      async function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\n        if (worker.destroyed) {\n          throw new Error(\"Worker was destroyed\");\n        }\n        if (pdfDataRangeTransport) {\n          source.length = pdfDataRangeTransport.length;\n          source.initialData = pdfDataRangeTransport.initialData;\n          source.progressiveDone = pdfDataRangeTransport.progressiveDone;\n          source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;\n        }\n        const workerId = await worker.messageHandler.sendWithPromise(\"GetDocRequest\", {\n          docId,\n          apiVersion: '2.12.313',\n          source: {\n            data: source.data,\n            url: source.url,\n            password: source.password,\n            disableAutoFetch: source.disableAutoFetch,\n            rangeChunkSize: source.rangeChunkSize,\n            length: source.length\n          },\n          maxImageSize: source.maxImageSize,\n          disableFontFace: source.disableFontFace,\n          docBaseUrl: source.docBaseUrl,\n          ignoreErrors: source.ignoreErrors,\n          isEvalSupported: source.isEvalSupported,\n          fontExtraProperties: source.fontExtraProperties,\n          enableXfa: source.enableXfa,\n          useSystemFonts: source.useSystemFonts,\n          cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,\n          standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null\n        });\n        if (worker.destroyed) {\n          throw new Error(\"Worker was destroyed\");\n        }\n        return workerId;\n      }\n      class PDFDocumentLoadingTask {\n        static get idCounters() {\n          return (0, _util.shadow)(this, \"idCounters\", {\n            doc: 0\n          });\n        }\n        constructor() {\n          this._capability = (0, _util.createPromiseCapability)();\n          this._transport = null;\n          this._worker = null;\n          this.docId = `d${PDFDocumentLoadingTask.idCounters.doc++}`;\n          this.destroyed = false;\n          this.onPassword = null;\n          this.onProgress = null;\n          this.onUnsupportedFeature = null;\n        }\n        get promise() {\n          return this._capability.promise;\n        }\n        async destroy() {\n          this.destroyed = true;\n          await this._transport?.destroy();\n          this._transport = null;\n          if (this._worker) {\n            this._worker.destroy();\n            this._worker = null;\n          }\n        }\n      }\n      exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;\n      class PDFDataRangeTransport {\n        constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {\n          this.length = length;\n          this.initialData = initialData;\n          this.progressiveDone = progressiveDone;\n          this.contentDispositionFilename = contentDispositionFilename;\n          this._rangeListeners = [];\n          this._progressListeners = [];\n          this._progressiveReadListeners = [];\n          this._progressiveDoneListeners = [];\n          this._readyCapability = (0, _util.createPromiseCapability)();\n        }\n        addRangeListener(listener) {\n          this._rangeListeners.push(listener);\n        }\n        addProgressListener(listener) {\n          this._progressListeners.push(listener);\n        }\n        addProgressiveReadListener(listener) {\n          this._progressiveReadListeners.push(listener);\n        }\n        addProgressiveDoneListener(listener) {\n          this._progressiveDoneListeners.push(listener);\n        }\n        onDataRange(begin, chunk) {\n          for (const listener of this._rangeListeners) {\n            listener(begin, chunk);\n          }\n        }\n        onDataProgress(loaded, total) {\n          this._readyCapability.promise.then(() => {\n            for (const listener of this._progressListeners) {\n              listener(loaded, total);\n            }\n          });\n        }\n        onDataProgressiveRead(chunk) {\n          this._readyCapability.promise.then(() => {\n            for (const listener of this._progressiveReadListeners) {\n              listener(chunk);\n            }\n          });\n        }\n        onDataProgressiveDone() {\n          this._readyCapability.promise.then(() => {\n            for (const listener of this._progressiveDoneListeners) {\n              listener();\n            }\n          });\n        }\n        transportReady() {\n          this._readyCapability.resolve();\n        }\n        requestDataRange(begin, end) {\n          (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n        }\n        abort() {}\n      }\n      exports.PDFDataRangeTransport = PDFDataRangeTransport;\n      class PDFDocumentProxy {\n        constructor(pdfInfo, transport) {\n          this._pdfInfo = pdfInfo;\n          this._transport = transport;\n          Object.defineProperty(this, \"fingerprint\", {\n            get() {\n              (0, _display_utils.deprecated)(\"`PDFDocumentProxy.fingerprint`, \" + \"please use `PDFDocumentProxy.fingerprints` instead.\");\n              return this.fingerprints[0];\n            }\n          });\n          Object.defineProperty(this, \"getStats\", {\n            value: async () => {\n              (0, _display_utils.deprecated)(\"`PDFDocumentProxy.getStats`, \" + \"please use the `PDFDocumentProxy.stats`-getter instead.\");\n              return this.stats || {\n                streamTypes: {},\n                fontTypes: {}\n              };\n            }\n          });\n        }\n        get annotationStorage() {\n          return this._transport.annotationStorage;\n        }\n        get numPages() {\n          return this._pdfInfo.numPages;\n        }\n        get fingerprints() {\n          return this._pdfInfo.fingerprints;\n        }\n        get stats() {\n          return this._transport.stats;\n        }\n        get isPureXfa() {\n          return !!this._transport._htmlForXfa;\n        }\n        get allXfaHtml() {\n          return this._transport._htmlForXfa;\n        }\n        getPage(pageNumber) {\n          return this._transport.getPage(pageNumber);\n        }\n        getPageIndex(ref) {\n          return this._transport.getPageIndex(ref);\n        }\n        getDestinations() {\n          return this._transport.getDestinations();\n        }\n        getDestination(id) {\n          return this._transport.getDestination(id);\n        }\n        getPageLabels() {\n          return this._transport.getPageLabels();\n        }\n        getPageLayout() {\n          return this._transport.getPageLayout();\n        }\n        getPageMode() {\n          return this._transport.getPageMode();\n        }\n        getViewerPreferences() {\n          return this._transport.getViewerPreferences();\n        }\n        getOpenAction() {\n          return this._transport.getOpenAction();\n        }\n        getAttachments() {\n          return this._transport.getAttachments();\n        }\n        getJavaScript() {\n          return this._transport.getJavaScript();\n        }\n        getJSActions() {\n          return this._transport.getDocJSActions();\n        }\n        getOutline() {\n          return this._transport.getOutline();\n        }\n        getOptionalContentConfig() {\n          return this._transport.getOptionalContentConfig();\n        }\n        getPermissions() {\n          return this._transport.getPermissions();\n        }\n        getMetadata() {\n          return this._transport.getMetadata();\n        }\n        getMarkInfo() {\n          return this._transport.getMarkInfo();\n        }\n        getData() {\n          return this._transport.getData();\n        }\n        getDownloadInfo() {\n          return this._transport.downloadInfoCapability.promise;\n        }\n        cleanup(keepLoadedFonts = false) {\n          return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n        }\n        destroy() {\n          return this.loadingTask.destroy();\n        }\n        get loadingParams() {\n          return this._transport.loadingParams;\n        }\n        get loadingTask() {\n          return this._transport.loadingTask;\n        }\n        saveDocument() {\n          if (this._transport.annotationStorage.size <= 0) {\n            (0, _display_utils.deprecated)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n          }\n          return this._transport.saveDocument();\n        }\n        getFieldObjects() {\n          return this._transport.getFieldObjects();\n        }\n        hasJSActions() {\n          return this._transport.hasJSActions();\n        }\n        getCalculationOrderIds() {\n          return this._transport.getCalculationOrderIds();\n        }\n      }\n      exports.PDFDocumentProxy = PDFDocumentProxy;\n      class PDFPageProxy {\n        constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {\n          this._pageIndex = pageIndex;\n          this._pageInfo = pageInfo;\n          this._ownerDocument = ownerDocument;\n          this._transport = transport;\n          this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n          this._pdfBug = pdfBug;\n          this.commonObjs = transport.commonObjs;\n          this.objs = new PDFObjects();\n          this.cleanupAfterRender = false;\n          this.pendingCleanup = false;\n          this._intentStates = new Map();\n          this._annotationPromises = new Map();\n          this.destroyed = false;\n        }\n        get pageNumber() {\n          return this._pageIndex + 1;\n        }\n        get rotate() {\n          return this._pageInfo.rotate;\n        }\n        get ref() {\n          return this._pageInfo.ref;\n        }\n        get userUnit() {\n          return this._pageInfo.userUnit;\n        }\n        get view() {\n          return this._pageInfo.view;\n        }\n        getViewport({\n          scale,\n          rotation = this.rotate,\n          offsetX = 0,\n          offsetY = 0,\n          dontFlip = false\n        } = {}) {\n          return new _display_utils.PageViewport({\n            viewBox: this.view,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n          });\n        }\n        getAnnotations({\n          intent = \"display\"\n        } = {}) {\n          const intentArgs = this._transport.getRenderingIntent(intent);\n          let promise = this._annotationPromises.get(intentArgs.cacheKey);\n          if (!promise) {\n            promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);\n            this._annotationPromises.set(intentArgs.cacheKey, promise);\n            promise = promise.then(annotations => {\n              for (const annotation of annotations) {\n                if (annotation.titleObj !== undefined) {\n                  Object.defineProperty(annotation, \"title\", {\n                    get() {\n                      (0, _display_utils.deprecated)(\"`title`-property on annotation, please use `titleObj` instead.\");\n                      return annotation.titleObj.str;\n                    }\n                  });\n                }\n                if (annotation.contentsObj !== undefined) {\n                  Object.defineProperty(annotation, \"contents\", {\n                    get() {\n                      (0, _display_utils.deprecated)(\"`contents`-property on annotation, please use `contentsObj` instead.\");\n                      return annotation.contentsObj.str;\n                    }\n                  });\n                }\n              }\n              return annotations;\n            });\n          }\n          return promise;\n        }\n        getJSActions() {\n          return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex);\n        }\n        async getXfa() {\n          return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n        }\n        render({\n          canvasContext,\n          viewport,\n          intent = \"display\",\n          annotationMode = _util.AnnotationMode.ENABLE,\n          transform = null,\n          imageLayer = null,\n          canvasFactory = null,\n          background = null,\n          optionalContentConfigPromise = null,\n          annotationCanvasMap = null\n        }) {\n          if (arguments[0]?.renderInteractiveForms !== undefined) {\n            (0, _display_utils.deprecated)(\"render no longer accepts the `renderInteractiveForms`-option, \" + \"please use the `annotationMode`-option instead.\");\n            if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {\n              annotationMode = _util.AnnotationMode.ENABLE_FORMS;\n            }\n          }\n          if (arguments[0]?.includeAnnotationStorage !== undefined) {\n            (0, _display_utils.deprecated)(\"render no longer accepts the `includeAnnotationStorage`-option, \" + \"please use the `annotationMode`-option instead.\");\n            if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {\n              annotationMode = _util.AnnotationMode.ENABLE_STORAGE;\n            }\n          }\n          if (this._stats) {\n            this._stats.time(\"Overall\");\n          }\n          const intentArgs = this._transport.getRenderingIntent(intent, annotationMode);\n          this.pendingCleanup = false;\n          if (!optionalContentConfigPromise) {\n            optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n          }\n          let intentState = this._intentStates.get(intentArgs.cacheKey);\n          if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(intentArgs.cacheKey, intentState);\n          }\n          if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n          }\n          const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({\n            ownerDocument: this._ownerDocument\n          });\n          const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);\n          if (!intentState.displayReadyCapability) {\n            intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\n            intentState.operatorList = {\n              fnArray: [],\n              argsArray: [],\n              lastChunk: false\n            };\n            if (this._stats) {\n              this._stats.time(\"Page Request\");\n            }\n            this._pumpOperatorList(intentArgs);\n          }\n          const complete = error => {\n            intentState.renderTasks.delete(internalRenderTask);\n            if (this.cleanupAfterRender || intentPrint) {\n              this.pendingCleanup = true;\n            }\n            this._tryCleanup();\n            if (error) {\n              internalRenderTask.capability.reject(error);\n              this._abortOperatorList({\n                intentState,\n                reason: error instanceof Error ? error : new Error(error)\n              });\n            } else {\n              internalRenderTask.capability.resolve();\n            }\n            if (this._stats) {\n              this._stats.timeEnd(\"Rendering\");\n              this._stats.timeEnd(\"Overall\");\n            }\n          };\n          const internalRenderTask = new InternalRenderTask({\n            callback: complete,\n            params: {\n              canvasContext,\n              viewport,\n              transform,\n              imageLayer,\n              background\n            },\n            objs: this.objs,\n            commonObjs: this.commonObjs,\n            annotationCanvasMap,\n            operatorList: intentState.operatorList,\n            pageIndex: this._pageIndex,\n            canvasFactory: canvasFactoryInstance,\n            useRequestAnimationFrame: !intentPrint,\n            pdfBug: this._pdfBug\n          });\n          (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n          const renderTask = internalRenderTask.task;\n          Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\n            if (this.pendingCleanup) {\n              complete();\n              return;\n            }\n            if (this._stats) {\n              this._stats.time(\"Rendering\");\n            }\n            internalRenderTask.initializeGraphics({\n              transparency,\n              optionalContentConfig\n            });\n            internalRenderTask.operatorListChanged();\n          }).catch(complete);\n          return renderTask;\n        }\n        getOperatorList({\n          intent = \"display\",\n          annotationMode = _util.AnnotationMode.ENABLE\n        } = {}) {\n          function operatorListChanged() {\n            if (intentState.operatorList.lastChunk) {\n              intentState.opListReadCapability.resolve(intentState.operatorList);\n              intentState.renderTasks.delete(opListTask);\n            }\n          }\n          const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, true);\n          let intentState = this._intentStates.get(intentArgs.cacheKey);\n          if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(intentArgs.cacheKey, intentState);\n          }\n          let opListTask;\n          if (!intentState.opListReadCapability) {\n            opListTask = Object.create(null);\n            opListTask.operatorListChanged = operatorListChanged;\n            intentState.opListReadCapability = (0, _util.createPromiseCapability)();\n            (intentState.renderTasks ||= new Set()).add(opListTask);\n            intentState.operatorList = {\n              fnArray: [],\n              argsArray: [],\n              lastChunk: false\n            };\n            if (this._stats) {\n              this._stats.time(\"Page Request\");\n            }\n            this._pumpOperatorList(intentArgs);\n          }\n          return intentState.opListReadCapability.promise;\n        }\n        streamTextContent({\n          normalizeWhitespace = false,\n          disableCombineTextItems = false,\n          includeMarkedContent = false\n        } = {}) {\n          const TEXT_CONTENT_CHUNK_SIZE = 100;\n          return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n            pageIndex: this._pageIndex,\n            normalizeWhitespace: normalizeWhitespace === true,\n            combineTextItems: disableCombineTextItems !== true,\n            includeMarkedContent: includeMarkedContent === true\n          }, {\n            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n            size(textContent) {\n              return textContent.items.length;\n            }\n          });\n        }\n        getTextContent(params = {}) {\n          if (this._transport._htmlForXfa) {\n            return this.getXfa().then(xfa => {\n              return _xfa_text.XfaText.textContent(xfa);\n            });\n          }\n          const readableStream = this.streamTextContent(params);\n          return new Promise(function (resolve, reject) {\n            function pump() {\n              reader.read().then(function ({\n                value,\n                done\n              }) {\n                if (done) {\n                  resolve(textContent);\n                  return;\n                }\n                Object.assign(textContent.styles, value.styles);\n                textContent.items.push(...value.items);\n                pump();\n              }, reject);\n            }\n            const reader = readableStream.getReader();\n            const textContent = {\n              items: [],\n              styles: Object.create(null)\n            };\n            pump();\n          });\n        }\n        getStructTree() {\n          return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex);\n        }\n        _destroy() {\n          this.destroyed = true;\n          const waitOn = [];\n          for (const intentState of this._intentStates.values()) {\n            this._abortOperatorList({\n              intentState,\n              reason: new Error(\"Page was destroyed.\"),\n              force: true\n            });\n            if (intentState.opListReadCapability) {\n              continue;\n            }\n            for (const internalRenderTask of intentState.renderTasks) {\n              waitOn.push(internalRenderTask.completed);\n              internalRenderTask.cancel();\n            }\n          }\n          this.objs.clear();\n          this._annotationPromises.clear();\n          this._jsActionsPromise = null;\n          this._structTreePromise = null;\n          this.pendingCleanup = false;\n          return Promise.all(waitOn);\n        }\n        cleanup(resetStats = false) {\n          this.pendingCleanup = true;\n          return this._tryCleanup(resetStats);\n        }\n        _tryCleanup(resetStats = false) {\n          if (!this.pendingCleanup) {\n            return false;\n          }\n          for (const {\n            renderTasks,\n            operatorList\n          } of this._intentStates.values()) {\n            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n              return false;\n            }\n          }\n          this._intentStates.clear();\n          this.objs.clear();\n          this._annotationPromises.clear();\n          this._jsActionsPromise = null;\n          this._structTreePromise = null;\n          if (resetStats && this._stats) {\n            this._stats = new _display_utils.StatTimer();\n          }\n          this.pendingCleanup = false;\n          return true;\n        }\n        _startRenderPage(transparency, cacheKey) {\n          const intentState = this._intentStates.get(cacheKey);\n          if (!intentState) {\n            return;\n          }\n          if (this._stats) {\n            this._stats.timeEnd(\"Page Request\");\n          }\n          if (intentState.displayReadyCapability) {\n            intentState.displayReadyCapability.resolve(transparency);\n          }\n        }\n        _renderPageChunk(operatorListChunk, intentState) {\n          for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n          }\n          intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n          for (const internalRenderTask of intentState.renderTasks) {\n            internalRenderTask.operatorListChanged();\n          }\n          if (operatorListChunk.lastChunk) {\n            this._tryCleanup();\n          }\n        }\n        _pumpOperatorList({\n          renderingIntent,\n          cacheKey\n        }) {\n          const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n            pageIndex: this._pageIndex,\n            intent: renderingIntent,\n            cacheKey,\n            annotationStorage: renderingIntent & _util.RenderingIntentFlag.ANNOTATIONS_STORAGE ? this._transport.annotationStorage.serializable : null\n          });\n          const reader = readableStream.getReader();\n          const intentState = this._intentStates.get(cacheKey);\n          intentState.streamReader = reader;\n          const pump = () => {\n            reader.read().then(({\n              value,\n              done\n            }) => {\n              if (done) {\n                intentState.streamReader = null;\n                return;\n              }\n              if (this._transport.destroyed) {\n                return;\n              }\n              this._renderPageChunk(value, intentState);\n              pump();\n            }, reason => {\n              intentState.streamReader = null;\n              if (this._transport.destroyed) {\n                return;\n              }\n              if (intentState.operatorList) {\n                intentState.operatorList.lastChunk = true;\n                for (const internalRenderTask of intentState.renderTasks) {\n                  internalRenderTask.operatorListChanged();\n                }\n                this._tryCleanup();\n              }\n              if (intentState.displayReadyCapability) {\n                intentState.displayReadyCapability.reject(reason);\n              } else if (intentState.opListReadCapability) {\n                intentState.opListReadCapability.reject(reason);\n              } else {\n                throw reason;\n              }\n            });\n          };\n          pump();\n        }\n        _abortOperatorList({\n          intentState,\n          reason,\n          force = false\n        }) {\n          if (!intentState.streamReader) {\n            return;\n          }\n          if (!force) {\n            if (intentState.renderTasks.size > 0) {\n              return;\n            }\n            if (reason instanceof _display_utils.RenderingCancelledException) {\n              intentState.streamReaderCancelTimeout = setTimeout(() => {\n                this._abortOperatorList({\n                  intentState,\n                  reason,\n                  force: true\n                });\n                intentState.streamReaderCancelTimeout = null;\n              }, RENDERING_CANCELLED_TIMEOUT);\n              return;\n            }\n          }\n          intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});\n          intentState.streamReader = null;\n          if (this._transport.destroyed) {\n            return;\n          }\n          for (const [curCacheKey, curIntentState] of this._intentStates) {\n            if (curIntentState === intentState) {\n              this._intentStates.delete(curCacheKey);\n              break;\n            }\n          }\n          this.cleanup();\n        }\n        get stats() {\n          return this._stats;\n        }\n      }\n      exports.PDFPageProxy = PDFPageProxy;\n      class LoopbackPort {\n        constructor() {\n          this._listeners = [];\n          this._deferred = Promise.resolve();\n        }\n        postMessage(obj, transfers) {\n          function cloneValue(object) {\n            if (globalThis.structuredClone) {\n              return globalThis.structuredClone(object, transfers);\n            }\n            function fallbackCloneValue(value) {\n              if (typeof value === \"function\" || typeof value === \"symbol\" || value instanceof URL) {\n                throw new Error(`LoopbackPort.postMessage - cannot clone: ${value?.toString()}`);\n              }\n              if (typeof value !== \"object\" || value === null) {\n                return value;\n              }\n              if (cloned.has(value)) {\n                return cloned.get(value);\n              }\n              let buffer, result;\n              if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {\n                if (transfers?.includes(buffer)) {\n                  result = new value.constructor(buffer, value.byteOffset, value.byteLength);\n                } else {\n                  result = new value.constructor(value);\n                }\n                cloned.set(value, result);\n                return result;\n              }\n              if (value instanceof Map) {\n                result = new Map();\n                cloned.set(value, result);\n                for (const [key, val] of value) {\n                  result.set(key, fallbackCloneValue(val));\n                }\n                return result;\n              }\n              if (value instanceof Set) {\n                result = new Set();\n                cloned.set(value, result);\n                for (const val of value) {\n                  result.add(fallbackCloneValue(val));\n                }\n                return result;\n              }\n              result = Array.isArray(value) ? [] : Object.create(null);\n              cloned.set(value, result);\n              for (const i in value) {\n                let desc,\n                  p = value;\n                while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {\n                  p = Object.getPrototypeOf(p);\n                }\n                if (typeof desc.value === \"undefined\") {\n                  continue;\n                }\n                if (typeof desc.value === \"function\" && !value.hasOwnProperty?.(i)) {\n                  continue;\n                }\n                result[i] = fallbackCloneValue(desc.value);\n              }\n              return result;\n            }\n            const cloned = new WeakMap();\n            return fallbackCloneValue(object);\n          }\n          const event = {\n            data: cloneValue(obj)\n          };\n          this._deferred.then(() => {\n            for (const listener of this._listeners) {\n              listener.call(this, event);\n            }\n          });\n        }\n        addEventListener(name, listener) {\n          this._listeners.push(listener);\n        }\n        removeEventListener(name, listener) {\n          const i = this._listeners.indexOf(listener);\n          this._listeners.splice(i, 1);\n        }\n        terminate() {\n          this._listeners.length = 0;\n        }\n      }\n      exports.LoopbackPort = LoopbackPort;\n      const PDFWorkerUtil = {\n        isWorkerDisabled: false,\n        fallbackWorkerSrc: null,\n        fakeWorkerId: 0\n      };\n      {\n        if (_is_node.isNodeJS && typeof require === \"function\") {\n          PDFWorkerUtil.isWorkerDisabled = true;\n          PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\";\n        } else if (typeof document === \"object\") {\n          const pdfjsFilePath = document?.currentScript?.src;\n          if (pdfjsFilePath) {\n            PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n          }\n        }\n        PDFWorkerUtil.createCDNWrapper = function (url) {\n          const wrapper = `importScripts(\"${url}\");`;\n          return URL.createObjectURL(new Blob([wrapper]));\n        };\n      }\n      class PDFWorker {\n        static get _workerPorts() {\n          return (0, _util.shadow)(this, \"_workerPorts\", new WeakMap());\n        }\n        constructor({\n          name = null,\n          port = null,\n          verbosity = (0, _util.getVerbosityLevel)()\n        } = {}) {\n          if (port && PDFWorker._workerPorts.has(port)) {\n            throw new Error(\"Cannot use more than one PDFWorker per port.\");\n          }\n          this.name = name;\n          this.destroyed = false;\n          this.verbosity = verbosity;\n          this._readyCapability = (0, _util.createPromiseCapability)();\n          this._port = null;\n          this._webWorker = null;\n          this._messageHandler = null;\n          if (port) {\n            PDFWorker._workerPorts.set(port, this);\n            this._initializeFromPort(port);\n            return;\n          }\n          this._initialize();\n        }\n        get promise() {\n          return this._readyCapability.promise;\n        }\n        get port() {\n          return this._port;\n        }\n        get messageHandler() {\n          return this._messageHandler;\n        }\n        _initializeFromPort(port) {\n          this._port = port;\n          this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n          this._messageHandler.on(\"ready\", function () {});\n          this._readyCapability.resolve();\n        }\n        _initialize() {\n          if (typeof Worker !== \"undefined\" && !PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {\n            let workerSrc = PDFWorker.workerSrc;\n            try {\n              if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {\n                workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);\n              }\n              const worker = new Worker(workerSrc);\n              const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n              const terminateEarly = () => {\n                worker.removeEventListener(\"error\", onWorkerError);\n                messageHandler.destroy();\n                worker.terminate();\n                if (this.destroyed) {\n                  this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                } else {\n                  this._setupFakeWorker();\n                }\n              };\n              const onWorkerError = () => {\n                if (!this._webWorker) {\n                  terminateEarly();\n                }\n              };\n              worker.addEventListener(\"error\", onWorkerError);\n              messageHandler.on(\"test\", data => {\n                worker.removeEventListener(\"error\", onWorkerError);\n                if (this.destroyed) {\n                  terminateEarly();\n                  return;\n                }\n                if (data) {\n                  this._messageHandler = messageHandler;\n                  this._port = worker;\n                  this._webWorker = worker;\n                  this._readyCapability.resolve();\n                  messageHandler.send(\"configure\", {\n                    verbosity: this.verbosity\n                  });\n                } else {\n                  this._setupFakeWorker();\n                  messageHandler.destroy();\n                  worker.terminate();\n                }\n              });\n              messageHandler.on(\"ready\", data => {\n                worker.removeEventListener(\"error\", onWorkerError);\n                if (this.destroyed) {\n                  terminateEarly();\n                  return;\n                }\n                try {\n                  sendTest();\n                } catch (e) {\n                  this._setupFakeWorker();\n                }\n              });\n              const sendTest = () => {\n                const testObj = new Uint8Array([255]);\n                try {\n                  messageHandler.send(\"test\", testObj, [testObj.buffer]);\n                } catch (ex) {\n                  (0, _util.warn)(\"Cannot use postMessage transfers.\");\n                  testObj[0] = 0;\n                  messageHandler.send(\"test\", testObj);\n                }\n              };\n              sendTest();\n              return;\n            } catch (e) {\n              (0, _util.info)(\"The worker has been disabled.\");\n            }\n          }\n          this._setupFakeWorker();\n        }\n        _setupFakeWorker() {\n          if (!PDFWorkerUtil.isWorkerDisabled) {\n            (0, _util.warn)(\"Setting up fake worker.\");\n            PDFWorkerUtil.isWorkerDisabled = true;\n          }\n          PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {\n            if (this.destroyed) {\n              this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n              return;\n            }\n            const port = new LoopbackPort();\n            this._port = port;\n            const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n            const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n            WorkerMessageHandler.setup(workerHandler, port);\n            const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n            this._messageHandler = messageHandler;\n            this._readyCapability.resolve();\n            messageHandler.send(\"configure\", {\n              verbosity: this.verbosity\n            });\n          }).catch(reason => {\n            this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n          });\n        }\n        destroy() {\n          this.destroyed = true;\n          if (this._webWorker) {\n            this._webWorker.terminate();\n            this._webWorker = null;\n          }\n          PDFWorker._workerPorts.delete(this._port);\n          this._port = null;\n          if (this._messageHandler) {\n            this._messageHandler.destroy();\n            this._messageHandler = null;\n          }\n        }\n        static fromPort(params) {\n          if (!params?.port) {\n            throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n          }\n          if (this._workerPorts.has(params.port)) {\n            return this._workerPorts.get(params.port);\n          }\n          return new PDFWorker(params);\n        }\n        static get workerSrc() {\n          if (_worker_options.GlobalWorkerOptions.workerSrc) {\n            return _worker_options.GlobalWorkerOptions.workerSrc;\n          }\n          if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n            if (!_is_node.isNodeJS) {\n              (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n            }\n            return PDFWorkerUtil.fallbackWorkerSrc;\n          }\n          throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n        }\n        static get _mainThreadWorkerMessageHandler() {\n          try {\n            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n          } catch (ex) {\n            return null;\n          }\n        }\n        static get _setupFakeWorkerGlobal() {\n          const loader = async () => {\n            const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;\n            if (mainWorkerMessageHandler) {\n              return mainWorkerMessageHandler;\n            }\n            if (_is_node.isNodeJS && typeof require === \"function\") {\n              const worker = eval(\"require\")(this.workerSrc);\n              return worker.WorkerMessageHandler;\n            }\n            await (0, _display_utils.loadScript)(this.workerSrc);\n            return window.pdfjsWorker.WorkerMessageHandler;\n          };\n          return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n        }\n      }\n      exports.PDFWorker = PDFWorker;\n      {\n        PDFWorker.getWorkerSrc = function () {\n          (0, _display_utils.deprecated)(\"`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.\");\n          return this.workerSrc;\n        };\n      }\n      class WorkerTransport {\n        #docStats = null;\n        #pageCache = new Map();\n        #pagePromises = new Map();\n        #metadataPromise = null;\n        constructor(messageHandler, loadingTask, networkStream, params) {\n          this.messageHandler = messageHandler;\n          this.loadingTask = loadingTask;\n          this.commonObjs = new PDFObjects();\n          this.fontLoader = new _font_loader.FontLoader({\n            docId: loadingTask.docId,\n            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n            ownerDocument: params.ownerDocument,\n            styleElement: params.styleElement\n          });\n          this._params = params;\n          if (!params.useWorkerFetch) {\n            this.CMapReaderFactory = new params.CMapReaderFactory({\n              baseUrl: params.cMapUrl,\n              isCompressed: params.cMapPacked\n            });\n            this.StandardFontDataFactory = new params.StandardFontDataFactory({\n              baseUrl: params.standardFontDataUrl\n            });\n          }\n          this.destroyed = false;\n          this.destroyCapability = null;\n          this._passwordCapability = null;\n          this._networkStream = networkStream;\n          this._fullReader = null;\n          this._lastProgress = null;\n          this.downloadInfoCapability = (0, _util.createPromiseCapability)();\n          this.setupMessageHandler();\n        }\n        get annotationStorage() {\n          return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n        }\n        get stats() {\n          return this.#docStats;\n        }\n        getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, isOpList = false) {\n          let renderingIntent = _util.RenderingIntentFlag.DISPLAY;\n          let lastModified = \"\";\n          switch (intent) {\n            case \"any\":\n              renderingIntent = _util.RenderingIntentFlag.ANY;\n              break;\n            case \"display\":\n              break;\n            case \"print\":\n              renderingIntent = _util.RenderingIntentFlag.PRINT;\n              break;\n            default:\n              (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);\n          }\n          switch (annotationMode) {\n            case _util.AnnotationMode.DISABLE:\n              renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n              break;\n            case _util.AnnotationMode.ENABLE:\n              break;\n            case _util.AnnotationMode.ENABLE_FORMS:\n              renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;\n              break;\n            case _util.AnnotationMode.ENABLE_STORAGE:\n              renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n              lastModified = this.annotationStorage.lastModified;\n              break;\n            default:\n              (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n          }\n          if (isOpList) {\n            renderingIntent += _util.RenderingIntentFlag.OPLIST;\n          }\n          return {\n            renderingIntent,\n            cacheKey: `${renderingIntent}_${lastModified}`\n          };\n        }\n        destroy() {\n          if (this.destroyCapability) {\n            return this.destroyCapability.promise;\n          }\n          this.destroyed = true;\n          this.destroyCapability = (0, _util.createPromiseCapability)();\n          if (this._passwordCapability) {\n            this._passwordCapability.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n          }\n          const waitOn = [];\n          for (const page of this.#pageCache.values()) {\n            waitOn.push(page._destroy());\n          }\n          this.#pageCache.clear();\n          this.#pagePromises.clear();\n          if (this.hasOwnProperty(\"annotationStorage\")) {\n            this.annotationStorage.resetModified();\n          }\n          const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n          waitOn.push(terminated);\n          Promise.all(waitOn).then(() => {\n            this.commonObjs.clear();\n            this.fontLoader.clear();\n            this.#metadataPromise = null;\n            this._getFieldObjectsPromise = null;\n            this._hasJSActionsPromise = null;\n            if (this._networkStream) {\n              this._networkStream.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n            }\n            if (this.messageHandler) {\n              this.messageHandler.destroy();\n              this.messageHandler = null;\n            }\n            this.destroyCapability.resolve();\n          }, this.destroyCapability.reject);\n          return this.destroyCapability.promise;\n        }\n        setupMessageHandler() {\n          const {\n            messageHandler,\n            loadingTask\n          } = this;\n          messageHandler.on(\"GetReader\", (data, sink) => {\n            (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n            this._fullReader = this._networkStream.getFullReader();\n            this._fullReader.onProgress = evt => {\n              this._lastProgress = {\n                loaded: evt.loaded,\n                total: evt.total\n              };\n            };\n            sink.onPull = () => {\n              this._fullReader.read().then(function ({\n                value,\n                done\n              }) {\n                if (done) {\n                  sink.close();\n                  return;\n                }\n                (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetReader - expected an ArrayBuffer.\");\n                sink.enqueue(new Uint8Array(value), 1, [value]);\n              }).catch(reason => {\n                sink.error(reason);\n              });\n            };\n            sink.onCancel = reason => {\n              this._fullReader.cancel(reason);\n              sink.ready.catch(readyReason => {\n                if (this.destroyed) {\n                  return;\n                }\n                throw readyReason;\n              });\n            };\n          });\n          messageHandler.on(\"ReaderHeadersReady\", data => {\n            const headersCapability = (0, _util.createPromiseCapability)();\n            const fullReader = this._fullReader;\n            fullReader.headersReady.then(() => {\n              if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n                if (this._lastProgress) {\n                  loadingTask.onProgress?.(this._lastProgress);\n                }\n                fullReader.onProgress = evt => {\n                  loadingTask.onProgress?.({\n                    loaded: evt.loaded,\n                    total: evt.total\n                  });\n                };\n              }\n              headersCapability.resolve({\n                isStreamingSupported: fullReader.isStreamingSupported,\n                isRangeSupported: fullReader.isRangeSupported,\n                contentLength: fullReader.contentLength\n              });\n            }, headersCapability.reject);\n            return headersCapability.promise;\n          });\n          messageHandler.on(\"GetRangeReader\", (data, sink) => {\n            (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n            if (!rangeReader) {\n              sink.close();\n              return;\n            }\n            sink.onPull = () => {\n              rangeReader.read().then(function ({\n                value,\n                done\n              }) {\n                if (done) {\n                  sink.close();\n                  return;\n                }\n                (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetRangeReader - expected an ArrayBuffer.\");\n                sink.enqueue(new Uint8Array(value), 1, [value]);\n              }).catch(reason => {\n                sink.error(reason);\n              });\n            };\n            sink.onCancel = reason => {\n              rangeReader.cancel(reason);\n              sink.ready.catch(readyReason => {\n                if (this.destroyed) {\n                  return;\n                }\n                throw readyReason;\n              });\n            };\n          });\n          messageHandler.on(\"GetDoc\", ({\n            pdfInfo\n          }) => {\n            this._numPages = pdfInfo.numPages;\n            this._htmlForXfa = pdfInfo.htmlForXfa;\n            delete pdfInfo.htmlForXfa;\n            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n          });\n          messageHandler.on(\"DocException\", function (ex) {\n            let reason;\n            switch (ex.name) {\n              case \"PasswordException\":\n                reason = new _util.PasswordException(ex.message, ex.code);\n                break;\n              case \"InvalidPDFException\":\n                reason = new _util.InvalidPDFException(ex.message);\n                break;\n              case \"MissingPDFException\":\n                reason = new _util.MissingPDFException(ex.message);\n                break;\n              case \"UnexpectedResponseException\":\n                reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n                break;\n              case \"UnknownErrorException\":\n                reason = new _util.UnknownErrorException(ex.message, ex.details);\n                break;\n              default:\n                (0, _util.unreachable)(\"DocException - expected a valid Error.\");\n            }\n            loadingTask._capability.reject(reason);\n          });\n          messageHandler.on(\"PasswordRequest\", exception => {\n            this._passwordCapability = (0, _util.createPromiseCapability)();\n            if (loadingTask.onPassword) {\n              const updatePassword = password => {\n                this._passwordCapability.resolve({\n                  password\n                });\n              };\n              try {\n                loadingTask.onPassword(updatePassword, exception.code);\n              } catch (ex) {\n                this._passwordCapability.reject(ex);\n              }\n            } else {\n              this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n            }\n            return this._passwordCapability.promise;\n          });\n          messageHandler.on(\"DataLoaded\", data => {\n            loadingTask.onProgress?.({\n              loaded: data.length,\n              total: data.length\n            });\n            this.downloadInfoCapability.resolve(data);\n          });\n          messageHandler.on(\"StartRenderPage\", data => {\n            if (this.destroyed) {\n              return;\n            }\n            const page = this.#pageCache.get(data.pageIndex);\n            page._startRenderPage(data.transparency, data.cacheKey);\n          });\n          messageHandler.on(\"commonobj\", ([id, type, exportedData]) => {\n            if (this.destroyed) {\n              return;\n            }\n            if (this.commonObjs.has(id)) {\n              return;\n            }\n            switch (type) {\n              case \"Font\":\n                const params = this._params;\n                if (\"error\" in exportedData) {\n                  const exportedError = exportedData.error;\n                  (0, _util.warn)(`Error during font loading: ${exportedError}`);\n                  this.commonObjs.resolve(id, exportedError);\n                  break;\n                }\n                let fontRegistry = null;\n                if (params.pdfBug && globalThis.FontInspector?.enabled) {\n                  fontRegistry = {\n                    registerFont(font, url) {\n                      globalThis.FontInspector.fontAdded(font, url);\n                    }\n                  };\n                }\n                const font = new _font_loader.FontFaceObject(exportedData, {\n                  isEvalSupported: params.isEvalSupported,\n                  disableFontFace: params.disableFontFace,\n                  ignoreErrors: params.ignoreErrors,\n                  onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n                  fontRegistry\n                });\n                this.fontLoader.bind(font).catch(reason => {\n                  return messageHandler.sendWithPromise(\"FontFallback\", {\n                    id\n                  });\n                }).finally(() => {\n                  if (!params.fontExtraProperties && font.data) {\n                    font.data = null;\n                  }\n                  this.commonObjs.resolve(id, font);\n                });\n                break;\n              case \"FontPath\":\n              case \"Image\":\n                this.commonObjs.resolve(id, exportedData);\n                break;\n              default:\n                throw new Error(`Got unknown common object type ${type}`);\n            }\n          });\n          messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n            if (this.destroyed) {\n              return;\n            }\n            const pageProxy = this.#pageCache.get(pageIndex);\n            if (pageProxy.objs.has(id)) {\n              return;\n            }\n            switch (type) {\n              case \"Image\":\n                pageProxy.objs.resolve(id, imageData);\n                const MAX_IMAGE_SIZE_TO_STORE = 8000000;\n                if (imageData?.data?.length > MAX_IMAGE_SIZE_TO_STORE) {\n                  pageProxy.cleanupAfterRender = true;\n                }\n                break;\n              case \"Pattern\":\n                pageProxy.objs.resolve(id, imageData);\n                break;\n              default:\n                throw new Error(`Got unknown object type ${type}`);\n            }\n          });\n          messageHandler.on(\"DocProgress\", data => {\n            if (this.destroyed) {\n              return;\n            }\n            loadingTask.onProgress?.({\n              loaded: data.loaded,\n              total: data.total\n            });\n          });\n          messageHandler.on(\"DocStats\", data => {\n            if (this.destroyed) {\n              return;\n            }\n            this.#docStats = Object.freeze({\n              streamTypes: Object.freeze(data.streamTypes),\n              fontTypes: Object.freeze(data.fontTypes)\n            });\n          });\n          messageHandler.on(\"UnsupportedFeature\", this._onUnsupportedFeature.bind(this));\n          messageHandler.on(\"FetchBuiltInCMap\", data => {\n            if (this.destroyed) {\n              return Promise.reject(new Error(\"Worker was destroyed.\"));\n            }\n            if (!this.CMapReaderFactory) {\n              return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n            }\n            return this.CMapReaderFactory.fetch(data);\n          });\n          messageHandler.on(\"FetchStandardFontData\", data => {\n            if (this.destroyed) {\n              return Promise.reject(new Error(\"Worker was destroyed.\"));\n            }\n            if (!this.StandardFontDataFactory) {\n              return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n            }\n            return this.StandardFontDataFactory.fetch(data);\n          });\n        }\n        _onUnsupportedFeature({\n          featureId\n        }) {\n          if (this.destroyed) {\n            return;\n          }\n          this.loadingTask.onUnsupportedFeature?.(featureId);\n        }\n        getData() {\n          return this.messageHandler.sendWithPromise(\"GetData\", null);\n        }\n        getPage(pageNumber) {\n          if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n            return Promise.reject(new Error(\"Invalid page request\"));\n          }\n          const pageIndex = pageNumber - 1,\n            cachedPromise = this.#pagePromises.get(pageIndex);\n          if (cachedPromise) {\n            return cachedPromise;\n          }\n          const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n            pageIndex\n          }).then(pageInfo => {\n            if (this.destroyed) {\n              throw new Error(\"Transport destroyed\");\n            }\n            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);\n            this.#pageCache.set(pageIndex, page);\n            return page;\n          });\n          this.#pagePromises.set(pageIndex, promise);\n          return promise;\n        }\n        getPageIndex(ref) {\n          return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n            ref\n          });\n        }\n        getAnnotations(pageIndex, intent) {\n          return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n            pageIndex,\n            intent\n          });\n        }\n        saveDocument() {\n          return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n            isPureXfa: !!this._htmlForXfa,\n            numPages: this._numPages,\n            annotationStorage: this.annotationStorage.serializable,\n            filename: this._fullReader?.filename ?? null\n          }).finally(() => {\n            this.annotationStorage.resetModified();\n          });\n        }\n        getFieldObjects() {\n          return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise(\"GetFieldObjects\", null);\n        }\n        hasJSActions() {\n          return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise(\"HasJSActions\", null);\n        }\n        getCalculationOrderIds() {\n          return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n        }\n        getDestinations() {\n          return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n        }\n        getDestination(id) {\n          if (typeof id !== \"string\") {\n            return Promise.reject(new Error(\"Invalid destination request.\"));\n          }\n          return this.messageHandler.sendWithPromise(\"GetDestination\", {\n            id\n          });\n        }\n        getPageLabels() {\n          return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n        }\n        getPageLayout() {\n          return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n        }\n        getPageMode() {\n          return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n        }\n        getViewerPreferences() {\n          return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n        }\n        getOpenAction() {\n          return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n        }\n        getAttachments() {\n          return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n        }\n        getJavaScript() {\n          return this.messageHandler.sendWithPromise(\"GetJavaScript\", null);\n        }\n        getDocJSActions() {\n          return this.messageHandler.sendWithPromise(\"GetDocJSActions\", null);\n        }\n        getPageJSActions(pageIndex) {\n          return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n            pageIndex\n          });\n        }\n        getStructTree(pageIndex) {\n          return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n            pageIndex\n          });\n        }\n        getOutline() {\n          return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n        }\n        getOptionalContentConfig() {\n          return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(results => {\n            return new _optional_content_config.OptionalContentConfig(results);\n          });\n        }\n        getPermissions() {\n          return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n        }\n        getMetadata() {\n          return this.#metadataPromise ||= this.messageHandler.sendWithPromise(\"GetMetadata\", null).then(results => {\n            return {\n              info: results[0],\n              metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n              contentDispositionFilename: this._fullReader?.filename ?? null,\n              contentLength: this._fullReader?.contentLength ?? null\n            };\n          });\n        }\n        getMarkInfo() {\n          return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n        }\n        async startCleanup(keepLoadedFonts = false) {\n          await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n          if (this.destroyed) {\n            return;\n          }\n          for (const page of this.#pageCache.values()) {\n            const cleanupSuccessful = page.cleanup();\n            if (!cleanupSuccessful) {\n              throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n            }\n          }\n          this.commonObjs.clear();\n          if (!keepLoadedFonts) {\n            this.fontLoader.clear();\n          }\n          this.#metadataPromise = null;\n          this._getFieldObjectsPromise = null;\n          this._hasJSActionsPromise = null;\n        }\n        get loadingParams() {\n          const params = this._params;\n          return (0, _util.shadow)(this, \"loadingParams\", {\n            disableAutoFetch: params.disableAutoFetch,\n            enableXfa: params.enableXfa\n          });\n        }\n      }\n      class PDFObjects {\n        constructor() {\n          this._objs = Object.create(null);\n        }\n        _ensureObj(objId) {\n          if (this._objs[objId]) {\n            return this._objs[objId];\n          }\n          return this._objs[objId] = {\n            capability: (0, _util.createPromiseCapability)(),\n            data: null,\n            resolved: false\n          };\n        }\n        get(objId, callback = null) {\n          if (callback) {\n            this._ensureObj(objId).capability.promise.then(callback);\n            return null;\n          }\n          const obj = this._objs[objId];\n          if (!obj || !obj.resolved) {\n            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n          }\n          return obj.data;\n        }\n        has(objId) {\n          const obj = this._objs[objId];\n          return obj?.resolved || false;\n        }\n        resolve(objId, data) {\n          const obj = this._ensureObj(objId);\n          obj.resolved = true;\n          obj.data = data;\n          obj.capability.resolve(data);\n        }\n        clear() {\n          this._objs = Object.create(null);\n        }\n      }\n      class RenderTask {\n        constructor(internalRenderTask) {\n          this._internalRenderTask = internalRenderTask;\n          this.onContinue = null;\n        }\n        get promise() {\n          return this._internalRenderTask.capability.promise;\n        }\n        cancel() {\n          this._internalRenderTask.cancel();\n        }\n      }\n      exports.RenderTask = RenderTask;\n      class InternalRenderTask {\n        static get canvasInUse() {\n          return (0, _util.shadow)(this, \"canvasInUse\", new WeakSet());\n        }\n        constructor({\n          callback,\n          params,\n          objs,\n          commonObjs,\n          annotationCanvasMap,\n          operatorList,\n          pageIndex,\n          canvasFactory,\n          useRequestAnimationFrame = false,\n          pdfBug = false\n        }) {\n          this.callback = callback;\n          this.params = params;\n          this.objs = objs;\n          this.commonObjs = commonObjs;\n          this.annotationCanvasMap = annotationCanvasMap;\n          this.operatorListIdx = null;\n          this.operatorList = operatorList;\n          this._pageIndex = pageIndex;\n          this.canvasFactory = canvasFactory;\n          this._pdfBug = pdfBug;\n          this.running = false;\n          this.graphicsReadyCallback = null;\n          this.graphicsReady = false;\n          this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n          this.cancelled = false;\n          this.capability = (0, _util.createPromiseCapability)();\n          this.task = new RenderTask(this);\n          this._cancelBound = this.cancel.bind(this);\n          this._continueBound = this._continue.bind(this);\n          this._scheduleNextBound = this._scheduleNext.bind(this);\n          this._nextBound = this._next.bind(this);\n          this._canvas = params.canvasContext.canvas;\n        }\n        get completed() {\n          return this.capability.promise.catch(function () {});\n        }\n        initializeGraphics({\n          transparency = false,\n          optionalContentConfig\n        }) {\n          if (this.cancelled) {\n            return;\n          }\n          if (this._canvas) {\n            if (InternalRenderTask.canvasInUse.has(this._canvas)) {\n              throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n            }\n            InternalRenderTask.canvasInUse.add(this._canvas);\n          }\n          if (this._pdfBug && globalThis.StepperManager?.enabled) {\n            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n            this.stepper.init(this.operatorList);\n            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n          }\n          const {\n            canvasContext,\n            viewport,\n            transform,\n            imageLayer,\n            background\n          } = this.params;\n          this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap);\n          this.gfx.beginDrawing({\n            transform,\n            viewport,\n            transparency,\n            background\n          });\n          this.operatorListIdx = 0;\n          this.graphicsReady = true;\n          if (this.graphicsReadyCallback) {\n            this.graphicsReadyCallback();\n          }\n        }\n        cancel(error = null) {\n          this.running = false;\n          this.cancelled = true;\n          if (this.gfx) {\n            this.gfx.endDrawing();\n          }\n          if (this._canvas) {\n            InternalRenderTask.canvasInUse.delete(this._canvas);\n          }\n          this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, \"canvas\"));\n        }\n        operatorListChanged() {\n          if (!this.graphicsReady) {\n            if (!this.graphicsReadyCallback) {\n              this.graphicsReadyCallback = this._continueBound;\n            }\n            return;\n          }\n          if (this.stepper) {\n            this.stepper.updateOperatorList(this.operatorList);\n          }\n          if (this.running) {\n            return;\n          }\n          this._continue();\n        }\n        _continue() {\n          this.running = true;\n          if (this.cancelled) {\n            return;\n          }\n          if (this.task.onContinue) {\n            this.task.onContinue(this._scheduleNextBound);\n          } else {\n            this._scheduleNext();\n          }\n        }\n        _scheduleNext() {\n          if (this._useRequestAnimationFrame) {\n            window.requestAnimationFrame(() => {\n              this._nextBound().catch(this._cancelBound);\n            });\n          } else {\n            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n          }\n        }\n        async _next() {\n          if (this.cancelled) {\n            return;\n          }\n          this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n          if (this.operatorListIdx === this.operatorList.argsArray.length) {\n            this.running = false;\n            if (this.operatorList.lastChunk) {\n              this.gfx.endDrawing();\n              if (this._canvas) {\n                InternalRenderTask.canvasInUse.delete(this._canvas);\n              }\n              this.callback();\n            }\n          }\n        }\n      }\n      const version = '2.12.313';\n      exports.version = version;\n      const build = 'a2ae56f39';\n      exports.build = build;\n\n      /***/\n    }), (/* 7 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.FontLoader = exports.FontFaceObject = void 0;\n      var _util = __w_pdfjs_require__(2);\n      class BaseFontLoader {\n        constructor({\n          docId,\n          onUnsupportedFeature,\n          ownerDocument = globalThis.document,\n          styleElement = null\n        }) {\n          if (this.constructor === BaseFontLoader) {\n            (0, _util.unreachable)(\"Cannot initialize BaseFontLoader.\");\n          }\n          this.docId = docId;\n          this._onUnsupportedFeature = onUnsupportedFeature;\n          this._document = ownerDocument;\n          this.nativeFontFaces = [];\n          this.styleElement = null;\n        }\n        addNativeFontFace(nativeFontFace) {\n          this.nativeFontFaces.push(nativeFontFace);\n          this._document.fonts.add(nativeFontFace);\n        }\n        insertRule(rule) {\n          let styleElement = this.styleElement;\n          if (!styleElement) {\n            styleElement = this.styleElement = this._document.createElement(\"style\");\n            styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;\n            this._document.documentElement.getElementsByTagName(\"head\")[0].appendChild(styleElement);\n          }\n          const styleSheet = styleElement.sheet;\n          styleSheet.insertRule(rule, styleSheet.cssRules.length);\n        }\n        clear() {\n          for (const nativeFontFace of this.nativeFontFaces) {\n            this._document.fonts.delete(nativeFontFace);\n          }\n          this.nativeFontFaces.length = 0;\n          if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n          }\n        }\n        async bind(font) {\n          if (font.attached || font.missingFile) {\n            return;\n          }\n          font.attached = true;\n          if (this.isFontLoadingAPISupported) {\n            const nativeFontFace = font.createNativeFontFace();\n            if (nativeFontFace) {\n              this.addNativeFontFace(nativeFontFace);\n              try {\n                await nativeFontFace.loaded;\n              } catch (ex) {\n                this._onUnsupportedFeature({\n                  featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative\n                });\n                (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                font.disableFontFace = true;\n                throw ex;\n              }\n            }\n            return;\n          }\n          const rule = font.createFontFaceRule();\n          if (rule) {\n            this.insertRule(rule);\n            if (this.isSyncFontLoadingSupported) {\n              return;\n            }\n            await new Promise(resolve => {\n              const request = this._queueLoadingCallback(resolve);\n              this._prepareFontLoadEvent([rule], [font], request);\n            });\n          }\n        }\n        _queueLoadingCallback(callback) {\n          (0, _util.unreachable)(\"Abstract method `_queueLoadingCallback`.\");\n        }\n        get isFontLoadingAPISupported() {\n          const hasFonts = !!this._document?.fonts;\n          return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", hasFonts);\n        }\n        get isSyncFontLoadingSupported() {\n          (0, _util.unreachable)(\"Abstract method `isSyncFontLoadingSupported`.\");\n        }\n        get _loadTestFont() {\n          (0, _util.unreachable)(\"Abstract method `_loadTestFont`.\");\n        }\n        _prepareFontLoadEvent(rules, fontsToLoad, request) {\n          (0, _util.unreachable)(\"Abstract method `_prepareFontLoadEvent`.\");\n        }\n      }\n      let FontLoader;\n      exports.FontLoader = FontLoader;\n      {\n        exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {\n          constructor(params) {\n            super(params);\n            this.loadingContext = {\n              requests: [],\n              nextRequestId: 0\n            };\n            this.loadTestFontId = 0;\n          }\n          get isSyncFontLoadingSupported() {\n            let supported = false;\n            if (typeof navigator === \"undefined\") {\n              supported = true;\n            } else {\n              const m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\n              if (m?.[1] >= 14) {\n                supported = true;\n              }\n            }\n            return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n          }\n          _queueLoadingCallback(callback) {\n            function completeRequest() {\n              (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n              request.done = true;\n              while (context.requests.length > 0 && context.requests[0].done) {\n                const otherRequest = context.requests.shift();\n                setTimeout(otherRequest.callback, 0);\n              }\n            }\n            const context = this.loadingContext;\n            const request = {\n              id: `pdfjs-font-loading-${context.nextRequestId++}`,\n              done: false,\n              complete: completeRequest,\n              callback\n            };\n            context.requests.push(request);\n            return request;\n          }\n          get _loadTestFont() {\n            const getLoadTestFont = function () {\n              return atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n            };\n            return (0, _util.shadow)(this, \"_loadTestFont\", getLoadTestFont());\n          }\n          _prepareFontLoadEvent(rules, fonts, request) {\n            function int32(data, offset) {\n              return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n            }\n            function spliceString(s, offset, remove, insert) {\n              const chunk1 = s.substring(0, offset);\n              const chunk2 = s.substring(offset + remove);\n              return chunk1 + insert + chunk2;\n            }\n            let i, ii;\n            const canvas = this._document.createElement(\"canvas\");\n            canvas.width = 1;\n            canvas.height = 1;\n            const ctx = canvas.getContext(\"2d\");\n            let called = 0;\n            function isFontReady(name, callback) {\n              called++;\n              if (called > 30) {\n                (0, _util.warn)(\"Load test font never loaded.\");\n                callback();\n                return;\n              }\n              ctx.font = \"30px \" + name;\n              ctx.fillText(\".\", 0, 20);\n              const imageData = ctx.getImageData(0, 0, 1, 1);\n              if (imageData.data[3] > 0) {\n                callback();\n                return;\n              }\n              setTimeout(isFontReady.bind(null, name, callback));\n            }\n            const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n            let data = this._loadTestFont;\n            const COMMENT_OFFSET = 976;\n            data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n            const CFF_CHECKSUM_OFFSET = 16;\n            const XXXX_VALUE = 0x58585858;\n            let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n            for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n              checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n            }\n            if (i < loadTestFontId.length) {\n              checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n            }\n            data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n            const url = `url(data:font/opentype;base64,${btoa(data)});`;\n            const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n            this.insertRule(rule);\n            const names = [];\n            for (const font of fonts) {\n              names.push(font.loadedName);\n            }\n            names.push(loadTestFontId);\n            const div = this._document.createElement(\"div\");\n            div.style.visibility = \"hidden\";\n            div.style.width = div.style.height = \"10px\";\n            div.style.position = \"absolute\";\n            div.style.top = div.style.left = \"0px\";\n            for (const name of names) {\n              const span = this._document.createElement(\"span\");\n              span.textContent = \"Hi\";\n              span.style.fontFamily = name;\n              div.appendChild(span);\n            }\n            this._document.body.appendChild(div);\n            isFontReady(loadTestFontId, () => {\n              div.remove();\n              request.complete();\n            });\n          }\n        };\n      }\n      class FontFaceObject {\n        constructor(translatedData, {\n          isEvalSupported = true,\n          disableFontFace = false,\n          ignoreErrors = false,\n          onUnsupportedFeature,\n          fontRegistry = null\n        }) {\n          this.compiledGlyphs = Object.create(null);\n          for (const i in translatedData) {\n            this[i] = translatedData[i];\n          }\n          this.isEvalSupported = isEvalSupported !== false;\n          this.disableFontFace = disableFontFace === true;\n          this.ignoreErrors = ignoreErrors === true;\n          this._onUnsupportedFeature = onUnsupportedFeature;\n          this.fontRegistry = fontRegistry;\n        }\n        createNativeFontFace() {\n          if (!this.data || this.disableFontFace) {\n            return null;\n          }\n          let nativeFontFace;\n          if (!this.cssFontInfo) {\n            nativeFontFace = new FontFace(this.loadedName, this.data, {});\n          } else {\n            const css = {\n              weight: this.cssFontInfo.fontWeight\n            };\n            if (this.cssFontInfo.italicAngle) {\n              css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n            }\n            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n          }\n          if (this.fontRegistry) {\n            this.fontRegistry.registerFont(this);\n          }\n          return nativeFontFace;\n        }\n        createFontFaceRule() {\n          if (!this.data || this.disableFontFace) {\n            return null;\n          }\n          const data = (0, _util.bytesToString)(this.data);\n          const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n          let rule;\n          if (!this.cssFontInfo) {\n            rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n          } else {\n            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n            if (this.cssFontInfo.italicAngle) {\n              css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n            }\n            rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n          }\n          if (this.fontRegistry) {\n            this.fontRegistry.registerFont(this, url);\n          }\n          return rule;\n        }\n        getPathGenerator(objs, character) {\n          if (this.compiledGlyphs[character] !== undefined) {\n            return this.compiledGlyphs[character];\n          }\n          let cmds;\n          try {\n            cmds = objs.get(this.loadedName + \"_path_\" + character);\n          } catch (ex) {\n            if (!this.ignoreErrors) {\n              throw ex;\n            }\n            this._onUnsupportedFeature({\n              featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath\n            });\n            (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\n            return this.compiledGlyphs[character] = function (c, size) {};\n          }\n          if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {\n            const jsBuf = [];\n            for (const current of cmds) {\n              const args = current.args !== undefined ? current.args.join(\",\") : \"\";\n              jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n            }\n            return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\"));\n          }\n          return this.compiledGlyphs[character] = function (c, size) {\n            for (const current of cmds) {\n              if (current.cmd === \"scale\") {\n                current.args = [size, -size];\n              }\n              c[current.cmd].apply(c, current.args);\n            }\n          };\n        }\n      }\n      exports.FontFaceObject = FontFaceObject;\n\n      /***/\n    }), (/* 8 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;\n      var _base_factory = __w_pdfjs_require__(5);\n      var _is_node = __w_pdfjs_require__(4);\n      var _util = __w_pdfjs_require__(2);\n      let NodeCanvasFactory = class {\n        constructor() {\n          (0, _util.unreachable)(\"Not implemented: NodeCanvasFactory\");\n        }\n      };\n      exports.NodeCanvasFactory = NodeCanvasFactory;\n      let NodeCMapReaderFactory = class {\n        constructor() {\n          (0, _util.unreachable)(\"Not implemented: NodeCMapReaderFactory\");\n        }\n      };\n      exports.NodeCMapReaderFactory = NodeCMapReaderFactory;\n      let NodeStandardFontDataFactory = class {\n        constructor() {\n          (0, _util.unreachable)(\"Not implemented: NodeStandardFontDataFactory\");\n        }\n      };\n      exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;\n      if (_is_node.isNodeJS) {\n        const fetchData = function (url) {\n          return new Promise((resolve, reject) => {\n            const fs = require(\"fs\");\n            fs.readFile(url, (error, data) => {\n              if (error || !data) {\n                reject(new Error(error));\n                return;\n              }\n              resolve(new Uint8Array(data));\n            });\n          });\n        };\n        exports.NodeCanvasFactory = NodeCanvasFactory = class extends _base_factory.BaseCanvasFactory {\n          _createCanvas(width, height) {\n            const Canvas = require(\"canvas\");\n            return Canvas.createCanvas(width, height);\n          }\n        };\n        exports.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _base_factory.BaseCMapReaderFactory {\n          _fetchData(url, compressionType) {\n            return fetchData(url).then(data => {\n              return {\n                cMapData: data,\n                compressionType\n              };\n            });\n          }\n        };\n        exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory = class extends _base_factory.BaseStandardFontDataFactory {\n          _fetchData(url) {\n            return fetchData(url);\n          }\n        };\n      }\n\n      /***/\n    }), (/* 9 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.AnnotationStorage = void 0;\n      var _util = __w_pdfjs_require__(2);\n      class AnnotationStorage {\n        constructor() {\n          this._storage = new Map();\n          this._timeStamp = Date.now();\n          this._modified = false;\n          this.onSetModified = null;\n          this.onResetModified = null;\n        }\n        getValue(key, defaultValue) {\n          const value = this._storage.get(key);\n          if (value === undefined) {\n            return defaultValue;\n          }\n          return Object.assign(defaultValue, value);\n        }\n        setValue(key, value) {\n          const obj = this._storage.get(key);\n          let modified = false;\n          if (obj !== undefined) {\n            for (const [entry, val] of Object.entries(value)) {\n              if (obj[entry] !== val) {\n                modified = true;\n                obj[entry] = val;\n              }\n            }\n          } else {\n            modified = true;\n            this._storage.set(key, value);\n          }\n          if (modified) {\n            this._timeStamp = Date.now();\n            this._setModified();\n          }\n        }\n        getAll() {\n          return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;\n        }\n        get size() {\n          return this._storage.size;\n        }\n        _setModified() {\n          if (!this._modified) {\n            this._modified = true;\n            if (typeof this.onSetModified === \"function\") {\n              this.onSetModified();\n            }\n          }\n        }\n        resetModified() {\n          if (this._modified) {\n            this._modified = false;\n            if (typeof this.onResetModified === \"function\") {\n              this.onResetModified();\n            }\n          }\n        }\n        get serializable() {\n          return this._storage.size > 0 ? this._storage : null;\n        }\n        get lastModified() {\n          return this._timeStamp.toString();\n        }\n      }\n      exports.AnnotationStorage = AnnotationStorage;\n\n      /***/\n    }), (/* 10 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.CanvasGraphics = void 0;\n      var _util = __w_pdfjs_require__(2);\n      var _pattern_helper = __w_pdfjs_require__(11);\n      var _display_utils = __w_pdfjs_require__(1);\n      const MIN_FONT_SIZE = 16;\n      const MAX_FONT_SIZE = 100;\n      const MAX_GROUP_SIZE = 4096;\n      const EXECUTION_TIME = 15;\n      const EXECUTION_STEPS = 10;\n      const COMPILE_TYPE3_GLYPHS = true;\n      const MAX_SIZE_TO_COMPILE = 1000;\n      const FULL_CHUNK_HEIGHT = 16;\n      const LINEWIDTH_SCALE_FACTOR = 1.000001;\n      function mirrorContextOperations(ctx, destCtx) {\n        if (ctx._removeMirroring) {\n          throw new Error(\"Context is already forwarding operations.\");\n        }\n        ctx.__originalSave = ctx.save;\n        ctx.__originalRestore = ctx.restore;\n        ctx.__originalRotate = ctx.rotate;\n        ctx.__originalScale = ctx.scale;\n        ctx.__originalTranslate = ctx.translate;\n        ctx.__originalTransform = ctx.transform;\n        ctx.__originalSetTransform = ctx.setTransform;\n        ctx.__originalResetTransform = ctx.resetTransform;\n        ctx.__originalClip = ctx.clip;\n        ctx.__originalMoveTo = ctx.moveTo;\n        ctx.__originalLineTo = ctx.lineTo;\n        ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n        ctx.__originalRect = ctx.rect;\n        ctx.__originalClosePath = ctx.closePath;\n        ctx.__originalBeginPath = ctx.beginPath;\n        ctx._removeMirroring = () => {\n          ctx.save = ctx.__originalSave;\n          ctx.restore = ctx.__originalRestore;\n          ctx.rotate = ctx.__originalRotate;\n          ctx.scale = ctx.__originalScale;\n          ctx.translate = ctx.__originalTranslate;\n          ctx.transform = ctx.__originalTransform;\n          ctx.setTransform = ctx.__originalSetTransform;\n          ctx.resetTransform = ctx.__originalResetTransform;\n          ctx.clip = ctx.__originalClip;\n          ctx.moveTo = ctx.__originalMoveTo;\n          ctx.lineTo = ctx.__originalLineTo;\n          ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n          ctx.rect = ctx.__originalRect;\n          ctx.closePath = ctx.__originalClosePath;\n          ctx.beginPath = ctx.__originalBeginPath;\n          delete ctx._removeMirroring;\n        };\n        ctx.save = function ctxSave() {\n          destCtx.save();\n          this.__originalSave();\n        };\n        ctx.restore = function ctxRestore() {\n          destCtx.restore();\n          this.__originalRestore();\n        };\n        ctx.translate = function ctxTranslate(x, y) {\n          destCtx.translate(x, y);\n          this.__originalTranslate(x, y);\n        };\n        ctx.scale = function ctxScale(x, y) {\n          destCtx.scale(x, y);\n          this.__originalScale(x, y);\n        };\n        ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n          destCtx.transform(a, b, c, d, e, f);\n          this.__originalTransform(a, b, c, d, e, f);\n        };\n        ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n          destCtx.setTransform(a, b, c, d, e, f);\n          this.__originalSetTransform(a, b, c, d, e, f);\n        };\n        ctx.resetTransform = function ctxResetTransform() {\n          destCtx.resetTransform();\n          this.__originalResetTransform();\n        };\n        ctx.rotate = function ctxRotate(angle) {\n          destCtx.rotate(angle);\n          this.__originalRotate(angle);\n        };\n        ctx.clip = function ctxRotate(rule) {\n          destCtx.clip(rule);\n          this.__originalClip(rule);\n        };\n        ctx.moveTo = function (x, y) {\n          destCtx.moveTo(x, y);\n          this.__originalMoveTo(x, y);\n        };\n        ctx.lineTo = function (x, y) {\n          destCtx.lineTo(x, y);\n          this.__originalLineTo(x, y);\n        };\n        ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n          destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n          this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n        };\n        ctx.rect = function (x, y, width, height) {\n          destCtx.rect(x, y, width, height);\n          this.__originalRect(x, y, width, height);\n        };\n        ctx.closePath = function () {\n          destCtx.closePath();\n          this.__originalClosePath();\n        };\n        ctx.beginPath = function () {\n          destCtx.beginPath();\n          this.__originalBeginPath();\n        };\n      }\n      function addContextCurrentTransform(ctx) {\n        if (ctx.mozCurrentTransform) {\n          return;\n        }\n        ctx._originalSave = ctx.save;\n        ctx._originalRestore = ctx.restore;\n        ctx._originalRotate = ctx.rotate;\n        ctx._originalScale = ctx.scale;\n        ctx._originalTranslate = ctx.translate;\n        ctx._originalTransform = ctx.transform;\n        ctx._originalSetTransform = ctx.setTransform;\n        ctx._originalResetTransform = ctx.resetTransform;\n        ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\n        ctx._transformStack = [];\n        try {\n          const desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), \"lineWidth\");\n          ctx._setLineWidth = desc.set;\n          ctx._getLineWidth = desc.get;\n          Object.defineProperty(ctx, \"lineWidth\", {\n            set: function setLineWidth(width) {\n              this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);\n            },\n            get: function getLineWidth() {\n              return this._getLineWidth();\n            }\n          });\n        } catch (_) {}\n        Object.defineProperty(ctx, \"mozCurrentTransform\", {\n          get: function getCurrentTransform() {\n            return this._transformMatrix;\n          }\n        });\n        Object.defineProperty(ctx, \"mozCurrentTransformInverse\", {\n          get: function getCurrentTransformInverse() {\n            const [a, b, c, d, e, f] = this._transformMatrix;\n            const ad_bc = a * d - b * c;\n            const bc_ad = b * c - a * d;\n            return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];\n          }\n        });\n        ctx.save = function ctxSave() {\n          const old = this._transformMatrix;\n          this._transformStack.push(old);\n          this._transformMatrix = old.slice(0, 6);\n          this._originalSave();\n        };\n        ctx.restore = function ctxRestore() {\n          const prev = this._transformStack.pop();\n          if (prev) {\n            this._transformMatrix = prev;\n            this._originalRestore();\n          }\n        };\n        ctx.translate = function ctxTranslate(x, y) {\n          const m = this._transformMatrix;\n          m[4] = m[0] * x + m[2] * y + m[4];\n          m[5] = m[1] * x + m[3] * y + m[5];\n          this._originalTranslate(x, y);\n        };\n        ctx.scale = function ctxScale(x, y) {\n          const m = this._transformMatrix;\n          m[0] *= x;\n          m[1] *= x;\n          m[2] *= y;\n          m[3] *= y;\n          this._originalScale(x, y);\n        };\n        ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n          const m = this._transformMatrix;\n          this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];\n          ctx._originalTransform(a, b, c, d, e, f);\n        };\n        ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n          this._transformMatrix = [a, b, c, d, e, f];\n          ctx._originalSetTransform(a, b, c, d, e, f);\n        };\n        ctx.resetTransform = function ctxResetTransform() {\n          this._transformMatrix = [1, 0, 0, 1, 0, 0];\n          ctx._originalResetTransform();\n        };\n        ctx.rotate = function ctxRotate(angle) {\n          const cosValue = Math.cos(angle);\n          const sinValue = Math.sin(angle);\n          const m = this._transformMatrix;\n          this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];\n          this._originalRotate(angle);\n        };\n      }\n      class CachedCanvases {\n        constructor(canvasFactory) {\n          this.canvasFactory = canvasFactory;\n          this.cache = Object.create(null);\n        }\n        getCanvas(id, width, height, trackTransform) {\n          let canvasEntry;\n          if (this.cache[id] !== undefined) {\n            canvasEntry = this.cache[id];\n            this.canvasFactory.reset(canvasEntry, width, height);\n            canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\n          } else {\n            canvasEntry = this.canvasFactory.create(width, height);\n            this.cache[id] = canvasEntry;\n          }\n          if (trackTransform) {\n            addContextCurrentTransform(canvasEntry.context);\n          }\n          return canvasEntry;\n        }\n        clear() {\n          for (const id in this.cache) {\n            const canvasEntry = this.cache[id];\n            this.canvasFactory.destroy(canvasEntry);\n            delete this.cache[id];\n          }\n        }\n      }\n      function compileType3Glyph(imgData) {\n        const POINT_TO_PROCESS_LIMIT = 1000;\n        const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n        const width = imgData.width,\n          height = imgData.height,\n          width1 = width + 1;\n        let i, ii, j, j0;\n        const points = new Uint8Array(width1 * (height + 1));\n        const lineSize = width + 7 & ~7,\n          data0 = imgData.data;\n        const data = new Uint8Array(lineSize * height);\n        let pos = 0;\n        for (i = 0, ii = data0.length; i < ii; i++) {\n          const elem = data0[i];\n          let mask = 128;\n          while (mask > 0) {\n            data[pos++] = elem & mask ? 0 : 255;\n            mask >>= 1;\n          }\n        }\n        let count = 0;\n        pos = 0;\n        if (data[pos] !== 0) {\n          points[0] = 1;\n          ++count;\n        }\n        for (j = 1; j < width; j++) {\n          if (data[pos] !== data[pos + 1]) {\n            points[j] = data[pos] ? 2 : 1;\n            ++count;\n          }\n          pos++;\n        }\n        if (data[pos] !== 0) {\n          points[j] = 2;\n          ++count;\n        }\n        for (i = 1; i < height; i++) {\n          pos = i * lineSize;\n          j0 = i * width1;\n          if (data[pos - lineSize] !== data[pos]) {\n            points[j0] = data[pos] ? 1 : 8;\n            ++count;\n          }\n          let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n          for (j = 1; j < width; j++) {\n            sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n            if (POINT_TYPES[sum]) {\n              points[j0 + j] = POINT_TYPES[sum];\n              ++count;\n            }\n            pos++;\n          }\n          if (data[pos - lineSize] !== data[pos]) {\n            points[j0 + j] = data[pos] ? 2 : 4;\n            ++count;\n          }\n          if (count > POINT_TO_PROCESS_LIMIT) {\n            return null;\n          }\n        }\n        pos = lineSize * (height - 1);\n        j0 = i * width1;\n        if (data[pos] !== 0) {\n          points[j0] = 8;\n          ++count;\n        }\n        for (j = 1; j < width; j++) {\n          if (data[pos] !== data[pos + 1]) {\n            points[j0 + j] = data[pos] ? 4 : 8;\n            ++count;\n          }\n          pos++;\n        }\n        if (data[pos] !== 0) {\n          points[j0 + j] = 4;\n          ++count;\n        }\n        if (count > POINT_TO_PROCESS_LIMIT) {\n          return null;\n        }\n        const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n        const outlines = [];\n        for (i = 0; count && i <= height; i++) {\n          let p = i * width1;\n          const end = p + width;\n          while (p < end && !points[p]) {\n            p++;\n          }\n          if (p === end) {\n            continue;\n          }\n          const coords = [p % width1, i];\n          const p0 = p;\n          let type = points[p];\n          do {\n            const step = steps[type];\n            do {\n              p += step;\n            } while (!points[p]);\n            const pp = points[p];\n            if (pp !== 5 && pp !== 10) {\n              type = pp;\n              points[p] = 0;\n            } else {\n              type = pp & 0x33 * type >> 4;\n              points[p] &= type >> 2 | type << 2;\n            }\n            coords.push(p % width1, p / width1 | 0);\n            if (!points[p]) {\n              --count;\n            }\n          } while (p0 !== p);\n          outlines.push(coords);\n          --i;\n        }\n        const drawOutline = function (c) {\n          c.save();\n          c.scale(1 / width, -1 / height);\n          c.translate(0, -height);\n          c.beginPath();\n          for (let k = 0, kk = outlines.length; k < kk; k++) {\n            const o = outlines[k];\n            c.moveTo(o[0], o[1]);\n            for (let l = 2, ll = o.length; l < ll; l += 2) {\n              c.lineTo(o[l], o[l + 1]);\n            }\n          }\n          c.fill();\n          c.beginPath();\n          c.restore();\n        };\n        return drawOutline;\n      }\n      class CanvasExtraState {\n        constructor(width, height) {\n          this.alphaIsShape = false;\n          this.fontSize = 0;\n          this.fontSizeScale = 1;\n          this.textMatrix = _util.IDENTITY_MATRIX;\n          this.textMatrixScale = 1;\n          this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n          this.leading = 0;\n          this.x = 0;\n          this.y = 0;\n          this.lineX = 0;\n          this.lineY = 0;\n          this.charSpacing = 0;\n          this.wordSpacing = 0;\n          this.textHScale = 1;\n          this.textRenderingMode = _util.TextRenderingMode.FILL;\n          this.textRise = 0;\n          this.fillColor = \"#000000\";\n          this.strokeColor = \"#000000\";\n          this.patternFill = false;\n          this.fillAlpha = 1;\n          this.strokeAlpha = 1;\n          this.lineWidth = 1;\n          this.activeSMask = null;\n          this.transferMaps = null;\n          this.startNewPathAndClipBox([0, 0, width, height]);\n        }\n        clone() {\n          const clone = Object.create(this);\n          clone.clipBox = this.clipBox.slice();\n          return clone;\n        }\n        setCurrentPoint(x, y) {\n          this.x = x;\n          this.y = y;\n        }\n        updatePathMinMax(transform, x, y) {\n          [x, y] = _util.Util.applyTransform([x, y], transform);\n          this.minX = Math.min(this.minX, x);\n          this.minY = Math.min(this.minY, y);\n          this.maxX = Math.max(this.maxX, x);\n          this.maxY = Math.max(this.maxY, y);\n        }\n        updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3) {\n          const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n          this.updatePathMinMax(transform, box[0], box[1]);\n          this.updatePathMinMax(transform, box[2], box[3]);\n        }\n        getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n          const box = [this.minX, this.minY, this.maxX, this.maxY];\n          if (pathType === _pattern_helper.PathType.STROKE) {\n            if (!transform) {\n              (0, _util.unreachable)(\"Stroke bounding box must include transform.\");\n            }\n            const scale = _util.Util.singularValueDecompose2dScale(transform);\n            const xStrokePad = scale[0] * this.lineWidth / 2;\n            const yStrokePad = scale[1] * this.lineWidth / 2;\n            box[0] -= xStrokePad;\n            box[1] -= yStrokePad;\n            box[2] += xStrokePad;\n            box[3] += yStrokePad;\n          }\n          return box;\n        }\n        updateClipFromPath() {\n          const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());\n          this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n        }\n        startNewPathAndClipBox(box) {\n          this.clipBox = box;\n          this.minX = Infinity;\n          this.minY = Infinity;\n          this.maxX = 0;\n          this.maxY = 0;\n        }\n        getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {\n          return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n        }\n      }\n      function putBinaryImageData(ctx, imgData, transferMaps = null) {\n        if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n          ctx.putImageData(imgData, 0, 0);\n          return;\n        }\n        const height = imgData.height,\n          width = imgData.width;\n        const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n        const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n        const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n        const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n        let srcPos = 0,\n          destPos;\n        const src = imgData.data;\n        const dest = chunkImgData.data;\n        let i, j, thisChunkHeight, elemsInThisChunk;\n        let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;\n        if (transferMaps) {\n          switch (transferMaps.length) {\n            case 1:\n              transferMapRed = transferMaps[0];\n              transferMapGreen = transferMaps[0];\n              transferMapBlue = transferMaps[0];\n              transferMapGray = transferMaps[0];\n              break;\n            case 4:\n              transferMapRed = transferMaps[0];\n              transferMapGreen = transferMaps[1];\n              transferMapBlue = transferMaps[2];\n              transferMapGray = transferMaps[3];\n              break;\n          }\n        }\n        if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n          const srcLength = src.byteLength;\n          const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n          const dest32DataLength = dest32.length;\n          const fullSrcDiff = width + 7 >> 3;\n          let white = 0xffffffff;\n          let black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;\n          if (transferMapGray) {\n            if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {\n              [white, black] = [black, white];\n            }\n          }\n          for (i = 0; i < totalChunks; i++) {\n            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n            destPos = 0;\n            for (j = 0; j < thisChunkHeight; j++) {\n              const srcDiff = srcLength - srcPos;\n              let k = 0;\n              const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n              const kEndUnrolled = kEnd & ~7;\n              let mask = 0;\n              let srcByte = 0;\n              for (; k < kEndUnrolled; k += 8) {\n                srcByte = src[srcPos++];\n                dest32[destPos++] = srcByte & 128 ? white : black;\n                dest32[destPos++] = srcByte & 64 ? white : black;\n                dest32[destPos++] = srcByte & 32 ? white : black;\n                dest32[destPos++] = srcByte & 16 ? white : black;\n                dest32[destPos++] = srcByte & 8 ? white : black;\n                dest32[destPos++] = srcByte & 4 ? white : black;\n                dest32[destPos++] = srcByte & 2 ? white : black;\n                dest32[destPos++] = srcByte & 1 ? white : black;\n              }\n              for (; k < kEnd; k++) {\n                if (mask === 0) {\n                  srcByte = src[srcPos++];\n                  mask = 128;\n                }\n                dest32[destPos++] = srcByte & mask ? white : black;\n                mask >>= 1;\n              }\n            }\n            while (destPos < dest32DataLength) {\n              dest32[destPos++] = 0;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n          }\n        } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n          const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n          j = 0;\n          elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n          for (i = 0; i < fullChunks; i++) {\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            srcPos += elemsInThisChunk;\n            if (hasTransferMaps) {\n              for (let k = 0; k < elemsInThisChunk; k += 4) {\n                if (transferMapRed) {\n                  dest[k + 0] = transferMapRed[dest[k + 0]];\n                }\n                if (transferMapGreen) {\n                  dest[k + 1] = transferMapGreen[dest[k + 1]];\n                }\n                if (transferMapBlue) {\n                  dest[k + 2] = transferMapBlue[dest[k + 2]];\n                }\n              }\n            }\n            ctx.putImageData(chunkImgData, 0, j);\n            j += FULL_CHUNK_HEIGHT;\n          }\n          if (i < totalChunks) {\n            elemsInThisChunk = width * partialChunkHeight * 4;\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            if (hasTransferMaps) {\n              for (let k = 0; k < elemsInThisChunk; k += 4) {\n                if (transferMapRed) {\n                  dest[k + 0] = transferMapRed[dest[k + 0]];\n                }\n                if (transferMapGreen) {\n                  dest[k + 1] = transferMapGreen[dest[k + 1]];\n                }\n                if (transferMapBlue) {\n                  dest[k + 2] = transferMapBlue[dest[k + 2]];\n                }\n              }\n            }\n            ctx.putImageData(chunkImgData, 0, j);\n          }\n        } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n          const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n          thisChunkHeight = FULL_CHUNK_HEIGHT;\n          elemsInThisChunk = width * thisChunkHeight;\n          for (i = 0; i < totalChunks; i++) {\n            if (i >= fullChunks) {\n              thisChunkHeight = partialChunkHeight;\n              elemsInThisChunk = width * thisChunkHeight;\n            }\n            destPos = 0;\n            for (j = elemsInThisChunk; j--;) {\n              dest[destPos++] = src[srcPos++];\n              dest[destPos++] = src[srcPos++];\n              dest[destPos++] = src[srcPos++];\n              dest[destPos++] = 255;\n            }\n            if (hasTransferMaps) {\n              for (let k = 0; k < destPos; k += 4) {\n                if (transferMapRed) {\n                  dest[k + 0] = transferMapRed[dest[k + 0]];\n                }\n                if (transferMapGreen) {\n                  dest[k + 1] = transferMapGreen[dest[k + 1]];\n                }\n                if (transferMapBlue) {\n                  dest[k + 2] = transferMapBlue[dest[k + 2]];\n                }\n              }\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n          }\n        } else {\n          throw new Error(`bad image kind: ${imgData.kind}`);\n        }\n      }\n      function putBinaryImageMask(ctx, imgData) {\n        const height = imgData.height,\n          width = imgData.width;\n        const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n        const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n        const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n        const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n        let srcPos = 0;\n        const src = imgData.data;\n        const dest = chunkImgData.data;\n        for (let i = 0; i < totalChunks; i++) {\n          const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n          let destPos = 3;\n          for (let j = 0; j < thisChunkHeight; j++) {\n            let elem,\n              mask = 0;\n            for (let k = 0; k < width; k++) {\n              if (!mask) {\n                elem = src[srcPos++];\n                mask = 128;\n              }\n              dest[destPos] = elem & mask ? 0 : 255;\n              destPos += 4;\n              mask >>= 1;\n            }\n          }\n          ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n      }\n      function copyCtxState(sourceCtx, destCtx) {\n        const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\"];\n        for (let i = 0, ii = properties.length; i < ii; i++) {\n          const property = properties[i];\n          if (sourceCtx[property] !== undefined) {\n            destCtx[property] = sourceCtx[property];\n          }\n        }\n        if (sourceCtx.setLineDash !== undefined) {\n          destCtx.setLineDash(sourceCtx.getLineDash());\n          destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n        }\n      }\n      function resetCtxToDefault(ctx) {\n        ctx.strokeStyle = \"#000000\";\n        ctx.fillStyle = \"#000000\";\n        ctx.fillRule = \"nonzero\";\n        ctx.globalAlpha = 1;\n        ctx.lineWidth = 1;\n        ctx.lineCap = \"butt\";\n        ctx.lineJoin = \"miter\";\n        ctx.miterLimit = 10;\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.font = \"10px sans-serif\";\n        if (ctx.setLineDash !== undefined) {\n          ctx.setLineDash([]);\n          ctx.lineDashOffset = 0;\n        }\n      }\n      function composeSMaskBackdrop(bytes, r0, g0, b0) {\n        const length = bytes.length;\n        for (let i = 3; i < length; i += 4) {\n          const alpha = bytes[i];\n          if (alpha === 0) {\n            bytes[i - 3] = r0;\n            bytes[i - 2] = g0;\n            bytes[i - 1] = b0;\n          } else if (alpha < 255) {\n            const alpha_ = 255 - alpha;\n            bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n            bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n            bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n          }\n        }\n      }\n      function composeSMaskAlpha(maskData, layerData, transferMap) {\n        const length = maskData.length;\n        const scale = 1 / 255;\n        for (let i = 3; i < length; i += 4) {\n          const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n          layerData[i] = layerData[i] * alpha * scale | 0;\n        }\n      }\n      function composeSMaskLuminosity(maskData, layerData, transferMap) {\n        const length = maskData.length;\n        for (let i = 3; i < length; i += 4) {\n          const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n          layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n        }\n      }\n      function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n        const hasBackdrop = !!backdrop;\n        const r0 = hasBackdrop ? backdrop[0] : 0;\n        const g0 = hasBackdrop ? backdrop[1] : 0;\n        const b0 = hasBackdrop ? backdrop[2] : 0;\n        let composeFn;\n        if (subtype === \"Luminosity\") {\n          composeFn = composeSMaskLuminosity;\n        } else {\n          composeFn = composeSMaskAlpha;\n        }\n        const PIXELS_TO_PROCESS = 1048576;\n        const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n        for (let row = 0; row < height; row += chunkSize) {\n          const chunkHeight = Math.min(chunkSize, height - row);\n          const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);\n          const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);\n          if (hasBackdrop) {\n            composeSMaskBackdrop(maskData.data, r0, g0, b0);\n          }\n          composeFn(maskData.data, layerData.data, transferMap);\n          layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n        }\n      }\n      function composeSMask(ctx, smask, layerCtx, layerBox) {\n        const layerOffsetX = layerBox[0];\n        const layerOffsetY = layerBox[1];\n        const layerWidth = layerBox[2] - layerOffsetX;\n        const layerHeight = layerBox[3] - layerOffsetY;\n        if (layerWidth === 0 || layerHeight === 0) {\n          return;\n        }\n        genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n        ctx.save();\n        ctx.globalAlpha = 1;\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(layerCtx.canvas, 0, 0);\n        ctx.restore();\n      }\n      function getImageSmoothingEnabled(transform, interpolate) {\n        const scale = _util.Util.singularValueDecompose2dScale(transform);\n        scale[0] = Math.fround(scale[0]);\n        scale[1] = Math.fround(scale[1]);\n        const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n        if (interpolate !== undefined) {\n          return interpolate;\n        } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n          return true;\n        }\n        return false;\n      }\n      const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n      const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n      const NORMAL_CLIP = {};\n      const EO_CLIP = {};\n      class CanvasGraphics {\n        constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap) {\n          this.ctx = canvasCtx;\n          this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n          this.stateStack = [];\n          this.pendingClip = null;\n          this.pendingEOFill = false;\n          this.res = null;\n          this.xobjs = null;\n          this.commonObjs = commonObjs;\n          this.objs = objs;\n          this.canvasFactory = canvasFactory;\n          this.imageLayer = imageLayer;\n          this.groupStack = [];\n          this.processingType3 = null;\n          this.baseTransform = null;\n          this.baseTransformStack = [];\n          this.groupLevel = 0;\n          this.smaskStack = [];\n          this.smaskCounter = 0;\n          this.tempSMask = null;\n          this.suspendedCtx = null;\n          this.contentVisible = true;\n          this.markedContentStack = [];\n          this.optionalContentConfig = optionalContentConfig;\n          this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n          this.cachedPatterns = new Map();\n          this.annotationCanvasMap = annotationCanvasMap;\n          this.viewportScale = 1;\n          this.outputScaleX = 1;\n          this.outputScaleY = 1;\n          if (canvasCtx) {\n            addContextCurrentTransform(canvasCtx);\n          }\n          this._cachedGetSinglePixelWidth = null;\n        }\n        beginDrawing({\n          transform,\n          viewport,\n          transparency = false,\n          background = null\n        }) {\n          const width = this.ctx.canvas.width;\n          const height = this.ctx.canvas.height;\n          this.ctx.save();\n          this.ctx.fillStyle = background || \"rgb(255, 255, 255)\";\n          this.ctx.fillRect(0, 0, width, height);\n          this.ctx.restore();\n          if (transparency) {\n            const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height, true);\n            this.compositeCtx = this.ctx;\n            this.transparentCanvas = transparentCanvas.canvas;\n            this.ctx = transparentCanvas.context;\n            this.ctx.save();\n            this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);\n          }\n          this.ctx.save();\n          resetCtxToDefault(this.ctx);\n          if (transform) {\n            this.ctx.transform.apply(this.ctx, transform);\n            this.outputScaleX = transform[0];\n            this.outputScaleY = transform[0];\n          }\n          this.ctx.transform.apply(this.ctx, viewport.transform);\n          this.viewportScale = viewport.scale;\n          this.baseTransform = this.ctx.mozCurrentTransform.slice();\n          this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);\n          if (this.imageLayer) {\n            this.imageLayer.beginLayout();\n          }\n        }\n        executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n          const argsArray = operatorList.argsArray;\n          const fnArray = operatorList.fnArray;\n          let i = executionStartIdx || 0;\n          const argsArrayLen = argsArray.length;\n          if (argsArrayLen === i) {\n            return i;\n          }\n          const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n          const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n          let steps = 0;\n          const commonObjs = this.commonObjs;\n          const objs = this.objs;\n          let fnId;\n          while (true) {\n            if (stepper !== undefined && i === stepper.nextBreakPoint) {\n              stepper.breakIt(i, continueCallback);\n              return i;\n            }\n            fnId = fnArray[i];\n            if (fnId !== _util.OPS.dependency) {\n              this[fnId].apply(this, argsArray[i]);\n            } else {\n              for (const depObjId of argsArray[i]) {\n                const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                if (!objsPool.has(depObjId)) {\n                  objsPool.get(depObjId, continueCallback);\n                  return i;\n                }\n              }\n            }\n            i++;\n            if (i === argsArrayLen) {\n              return i;\n            }\n            if (chunkOperations && ++steps > EXECUTION_STEPS) {\n              if (Date.now() > endTime) {\n                continueCallback();\n                return i;\n              }\n              steps = 0;\n            }\n          }\n        }\n        endDrawing() {\n          while (this.stateStack.length || this.current.activeSMask !== null) {\n            this.restore();\n          }\n          this.ctx.restore();\n          if (this.transparentCanvas) {\n            this.ctx = this.compositeCtx;\n            this.ctx.save();\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n            this.ctx.restore();\n            this.transparentCanvas = null;\n          }\n          this.cachedCanvases.clear();\n          this.cachedPatterns.clear();\n          if (this.imageLayer) {\n            this.imageLayer.endLayout();\n          }\n        }\n        _scaleImage(img, inverseTransform) {\n          const width = img.width;\n          const height = img.height;\n          let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n          let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n          let paintWidth = width,\n            paintHeight = height;\n          let tmpCanvasId = \"prescale1\";\n          let tmpCanvas, tmpCtx;\n          while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n            let newWidth = paintWidth,\n              newHeight = paintHeight;\n            if (widthScale > 2 && paintWidth > 1) {\n              newWidth = Math.ceil(paintWidth / 2);\n              widthScale /= paintWidth / newWidth;\n            }\n            if (heightScale > 2 && paintHeight > 1) {\n              newHeight = Math.ceil(paintHeight / 2);\n              heightScale /= paintHeight / newHeight;\n            }\n            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n            tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, newWidth, newHeight);\n            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n            img = tmpCanvas.canvas;\n            paintWidth = newWidth;\n            paintHeight = newHeight;\n            tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n          }\n          return {\n            img,\n            paintWidth,\n            paintHeight\n          };\n        }\n        _createMaskCanvas(img) {\n          const ctx = this.ctx;\n          const width = img.width,\n            height = img.height;\n          const fillColor = this.current.fillColor;\n          const isPatternFill = this.current.patternFill;\n          const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n          const maskCtx = maskCanvas.context;\n          putBinaryImageMask(maskCtx, img);\n          const objToCanvas = ctx.mozCurrentTransform;\n          let maskToCanvas = _util.Util.transform(objToCanvas, [1 / width, 0, 0, -1 / height, 0, 0]);\n          maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n          const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);\n          const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);\n          const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);\n          const drawnWidth = Math.ceil(rect[2] - rect[0]);\n          const drawnHeight = Math.ceil(rect[3] - rect[1]);\n          const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight, true);\n          const fillCtx = fillCanvas.context;\n          const offsetX = Math.min(cord1[0], cord2[0]);\n          const offsetY = Math.min(cord1[1], cord2[1]);\n          fillCtx.translate(-offsetX, -offsetY);\n          fillCtx.transform.apply(fillCtx, maskToCanvas);\n          const scaled = this._scaleImage(maskCanvas.canvas, fillCtx.mozCurrentTransformInverse);\n          fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(fillCtx.mozCurrentTransform, img.interpolate);\n          fillCtx.drawImage(scaled.img, 0, 0, scaled.img.width, scaled.img.height, 0, 0, width, height);\n          fillCtx.globalCompositeOperation = \"source-in\";\n          const inverse = _util.Util.transform(fillCtx.mozCurrentTransformInverse, [1, 0, 0, 1, -offsetX, -offsetY]);\n          fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;\n          fillCtx.fillRect(0, 0, width, height);\n          return {\n            canvas: fillCanvas.canvas,\n            offsetX: Math.round(offsetX),\n            offsetY: Math.round(offsetY)\n          };\n        }\n        setLineWidth(width) {\n          this.current.lineWidth = width;\n          this.ctx.lineWidth = width;\n        }\n        setLineCap(style) {\n          this.ctx.lineCap = LINE_CAP_STYLES[style];\n        }\n        setLineJoin(style) {\n          this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n        }\n        setMiterLimit(limit) {\n          this.ctx.miterLimit = limit;\n        }\n        setDash(dashArray, dashPhase) {\n          const ctx = this.ctx;\n          if (ctx.setLineDash !== undefined) {\n            ctx.setLineDash(dashArray);\n            ctx.lineDashOffset = dashPhase;\n          }\n        }\n        setRenderingIntent(intent) {}\n        setFlatness(flatness) {}\n        setGState(states) {\n          for (let i = 0, ii = states.length; i < ii; i++) {\n            const state = states[i];\n            const key = state[0];\n            const value = state[1];\n            switch (key) {\n              case \"LW\":\n                this.setLineWidth(value);\n                break;\n              case \"LC\":\n                this.setLineCap(value);\n                break;\n              case \"LJ\":\n                this.setLineJoin(value);\n                break;\n              case \"ML\":\n                this.setMiterLimit(value);\n                break;\n              case \"D\":\n                this.setDash(value[0], value[1]);\n                break;\n              case \"RI\":\n                this.setRenderingIntent(value);\n                break;\n              case \"FL\":\n                this.setFlatness(value);\n                break;\n              case \"Font\":\n                this.setFont(value[0], value[1]);\n                break;\n              case \"CA\":\n                this.current.strokeAlpha = state[1];\n                break;\n              case \"ca\":\n                this.current.fillAlpha = state[1];\n                this.ctx.globalAlpha = state[1];\n                break;\n              case \"BM\":\n                this.ctx.globalCompositeOperation = value;\n                break;\n              case \"SMask\":\n                this.current.activeSMask = value ? this.tempSMask : null;\n                this.tempSMask = null;\n                this.checkSMaskState();\n                break;\n              case \"TR\":\n                this.current.transferMaps = value;\n            }\n          }\n        }\n        checkSMaskState() {\n          const inSMaskMode = !!this.suspendedCtx;\n          if (this.current.activeSMask && !inSMaskMode) {\n            this.beginSMaskMode();\n          } else if (!this.current.activeSMask && inSMaskMode) {\n            this.endSMaskMode();\n          }\n        }\n        beginSMaskMode() {\n          if (this.suspendedCtx) {\n            throw new Error(\"beginSMaskMode called while already in smask mode\");\n          }\n          const drawnWidth = this.ctx.canvas.width;\n          const drawnHeight = this.ctx.canvas.height;\n          const cacheId = \"smaskGroupAt\" + this.groupLevel;\n          const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n          this.suspendedCtx = this.ctx;\n          this.ctx = scratchCanvas.context;\n          const ctx = this.ctx;\n          ctx.setTransform.apply(ctx, this.suspendedCtx.mozCurrentTransform);\n          copyCtxState(this.suspendedCtx, ctx);\n          mirrorContextOperations(ctx, this.suspendedCtx);\n          this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n        }\n        endSMaskMode() {\n          if (!this.suspendedCtx) {\n            throw new Error(\"endSMaskMode called while not in smask mode\");\n          }\n          this.ctx._removeMirroring();\n          copyCtxState(this.ctx, this.suspendedCtx);\n          this.ctx = this.suspendedCtx;\n          this.current.activeSMask = null;\n          this.suspendedCtx = null;\n        }\n        compose(dirtyBox) {\n          if (!this.current.activeSMask) {\n            return;\n          }\n          if (!dirtyBox) {\n            dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n          } else {\n            dirtyBox[0] = Math.floor(dirtyBox[0]);\n            dirtyBox[1] = Math.floor(dirtyBox[1]);\n            dirtyBox[2] = Math.ceil(dirtyBox[2]);\n            dirtyBox[3] = Math.ceil(dirtyBox[3]);\n          }\n          const smask = this.current.activeSMask;\n          const suspendedCtx = this.suspendedCtx;\n          composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n          this.ctx.save();\n          this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n          this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n          this.ctx.restore();\n        }\n        save() {\n          this.ctx.save();\n          const old = this.current;\n          this.stateStack.push(old);\n          this.current = old.clone();\n        }\n        restore() {\n          if (this.stateStack.length === 0 && this.current.activeSMask) {\n            this.endSMaskMode();\n          }\n          if (this.stateStack.length !== 0) {\n            this.current = this.stateStack.pop();\n            this.ctx.restore();\n            this.checkSMaskState();\n            this.pendingClip = null;\n            this._cachedGetSinglePixelWidth = null;\n          }\n        }\n        transform(a, b, c, d, e, f) {\n          this.ctx.transform(a, b, c, d, e, f);\n          this._cachedGetSinglePixelWidth = null;\n        }\n        constructPath(ops, args) {\n          const ctx = this.ctx;\n          const current = this.current;\n          let x = current.x,\n            y = current.y;\n          let startX, startY;\n          for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {\n            switch (ops[i] | 0) {\n              case _util.OPS.rectangle:\n                x = args[j++];\n                y = args[j++];\n                const width = args[j++];\n                const height = args[j++];\n                const xw = x + width;\n                const yh = y + height;\n                ctx.moveTo(x, y);\n                if (width === 0 || height === 0) {\n                  ctx.lineTo(xw, yh);\n                } else {\n                  ctx.lineTo(xw, y);\n                  ctx.lineTo(xw, yh);\n                  ctx.lineTo(x, yh);\n                }\n                current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n                current.updatePathMinMax(ctx.mozCurrentTransform, xw, yh);\n                ctx.closePath();\n                break;\n              case _util.OPS.moveTo:\n                x = args[j++];\n                y = args[j++];\n                ctx.moveTo(x, y);\n                current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n                break;\n              case _util.OPS.lineTo:\n                x = args[j++];\n                y = args[j++];\n                ctx.lineTo(x, y);\n                current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n                break;\n              case _util.OPS.curveTo:\n                startX = x;\n                startY = y;\n                x = args[j + 4];\n                y = args[j + 5];\n                ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n                current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n                j += 6;\n                break;\n              case _util.OPS.curveTo2:\n                startX = x;\n                startY = y;\n                ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n                current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n                x = args[j + 2];\n                y = args[j + 3];\n                j += 4;\n                break;\n              case _util.OPS.curveTo3:\n                startX = x;\n                startY = y;\n                x = args[j + 2];\n                y = args[j + 3];\n                ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n                current.updateCurvePathMinMax(ctx.mozCurrentTransform, startX, startY, args[j], args[j + 1], x, y, x, y);\n                j += 4;\n                break;\n              case _util.OPS.closePath:\n                ctx.closePath();\n                break;\n            }\n          }\n          current.setCurrentPoint(x, y);\n        }\n        closePath() {\n          this.ctx.closePath();\n        }\n        stroke(consumePath) {\n          consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n          const ctx = this.ctx;\n          const strokeColor = this.current.strokeColor;\n          ctx.globalAlpha = this.current.strokeAlpha;\n          if (this.contentVisible) {\n            if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n              const lineWidth = this.getSinglePixelWidth();\n              ctx.save();\n              ctx.strokeStyle = strokeColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.STROKE);\n              ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);\n              ctx.stroke();\n              ctx.restore();\n            } else {\n              const lineWidth = this.getSinglePixelWidth();\n              if (lineWidth < 0 && -lineWidth >= this.current.lineWidth) {\n                ctx.save();\n                ctx.resetTransform();\n                ctx.lineWidth = Math.round(this._combinedScaleFactor);\n                ctx.stroke();\n                ctx.restore();\n              } else {\n                ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);\n                ctx.stroke();\n              }\n            }\n          }\n          if (consumePath) {\n            this.consumePath(this.current.getClippedPathBoundingBox());\n          }\n          ctx.globalAlpha = this.current.fillAlpha;\n        }\n        closeStroke() {\n          this.closePath();\n          this.stroke();\n        }\n        fill(consumePath) {\n          consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n          const ctx = this.ctx;\n          const fillColor = this.current.fillColor;\n          const isPatternFill = this.current.patternFill;\n          let needRestore = false;\n          if (isPatternFill) {\n            ctx.save();\n            ctx.fillStyle = fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);\n            needRestore = true;\n          }\n          const intersect = this.current.getClippedPathBoundingBox();\n          if (this.contentVisible && intersect !== null) {\n            if (this.pendingEOFill) {\n              ctx.fill(\"evenodd\");\n              this.pendingEOFill = false;\n            } else {\n              ctx.fill();\n            }\n          }\n          if (needRestore) {\n            ctx.restore();\n          }\n          if (consumePath) {\n            this.consumePath(intersect);\n          }\n        }\n        eoFill() {\n          this.pendingEOFill = true;\n          this.fill();\n        }\n        fillStroke() {\n          this.fill(false);\n          this.stroke(false);\n          this.consumePath();\n        }\n        eoFillStroke() {\n          this.pendingEOFill = true;\n          this.fillStroke();\n        }\n        closeFillStroke() {\n          this.closePath();\n          this.fillStroke();\n        }\n        closeEOFillStroke() {\n          this.pendingEOFill = true;\n          this.closePath();\n          this.fillStroke();\n        }\n        endPath() {\n          this.consumePath();\n        }\n        clip() {\n          this.pendingClip = NORMAL_CLIP;\n        }\n        eoClip() {\n          this.pendingClip = EO_CLIP;\n        }\n        beginText() {\n          this.current.textMatrix = _util.IDENTITY_MATRIX;\n          this.current.textMatrixScale = 1;\n          this.current.x = this.current.lineX = 0;\n          this.current.y = this.current.lineY = 0;\n        }\n        endText() {\n          const paths = this.pendingTextPaths;\n          const ctx = this.ctx;\n          if (paths === undefined) {\n            ctx.beginPath();\n            return;\n          }\n          ctx.save();\n          ctx.beginPath();\n          for (let i = 0; i < paths.length; i++) {\n            const path = paths[i];\n            ctx.setTransform.apply(ctx, path.transform);\n            ctx.translate(path.x, path.y);\n            path.addToPath(ctx, path.fontSize);\n          }\n          ctx.restore();\n          ctx.clip();\n          ctx.beginPath();\n          delete this.pendingTextPaths;\n        }\n        setCharSpacing(spacing) {\n          this.current.charSpacing = spacing;\n        }\n        setWordSpacing(spacing) {\n          this.current.wordSpacing = spacing;\n        }\n        setHScale(scale) {\n          this.current.textHScale = scale / 100;\n        }\n        setLeading(leading) {\n          this.current.leading = -leading;\n        }\n        setFont(fontRefName, size) {\n          const fontObj = this.commonObjs.get(fontRefName);\n          const current = this.current;\n          if (!fontObj) {\n            throw new Error(`Can't find font for ${fontRefName}`);\n          }\n          current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n          if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n            (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n          }\n          if (size < 0) {\n            size = -size;\n            current.fontDirection = -1;\n          } else {\n            current.fontDirection = 1;\n          }\n          this.current.font = fontObj;\n          this.current.fontSize = size;\n          if (fontObj.isType3Font) {\n            return;\n          }\n          const name = fontObj.loadedName || \"sans-serif\";\n          let bold = \"normal\";\n          if (fontObj.black) {\n            bold = \"900\";\n          } else if (fontObj.bold) {\n            bold = \"bold\";\n          }\n          const italic = fontObj.italic ? \"italic\" : \"normal\";\n          const typeface = `\"${name}\", ${fontObj.fallbackName}`;\n          let browserFontSize = size;\n          if (size < MIN_FONT_SIZE) {\n            browserFontSize = MIN_FONT_SIZE;\n          } else if (size > MAX_FONT_SIZE) {\n            browserFontSize = MAX_FONT_SIZE;\n          }\n          this.current.fontSizeScale = size / browserFontSize;\n          this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n        }\n        setTextRenderingMode(mode) {\n          this.current.textRenderingMode = mode;\n        }\n        setTextRise(rise) {\n          this.current.textRise = rise;\n        }\n        moveText(x, y) {\n          this.current.x = this.current.lineX += x;\n          this.current.y = this.current.lineY += y;\n        }\n        setLeadingMoveText(x, y) {\n          this.setLeading(-y);\n          this.moveText(x, y);\n        }\n        setTextMatrix(a, b, c, d, e, f) {\n          this.current.textMatrix = [a, b, c, d, e, f];\n          this.current.textMatrixScale = Math.hypot(a, b);\n          this.current.x = this.current.lineX = 0;\n          this.current.y = this.current.lineY = 0;\n        }\n        nextLine() {\n          this.moveText(0, this.current.leading);\n        }\n        paintChar(character, x, y, patternTransform, resetLineWidthToOne) {\n          const ctx = this.ctx;\n          const current = this.current;\n          const font = current.font;\n          const textRenderingMode = current.textRenderingMode;\n          const fontSize = current.fontSize / current.fontSizeScale;\n          const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n          const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n          const patternFill = current.patternFill && !font.missingFile;\n          let addToPath;\n          if (font.disableFontFace || isAddToPathSet || patternFill) {\n            addToPath = font.getPathGenerator(this.commonObjs, character);\n          }\n          if (font.disableFontFace || patternFill) {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.beginPath();\n            addToPath(ctx, fontSize);\n            if (patternTransform) {\n              ctx.setTransform.apply(ctx, patternTransform);\n            }\n            if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n              ctx.fill();\n            }\n            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n              if (resetLineWidthToOne) {\n                ctx.resetTransform();\n                ctx.lineWidth = Math.round(this._combinedScaleFactor);\n              }\n              ctx.stroke();\n            }\n            ctx.restore();\n          } else {\n            if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n              ctx.fillText(character, x, y);\n            }\n            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n              if (resetLineWidthToOne) {\n                ctx.save();\n                ctx.moveTo(x, y);\n                ctx.resetTransform();\n                ctx.lineWidth = Math.round(this._combinedScaleFactor);\n                ctx.strokeText(character, 0, 0);\n                ctx.restore();\n              } else {\n                ctx.strokeText(character, x, y);\n              }\n            }\n          }\n          if (isAddToPathSet) {\n            const paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n            paths.push({\n              transform: ctx.mozCurrentTransform,\n              x,\n              y,\n              fontSize,\n              addToPath\n            });\n          }\n        }\n        get isFontSubpixelAAEnabled() {\n          const {\n            context: ctx\n          } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n          ctx.scale(1.5, 1);\n          ctx.fillText(\"I\", 0, 10);\n          const data = ctx.getImageData(0, 0, 10, 10).data;\n          let enabled = false;\n          for (let i = 3; i < data.length; i += 4) {\n            if (data[i] > 0 && data[i] < 255) {\n              enabled = true;\n              break;\n            }\n          }\n          return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n        }\n        showText(glyphs) {\n          const current = this.current;\n          const font = current.font;\n          if (font.isType3Font) {\n            return this.showType3Text(glyphs);\n          }\n          const fontSize = current.fontSize;\n          if (fontSize === 0) {\n            return undefined;\n          }\n          const ctx = this.ctx;\n          const fontSizeScale = current.fontSizeScale;\n          const charSpacing = current.charSpacing;\n          const wordSpacing = current.wordSpacing;\n          const fontDirection = current.fontDirection;\n          const textHScale = current.textHScale * fontDirection;\n          const glyphsLength = glyphs.length;\n          const vertical = font.vertical;\n          const spacingDir = vertical ? 1 : -1;\n          const defaultVMetrics = font.defaultVMetrics;\n          const widthAdvanceScale = fontSize * current.fontMatrix[0];\n          const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n          ctx.save();\n          ctx.transform.apply(ctx, current.textMatrix);\n          ctx.translate(current.x, current.y + current.textRise);\n          if (fontDirection > 0) {\n            ctx.scale(textHScale, -1);\n          } else {\n            ctx.scale(textHScale, 1);\n          }\n          let patternTransform;\n          if (current.patternFill) {\n            ctx.save();\n            const pattern = current.fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL);\n            patternTransform = ctx.mozCurrentTransform;\n            ctx.restore();\n            ctx.fillStyle = pattern;\n          }\n          let lineWidth = current.lineWidth;\n          let resetLineWidthToOne = false;\n          const scale = current.textMatrixScale;\n          if (scale === 0 || lineWidth === 0) {\n            const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n              this._cachedGetSinglePixelWidth = null;\n              lineWidth = this.getSinglePixelWidth();\n              resetLineWidthToOne = lineWidth < 0;\n            }\n          } else {\n            lineWidth /= scale;\n          }\n          if (fontSizeScale !== 1.0) {\n            ctx.scale(fontSizeScale, fontSizeScale);\n            lineWidth /= fontSizeScale;\n          }\n          ctx.lineWidth = lineWidth;\n          let x = 0,\n            i;\n          for (i = 0; i < glyphsLength; ++i) {\n            const glyph = glyphs[i];\n            if ((0, _util.isNum)(glyph)) {\n              x += spacingDir * glyph * fontSize / 1000;\n              continue;\n            }\n            let restoreNeeded = false;\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const character = glyph.fontChar;\n            const accent = glyph.accent;\n            let scaledX, scaledY;\n            let width = glyph.width;\n            if (vertical) {\n              const vmetric = glyph.vmetric || defaultVMetrics;\n              const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n              const vy = vmetric[2] * widthAdvanceScale;\n              width = vmetric ? -vmetric[0] : width;\n              scaledX = vx / fontSizeScale;\n              scaledY = (x + vy) / fontSizeScale;\n            } else {\n              scaledX = x / fontSizeScale;\n              scaledY = 0;\n            }\n            if (font.remeasure && width > 0) {\n              const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n              if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                const characterScaleX = width / measuredWidth;\n                restoreNeeded = true;\n                ctx.save();\n                ctx.scale(characterScaleX, 1);\n                scaledX /= characterScaleX;\n              } else if (width !== measuredWidth) {\n                scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n              }\n            }\n            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n              if (simpleFillText && !accent) {\n                ctx.fillText(character, scaledX, scaledY);\n              } else {\n                this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);\n                if (accent) {\n                  const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                  const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                  this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);\n                }\n              }\n            }\n            let charWidth;\n            if (vertical) {\n              charWidth = width * widthAdvanceScale - spacing * fontDirection;\n            } else {\n              charWidth = width * widthAdvanceScale + spacing * fontDirection;\n            }\n            x += charWidth;\n            if (restoreNeeded) {\n              ctx.restore();\n            }\n          }\n          if (vertical) {\n            current.y -= x;\n          } else {\n            current.x += x * textHScale;\n          }\n          ctx.restore();\n          this.compose();\n          return undefined;\n        }\n        showType3Text(glyphs) {\n          const ctx = this.ctx;\n          const current = this.current;\n          const font = current.font;\n          const fontSize = current.fontSize;\n          const fontDirection = current.fontDirection;\n          const spacingDir = font.vertical ? 1 : -1;\n          const charSpacing = current.charSpacing;\n          const wordSpacing = current.wordSpacing;\n          const textHScale = current.textHScale * fontDirection;\n          const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n          const glyphsLength = glyphs.length;\n          const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n          let i, glyph, width, spacingLength;\n          if (isTextInvisible || fontSize === 0) {\n            return;\n          }\n          this._cachedGetSinglePixelWidth = null;\n          ctx.save();\n          ctx.transform.apply(ctx, current.textMatrix);\n          ctx.translate(current.x, current.y);\n          ctx.scale(textHScale, fontDirection);\n          for (i = 0; i < glyphsLength; ++i) {\n            glyph = glyphs[i];\n            if ((0, _util.isNum)(glyph)) {\n              spacingLength = spacingDir * glyph * fontSize / 1000;\n              this.ctx.translate(spacingLength, 0);\n              current.x += spacingLength * textHScale;\n              continue;\n            }\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const operatorList = font.charProcOperatorList[glyph.operatorListId];\n            if (!operatorList) {\n              (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n              continue;\n            }\n            if (this.contentVisible) {\n              this.processingType3 = glyph;\n              this.save();\n              ctx.scale(fontSize, fontSize);\n              ctx.transform.apply(ctx, fontMatrix);\n              this.executeOperatorList(operatorList);\n              this.restore();\n            }\n            const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n            width = transformed[0] * fontSize + spacing;\n            ctx.translate(width, 0);\n            current.x += width * textHScale;\n          }\n          ctx.restore();\n          this.processingType3 = null;\n        }\n        setCharWidth(xWidth, yWidth) {}\n        setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n          this.ctx.rect(llx, lly, urx - llx, ury - lly);\n          this.clip();\n          this.endPath();\n        }\n        getColorN_Pattern(IR) {\n          let pattern;\n          if (IR[0] === \"TilingPattern\") {\n            const color = IR[1];\n            const baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();\n            const canvasGraphicsFactory = {\n              createCanvasGraphics: ctx => {\n                return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);\n              }\n            };\n            pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n          } else {\n            pattern = this._getPattern(IR[1], IR[2]);\n          }\n          return pattern;\n        }\n        setStrokeColorN() {\n          this.current.strokeColor = this.getColorN_Pattern(arguments);\n        }\n        setFillColorN() {\n          this.current.fillColor = this.getColorN_Pattern(arguments);\n          this.current.patternFill = true;\n        }\n        setStrokeRGBColor(r, g, b) {\n          const color = _util.Util.makeHexColor(r, g, b);\n          this.ctx.strokeStyle = color;\n          this.current.strokeColor = color;\n        }\n        setFillRGBColor(r, g, b) {\n          const color = _util.Util.makeHexColor(r, g, b);\n          this.ctx.fillStyle = color;\n          this.current.fillColor = color;\n          this.current.patternFill = false;\n        }\n        _getPattern(objId, matrix = null) {\n          let pattern;\n          if (this.cachedPatterns.has(objId)) {\n            pattern = this.cachedPatterns.get(objId);\n          } else {\n            pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));\n            this.cachedPatterns.set(objId, pattern);\n          }\n          if (matrix) {\n            pattern.matrix = matrix;\n          }\n          return pattern;\n        }\n        shadingFill(objId) {\n          if (!this.contentVisible) {\n            return;\n          }\n          const ctx = this.ctx;\n          this.save();\n          const pattern = this._getPattern(objId);\n          ctx.fillStyle = pattern.getPattern(ctx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.SHADING);\n          const inv = ctx.mozCurrentTransformInverse;\n          if (inv) {\n            const canvas = ctx.canvas;\n            const width = canvas.width;\n            const height = canvas.height;\n            const bl = _util.Util.applyTransform([0, 0], inv);\n            const br = _util.Util.applyTransform([0, height], inv);\n            const ul = _util.Util.applyTransform([width, 0], inv);\n            const ur = _util.Util.applyTransform([width, height], inv);\n            const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n            const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n            const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n            const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n          } else {\n            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n          }\n          this.compose(this.current.getClippedPathBoundingBox());\n          this.restore();\n        }\n        beginInlineImage() {\n          (0, _util.unreachable)(\"Should not call beginInlineImage\");\n        }\n        beginImageData() {\n          (0, _util.unreachable)(\"Should not call beginImageData\");\n        }\n        paintFormXObjectBegin(matrix, bbox) {\n          if (!this.contentVisible) {\n            return;\n          }\n          this.save();\n          this.baseTransformStack.push(this.baseTransform);\n          if (Array.isArray(matrix) && matrix.length === 6) {\n            this.transform.apply(this, matrix);\n          }\n          this.baseTransform = this.ctx.mozCurrentTransform;\n          if (bbox) {\n            const width = bbox[2] - bbox[0];\n            const height = bbox[3] - bbox[1];\n            this.ctx.rect(bbox[0], bbox[1], width, height);\n            this.current.updatePathMinMax(this.ctx.mozCurrentTransform, bbox[0], bbox[1]);\n            this.current.updatePathMinMax(this.ctx.mozCurrentTransform, bbox[2], bbox[3]);\n            this.clip();\n            this.endPath();\n          }\n        }\n        paintFormXObjectEnd() {\n          if (!this.contentVisible) {\n            return;\n          }\n          this.restore();\n          this.baseTransform = this.baseTransformStack.pop();\n        }\n        beginGroup(group) {\n          if (!this.contentVisible) {\n            return;\n          }\n          this.save();\n          const suspendedCtx = this.suspendedCtx;\n          if (this.current.activeSMask) {\n            this.suspendedCtx = null;\n            this.current.activeSMask = null;\n          }\n          const currentCtx = this.ctx;\n          if (!group.isolated) {\n            (0, _util.info)(\"TODO: Support non-isolated groups.\");\n          }\n          if (group.knockout) {\n            (0, _util.warn)(\"Knockout groups not supported.\");\n          }\n          const currentTransform = currentCtx.mozCurrentTransform;\n          if (group.matrix) {\n            currentCtx.transform.apply(currentCtx, group.matrix);\n          }\n          if (!group.bbox) {\n            throw new Error(\"Bounding box is required.\");\n          }\n          let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);\n          const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n          bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n          const offsetX = Math.floor(bounds[0]);\n          const offsetY = Math.floor(bounds[1]);\n          let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n          let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n          let scaleX = 1,\n            scaleY = 1;\n          if (drawnWidth > MAX_GROUP_SIZE) {\n            scaleX = drawnWidth / MAX_GROUP_SIZE;\n            drawnWidth = MAX_GROUP_SIZE;\n          }\n          if (drawnHeight > MAX_GROUP_SIZE) {\n            scaleY = drawnHeight / MAX_GROUP_SIZE;\n            drawnHeight = MAX_GROUP_SIZE;\n          }\n          this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n          let cacheId = \"groupAt\" + this.groupLevel;\n          if (group.smask) {\n            cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n          }\n          const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n          const groupCtx = scratchCanvas.context;\n          groupCtx.scale(1 / scaleX, 1 / scaleY);\n          groupCtx.translate(-offsetX, -offsetY);\n          groupCtx.transform.apply(groupCtx, currentTransform);\n          if (group.smask) {\n            this.smaskStack.push({\n              canvas: scratchCanvas.canvas,\n              context: groupCtx,\n              offsetX,\n              offsetY,\n              scaleX,\n              scaleY,\n              subtype: group.smask.subtype,\n              backdrop: group.smask.backdrop,\n              transferMap: group.smask.transferMap || null,\n              startTransformInverse: null\n            });\n          } else {\n            currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n            currentCtx.translate(offsetX, offsetY);\n            currentCtx.scale(scaleX, scaleY);\n            currentCtx.save();\n          }\n          copyCtxState(currentCtx, groupCtx);\n          this.ctx = groupCtx;\n          this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n          this.groupStack.push({\n            ctx: currentCtx,\n            suspendedCtx\n          });\n          this.groupLevel++;\n        }\n        endGroup(group) {\n          if (!this.contentVisible) {\n            return;\n          }\n          this.groupLevel--;\n          const groupCtx = this.ctx;\n          const {\n            ctx,\n            suspendedCtx\n          } = this.groupStack.pop();\n          this.ctx = ctx;\n          this.ctx.imageSmoothingEnabled = false;\n          if (suspendedCtx) {\n            this.suspendedCtx = suspendedCtx;\n          }\n          if (group.smask) {\n            this.tempSMask = this.smaskStack.pop();\n            this.restore();\n          } else {\n            this.ctx.restore();\n            const currentMtx = this.ctx.mozCurrentTransform;\n            this.restore();\n            this.ctx.save();\n            this.ctx.setTransform.apply(this.ctx, currentMtx);\n            const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);\n            this.ctx.drawImage(groupCtx.canvas, 0, 0);\n            this.ctx.restore();\n            this.compose(dirtyBox);\n          }\n        }\n        beginAnnotations() {\n          this.save();\n          if (this.baseTransform) {\n            this.ctx.setTransform.apply(this.ctx, this.baseTransform);\n          }\n        }\n        endAnnotations() {\n          this.restore();\n        }\n        beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n          this.save();\n          if (Array.isArray(rect) && rect.length === 4) {\n            const width = rect[2] - rect[0];\n            const height = rect[3] - rect[1];\n            if (hasOwnCanvas && this.annotationCanvasMap) {\n              transform = transform.slice();\n              transform[4] -= rect[0];\n              transform[5] -= rect[1];\n              rect = rect.slice();\n              rect[0] = rect[1] = 0;\n              rect[2] = width;\n              rect[3] = height;\n              const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(this.ctx.mozCurrentTransform);\n              const {\n                viewportScale\n              } = this;\n              const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n              const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n              this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n              const {\n                canvas,\n                context\n              } = this.annotationCanvas;\n              canvas.style.width = `calc(${width}px * var(--viewport-scale-factor))`;\n              canvas.style.height = `calc(${height}px * var(--viewport-scale-factor))`;\n              this.annotationCanvasMap.set(id, canvas);\n              this.annotationCanvas.savedCtx = this.ctx;\n              this.ctx = context;\n              this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n              addContextCurrentTransform(this.ctx);\n              resetCtxToDefault(this.ctx);\n            } else {\n              resetCtxToDefault(this.ctx);\n              this.ctx.rect(rect[0], rect[1], width, height);\n              this.clip();\n              this.endPath();\n            }\n          }\n          this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n          this.transform.apply(this, transform);\n          this.transform.apply(this, matrix);\n        }\n        endAnnotation() {\n          if (this.annotationCanvas) {\n            this.ctx = this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas;\n          }\n          this.restore();\n        }\n        paintImageMaskXObject(img) {\n          if (!this.contentVisible) {\n            return;\n          }\n          const ctx = this.ctx;\n          const width = img.width,\n            height = img.height;\n          const glyph = this.processingType3;\n          if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\n            if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\n              glyph.compiled = compileType3Glyph({\n                data: img.data,\n                width,\n                height\n              });\n            } else {\n              glyph.compiled = null;\n            }\n          }\n          if (glyph?.compiled) {\n            glyph.compiled(ctx);\n            return;\n          }\n          const mask = this._createMaskCanvas(img);\n          const maskCanvas = mask.canvas;\n          ctx.save();\n          ctx.setTransform(1, 0, 0, 1, 0, 0);\n          ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n          ctx.restore();\n          this.compose();\n        }\n        paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n          if (!this.contentVisible) {\n            return;\n          }\n          const ctx = this.ctx;\n          ctx.save();\n          const currentTransform = ctx.mozCurrentTransform;\n          ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n          const mask = this._createMaskCanvas(imgData);\n          ctx.setTransform(1, 0, 0, 1, 0, 0);\n          for (let i = 0, ii = positions.length; i < ii; i += 2) {\n            const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);\n            const [x, y] = _util.Util.applyTransform([0, 0], trans);\n            ctx.drawImage(mask.canvas, x, y);\n          }\n          ctx.restore();\n          this.compose();\n        }\n        paintImageMaskXObjectGroup(images) {\n          if (!this.contentVisible) {\n            return;\n          }\n          const ctx = this.ctx;\n          const fillColor = this.current.fillColor;\n          const isPatternFill = this.current.patternFill;\n          for (let i = 0, ii = images.length; i < ii; i++) {\n            const image = images[i];\n            const width = image.width,\n              height = image.height;\n            const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            const maskCtx = maskCanvas.context;\n            maskCtx.save();\n            putBinaryImageMask(maskCtx, image);\n            maskCtx.globalCompositeOperation = \"source-in\";\n            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, ctx.mozCurrentTransformInverse, _pattern_helper.PathType.FILL) : fillColor;\n            maskCtx.fillRect(0, 0, width, height);\n            maskCtx.restore();\n            ctx.save();\n            ctx.transform.apply(ctx, image.transform);\n            ctx.scale(1, -1);\n            ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n            ctx.restore();\n          }\n          this.compose();\n        }\n        paintImageXObject(objId) {\n          if (!this.contentVisible) {\n            return;\n          }\n          const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n          if (!imgData) {\n            (0, _util.warn)(\"Dependent image isn't ready yet\");\n            return;\n          }\n          this.paintInlineImageXObject(imgData);\n        }\n        paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n          if (!this.contentVisible) {\n            return;\n          }\n          const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n          if (!imgData) {\n            (0, _util.warn)(\"Dependent image isn't ready yet\");\n            return;\n          }\n          const width = imgData.width;\n          const height = imgData.height;\n          const map = [];\n          for (let i = 0, ii = positions.length; i < ii; i += 2) {\n            map.push({\n              transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n              x: 0,\n              y: 0,\n              w: width,\n              h: height\n            });\n          }\n          this.paintInlineImageXObjectGroup(imgData, map);\n        }\n        paintInlineImageXObject(imgData) {\n          if (!this.contentVisible) {\n            return;\n          }\n          const width = imgData.width;\n          const height = imgData.height;\n          const ctx = this.ctx;\n          this.save();\n          ctx.scale(1 / width, -1 / height);\n          let imgToPaint;\n          if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n            imgToPaint = imgData;\n          } else {\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n            imgToPaint = tmpCanvas.canvas;\n          }\n          const scaled = this._scaleImage(imgToPaint, ctx.mozCurrentTransformInverse);\n          ctx.imageSmoothingEnabled = getImageSmoothingEnabled(ctx.mozCurrentTransform, imgData.interpolate);\n          ctx.drawImage(scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n          if (this.imageLayer) {\n            const position = this.getCanvasPosition(0, -height);\n            this.imageLayer.appendImage({\n              imgData,\n              left: position[0],\n              top: position[1],\n              width: width / ctx.mozCurrentTransformInverse[0],\n              height: height / ctx.mozCurrentTransformInverse[3]\n            });\n          }\n          this.compose();\n          this.restore();\n        }\n        paintInlineImageXObjectGroup(imgData, map) {\n          if (!this.contentVisible) {\n            return;\n          }\n          const ctx = this.ctx;\n          const w = imgData.width;\n          const h = imgData.height;\n          const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n          const tmpCtx = tmpCanvas.context;\n          putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n          for (let i = 0, ii = map.length; i < ii; i++) {\n            const entry = map[i];\n            ctx.save();\n            ctx.transform.apply(ctx, entry.transform);\n            ctx.scale(1, -1);\n            ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n            if (this.imageLayer) {\n              const position = this.getCanvasPosition(entry.x, entry.y);\n              this.imageLayer.appendImage({\n                imgData,\n                left: position[0],\n                top: position[1],\n                width: w,\n                height: h\n              });\n            }\n            ctx.restore();\n          }\n          this.compose();\n        }\n        paintSolidColorImageMask() {\n          if (!this.contentVisible) {\n            return;\n          }\n          this.ctx.fillRect(0, 0, 1, 1);\n          this.compose();\n        }\n        markPoint(tag) {}\n        markPointProps(tag, properties) {}\n        beginMarkedContent(tag) {\n          this.markedContentStack.push({\n            visible: true\n          });\n        }\n        beginMarkedContentProps(tag, properties) {\n          if (tag === \"OC\") {\n            this.markedContentStack.push({\n              visible: this.optionalContentConfig.isVisible(properties)\n            });\n          } else {\n            this.markedContentStack.push({\n              visible: true\n            });\n          }\n          this.contentVisible = this.isContentVisible();\n        }\n        endMarkedContent() {\n          this.markedContentStack.pop();\n          this.contentVisible = this.isContentVisible();\n        }\n        beginCompat() {}\n        endCompat() {}\n        consumePath(clipBox) {\n          if (this.pendingClip) {\n            this.current.updateClipFromPath();\n          }\n          if (!this.pendingClip) {\n            this.compose(clipBox);\n          }\n          const ctx = this.ctx;\n          if (this.pendingClip) {\n            if (this.pendingClip === EO_CLIP) {\n              ctx.clip(\"evenodd\");\n            } else {\n              ctx.clip();\n            }\n            this.pendingClip = null;\n          }\n          this.current.startNewPathAndClipBox(this.current.clipBox);\n          ctx.beginPath();\n        }\n        getSinglePixelWidth() {\n          if (this._cachedGetSinglePixelWidth === null) {\n            const m = this.ctx.mozCurrentTransform;\n            const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n            const sqNorm1 = m[0] ** 2 + m[2] ** 2;\n            const sqNorm2 = m[1] ** 2 + m[3] ** 2;\n            const pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;\n            if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {\n              this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);\n            } else if (absDet > Number.EPSILON) {\n              this._cachedGetSinglePixelWidth = pixelHeight;\n            } else {\n              this._cachedGetSinglePixelWidth = 1;\n            }\n          }\n          return this._cachedGetSinglePixelWidth;\n        }\n        getCanvasPosition(x, y) {\n          const transform = this.ctx.mozCurrentTransform;\n          return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];\n        }\n        isContentVisible() {\n          for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n            if (!this.markedContentStack[i].visible) {\n              return false;\n            }\n          }\n          return true;\n        }\n      }\n      exports.CanvasGraphics = CanvasGraphics;\n      for (const op in _util.OPS) {\n        if (CanvasGraphics.prototype[op] !== undefined) {\n          CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n        }\n      }\n\n      /***/\n    }), (/* 11 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.TilingPattern = exports.PathType = void 0;\n      exports.getShadingPattern = getShadingPattern;\n      var _util = __w_pdfjs_require__(2);\n      const PathType = {\n        FILL: \"Fill\",\n        STROKE: \"Stroke\",\n        SHADING: \"Shading\"\n      };\n      exports.PathType = PathType;\n      function applyBoundingBox(ctx, bbox) {\n        if (!bbox || typeof Path2D === \"undefined\") {\n          return;\n        }\n        const width = bbox[2] - bbox[0];\n        const height = bbox[3] - bbox[1];\n        const region = new Path2D();\n        region.rect(bbox[0], bbox[1], width, height);\n        ctx.clip(region);\n      }\n      class BaseShadingPattern {\n        constructor() {\n          if (this.constructor === BaseShadingPattern) {\n            (0, _util.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n          }\n        }\n        getPattern() {\n          (0, _util.unreachable)(\"Abstract method `getPattern` called.\");\n        }\n      }\n      class RadialAxialShadingPattern extends BaseShadingPattern {\n        constructor(IR) {\n          super();\n          this._type = IR[1];\n          this._bbox = IR[2];\n          this._colorStops = IR[3];\n          this._p0 = IR[4];\n          this._p1 = IR[5];\n          this._r0 = IR[6];\n          this._r1 = IR[7];\n          this.matrix = null;\n        }\n        _createGradient(ctx) {\n          let grad;\n          if (this._type === \"axial\") {\n            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n          } else if (this._type === \"radial\") {\n            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n          }\n          for (const colorStop of this._colorStops) {\n            grad.addColorStop(colorStop[0], colorStop[1]);\n          }\n          return grad;\n        }\n        getPattern(ctx, owner, inverse, pathType) {\n          let pattern;\n          if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, ctx.mozCurrentTransform) || [0, 0, 0, 0];\n            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n            const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true);\n            const tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.beginPath();\n            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n            inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);\n            tmpCtx.transform.apply(tmpCtx, owner.baseTransform);\n            if (this.matrix) {\n              tmpCtx.transform.apply(tmpCtx, this.matrix);\n            }\n            applyBoundingBox(tmpCtx, this._bbox);\n            tmpCtx.fillStyle = this._createGradient(tmpCtx);\n            tmpCtx.fill();\n            pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n            const domMatrix = new DOMMatrix(inverse);\n            try {\n              pattern.setTransform(domMatrix);\n            } catch (ex) {\n              (0, _util.warn)(`RadialAxialShadingPattern.getPattern: \"${ex?.message}\".`);\n            }\n          } else {\n            applyBoundingBox(ctx, this._bbox);\n            pattern = this._createGradient(ctx);\n          }\n          return pattern;\n        }\n      }\n      function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n        const coords = context.coords,\n          colors = context.colors;\n        const bytes = data.data,\n          rowSize = data.width * 4;\n        let tmp;\n        if (coords[p1 + 1] > coords[p2 + 1]) {\n          tmp = p1;\n          p1 = p2;\n          p2 = tmp;\n          tmp = c1;\n          c1 = c2;\n          c2 = tmp;\n        }\n        if (coords[p2 + 1] > coords[p3 + 1]) {\n          tmp = p2;\n          p2 = p3;\n          p3 = tmp;\n          tmp = c2;\n          c2 = c3;\n          c3 = tmp;\n        }\n        if (coords[p1 + 1] > coords[p2 + 1]) {\n          tmp = p1;\n          p1 = p2;\n          p2 = tmp;\n          tmp = c1;\n          c1 = c2;\n          c2 = tmp;\n        }\n        const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n        const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n        const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n        const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n        const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n        const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n        if (y1 >= y3) {\n          return;\n        }\n        const c1r = colors[c1],\n          c1g = colors[c1 + 1],\n          c1b = colors[c1 + 2];\n        const c2r = colors[c2],\n          c2g = colors[c2 + 1],\n          c2b = colors[c2 + 2];\n        const c3r = colors[c3],\n          c3g = colors[c3 + 1],\n          c3b = colors[c3 + 2];\n        const minY = Math.round(y1),\n          maxY = Math.round(y3);\n        let xa, car, cag, cab;\n        let xb, cbr, cbg, cbb;\n        for (let y = minY; y <= maxY; y++) {\n          if (y < y2) {\n            let k;\n            if (y < y1) {\n              k = 0;\n            } else {\n              k = (y1 - y) / (y1 - y2);\n            }\n            xa = x1 - (x1 - x2) * k;\n            car = c1r - (c1r - c2r) * k;\n            cag = c1g - (c1g - c2g) * k;\n            cab = c1b - (c1b - c2b) * k;\n          } else {\n            let k;\n            if (y > y3) {\n              k = 1;\n            } else if (y2 === y3) {\n              k = 0;\n            } else {\n              k = (y2 - y) / (y2 - y3);\n            }\n            xa = x2 - (x2 - x3) * k;\n            car = c2r - (c2r - c3r) * k;\n            cag = c2g - (c2g - c3g) * k;\n            cab = c2b - (c2b - c3b) * k;\n          }\n          let k;\n          if (y < y1) {\n            k = 0;\n          } else if (y > y3) {\n            k = 1;\n          } else {\n            k = (y1 - y) / (y1 - y3);\n          }\n          xb = x1 - (x1 - x3) * k;\n          cbr = c1r - (c1r - c3r) * k;\n          cbg = c1g - (c1g - c3g) * k;\n          cbb = c1b - (c1b - c3b) * k;\n          const x1_ = Math.round(Math.min(xa, xb));\n          const x2_ = Math.round(Math.max(xa, xb));\n          let j = rowSize * y + x1_ * 4;\n          for (let x = x1_; x <= x2_; x++) {\n            k = (xa - x) / (xa - xb);\n            if (k < 0) {\n              k = 0;\n            } else if (k > 1) {\n              k = 1;\n            }\n            bytes[j++] = car - (car - cbr) * k | 0;\n            bytes[j++] = cag - (cag - cbg) * k | 0;\n            bytes[j++] = cab - (cab - cbb) * k | 0;\n            bytes[j++] = 255;\n          }\n        }\n      }\n      function drawFigure(data, figure, context) {\n        const ps = figure.coords;\n        const cs = figure.colors;\n        let i, ii;\n        switch (figure.type) {\n          case \"lattice\":\n            const verticesPerRow = figure.verticesPerRow;\n            const rows = Math.floor(ps.length / verticesPerRow) - 1;\n            const cols = verticesPerRow - 1;\n            for (i = 0; i < rows; i++) {\n              let q = i * verticesPerRow;\n              for (let j = 0; j < cols; j++, q++) {\n                drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n              }\n            }\n            break;\n          case \"triangles\":\n            for (i = 0, ii = ps.length; i < ii; i += 3) {\n              drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n            }\n            break;\n          default:\n            throw new Error(\"illegal figure\");\n        }\n      }\n      class MeshShadingPattern extends BaseShadingPattern {\n        constructor(IR) {\n          super();\n          this._coords = IR[2];\n          this._colors = IR[3];\n          this._figures = IR[4];\n          this._bounds = IR[5];\n          this._bbox = IR[7];\n          this._background = IR[8];\n          this.matrix = null;\n        }\n        _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n          const EXPECTED_SCALE = 1.1;\n          const MAX_PATTERN_SIZE = 3000;\n          const BORDER_SIZE = 2;\n          const offsetX = Math.floor(this._bounds[0]);\n          const offsetY = Math.floor(this._bounds[1]);\n          const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n          const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n          const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n          const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n          const scaleX = boundsWidth / width;\n          const scaleY = boundsHeight / height;\n          const context = {\n            coords: this._coords,\n            colors: this._colors,\n            offsetX: -offsetX,\n            offsetY: -offsetY,\n            scaleX: 1 / scaleX,\n            scaleY: 1 / scaleY\n          };\n          const paddedWidth = width + BORDER_SIZE * 2;\n          const paddedHeight = height + BORDER_SIZE * 2;\n          const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n          const tmpCtx = tmpCanvas.context;\n          const data = tmpCtx.createImageData(width, height);\n          if (backgroundColor) {\n            const bytes = data.data;\n            for (let i = 0, ii = bytes.length; i < ii; i += 4) {\n              bytes[i] = backgroundColor[0];\n              bytes[i + 1] = backgroundColor[1];\n              bytes[i + 2] = backgroundColor[2];\n              bytes[i + 3] = 255;\n            }\n          }\n          for (const figure of this._figures) {\n            drawFigure(data, figure, context);\n          }\n          tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n          const canvas = tmpCanvas.canvas;\n          return {\n            canvas,\n            offsetX: offsetX - BORDER_SIZE * scaleX,\n            offsetY: offsetY - BORDER_SIZE * scaleY,\n            scaleX,\n            scaleY\n          };\n        }\n        getPattern(ctx, owner, inverse, pathType) {\n          applyBoundingBox(ctx, this._bbox);\n          let scale;\n          if (pathType === PathType.SHADING) {\n            scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\n          } else {\n            scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n            if (this.matrix) {\n              const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n              scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n            }\n          }\n          const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n          if (pathType !== PathType.SHADING) {\n            ctx.setTransform.apply(ctx, owner.baseTransform);\n            if (this.matrix) {\n              ctx.transform.apply(ctx, this.matrix);\n            }\n          }\n          ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n          ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n          return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n        }\n      }\n      class DummyShadingPattern extends BaseShadingPattern {\n        getPattern() {\n          return \"hotpink\";\n        }\n      }\n      function getShadingPattern(IR) {\n        switch (IR[0]) {\n          case \"RadialAxial\":\n            return new RadialAxialShadingPattern(IR);\n          case \"Mesh\":\n            return new MeshShadingPattern(IR);\n          case \"Dummy\":\n            return new DummyShadingPattern();\n        }\n        throw new Error(`Unknown IR type: ${IR[0]}`);\n      }\n      const PaintType = {\n        COLORED: 1,\n        UNCOLORED: 2\n      };\n      class TilingPattern {\n        static get MAX_PATTERN_SIZE() {\n          return (0, _util.shadow)(this, \"MAX_PATTERN_SIZE\", 3000);\n        }\n        constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n          this.operatorList = IR[2];\n          this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n          this.bbox = IR[4];\n          this.xstep = IR[5];\n          this.ystep = IR[6];\n          this.paintType = IR[7];\n          this.tilingType = IR[8];\n          this.color = color;\n          this.ctx = ctx;\n          this.canvasGraphicsFactory = canvasGraphicsFactory;\n          this.baseTransform = baseTransform;\n        }\n        createPatternCanvas(owner) {\n          const operatorList = this.operatorList;\n          const bbox = this.bbox;\n          const xstep = this.xstep;\n          const ystep = this.ystep;\n          const paintType = this.paintType;\n          const tilingType = this.tilingType;\n          const color = this.color;\n          const canvasGraphicsFactory = this.canvasGraphicsFactory;\n          (0, _util.info)(\"TilingType: \" + tilingType);\n          const x0 = bbox[0],\n            y0 = bbox[1],\n            x1 = bbox[2],\n            y1 = bbox[3];\n          const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n          const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n          const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n          const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n          const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n          const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n          const tmpCtx = tmpCanvas.context;\n          const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n          graphics.groupLevel = owner.groupLevel;\n          this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n          let adjustedX0 = x0;\n          let adjustedY0 = y0;\n          let adjustedX1 = x1;\n          let adjustedY1 = y1;\n          if (x0 < 0) {\n            adjustedX0 = 0;\n            adjustedX1 += Math.abs(x0);\n          }\n          if (y0 < 0) {\n            adjustedY0 = 0;\n            adjustedY1 += Math.abs(y0);\n          }\n          tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n          graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n          this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n          graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();\n          graphics.executeOperatorList(operatorList);\n          graphics.endDrawing();\n          return {\n            canvas: tmpCanvas.canvas,\n            scaleX: dimx.scale,\n            scaleY: dimy.scale,\n            offsetX: adjustedX0,\n            offsetY: adjustedY0\n          };\n        }\n        getSizeAndScale(step, realOutputSize, scale) {\n          step = Math.abs(step);\n          const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n          let size = Math.ceil(step * scale);\n          if (size >= maxSize) {\n            size = maxSize;\n          } else {\n            scale = size / step;\n          }\n          return {\n            scale,\n            size\n          };\n        }\n        clipBbox(graphics, x0, y0, x1, y1) {\n          const bboxWidth = x1 - x0;\n          const bboxHeight = y1 - y0;\n          graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n          graphics.clip();\n          graphics.endPath();\n        }\n        setFillAndStrokeStyleToContext(graphics, paintType, color) {\n          const context = graphics.ctx,\n            current = graphics.current;\n          switch (paintType) {\n            case PaintType.COLORED:\n              const ctx = this.ctx;\n              context.fillStyle = ctx.fillStyle;\n              context.strokeStyle = ctx.strokeStyle;\n              current.fillColor = ctx.fillStyle;\n              current.strokeColor = ctx.strokeStyle;\n              break;\n            case PaintType.UNCOLORED:\n              const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n              context.fillStyle = cssColor;\n              context.strokeStyle = cssColor;\n              current.fillColor = cssColor;\n              current.strokeColor = cssColor;\n              break;\n            default:\n              throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\n          }\n        }\n        getPattern(ctx, owner, inverse, pathType) {\n          let matrix = inverse;\n          if (pathType !== PathType.SHADING) {\n            matrix = _util.Util.transform(matrix, owner.baseTransform);\n            if (this.matrix) {\n              matrix = _util.Util.transform(matrix, this.matrix);\n            }\n          }\n          const temporaryPatternCanvas = this.createPatternCanvas(owner);\n          let domMatrix = new DOMMatrix(matrix);\n          domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n          domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n          const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n          try {\n            pattern.setTransform(domMatrix);\n          } catch (ex) {\n            (0, _util.warn)(`TilingPattern.getPattern: \"${ex?.message}\".`);\n          }\n          return pattern;\n        }\n      }\n      exports.TilingPattern = TilingPattern;\n\n      /***/\n    }), (/* 12 */\n    /***/(__unused_webpack_module, exports) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.GlobalWorkerOptions = void 0;\n      const GlobalWorkerOptions = Object.create(null);\n      exports.GlobalWorkerOptions = GlobalWorkerOptions;\n      GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;\n      GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? \"\" : GlobalWorkerOptions.workerSrc;\n\n      /***/\n    }), (/* 13 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.MessageHandler = void 0;\n      var _util = __w_pdfjs_require__(2);\n      const CallbackKind = {\n        UNKNOWN: 0,\n        DATA: 1,\n        ERROR: 2\n      };\n      const StreamKind = {\n        UNKNOWN: 0,\n        CANCEL: 1,\n        CANCEL_COMPLETE: 2,\n        CLOSE: 3,\n        ENQUEUE: 4,\n        ERROR: 5,\n        PULL: 6,\n        PULL_COMPLETE: 7,\n        START_COMPLETE: 8\n      };\n      function wrapReason(reason) {\n        if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n          (0, _util.warn)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n          return reason;\n        }\n        switch (reason.name) {\n          case \"AbortException\":\n            return new _util.AbortException(reason.message);\n          case \"MissingPDFException\":\n            return new _util.MissingPDFException(reason.message);\n          case \"PasswordException\":\n            return new _util.PasswordException(reason.message, reason.code);\n          case \"UnexpectedResponseException\":\n            return new _util.UnexpectedResponseException(reason.message, reason.status);\n          case \"UnknownErrorException\":\n            return new _util.UnknownErrorException(reason.message, reason.details);\n          default:\n            return new _util.UnknownErrorException(reason.message, reason.toString());\n        }\n      }\n      class MessageHandler {\n        constructor(sourceName, targetName, comObj) {\n          this.sourceName = sourceName;\n          this.targetName = targetName;\n          this.comObj = comObj;\n          this.callbackId = 1;\n          this.streamId = 1;\n          this.streamSinks = Object.create(null);\n          this.streamControllers = Object.create(null);\n          this.callbackCapabilities = Object.create(null);\n          this.actionHandler = Object.create(null);\n          this._onComObjOnMessage = event => {\n            const data = event.data;\n            if (data.targetName !== this.sourceName) {\n              return;\n            }\n            if (data.stream) {\n              this._processStreamMessage(data);\n              return;\n            }\n            if (data.callback) {\n              const callbackId = data.callbackId;\n              const capability = this.callbackCapabilities[callbackId];\n              if (!capability) {\n                throw new Error(`Cannot resolve callback ${callbackId}`);\n              }\n              delete this.callbackCapabilities[callbackId];\n              if (data.callback === CallbackKind.DATA) {\n                capability.resolve(data.data);\n              } else if (data.callback === CallbackKind.ERROR) {\n                capability.reject(wrapReason(data.reason));\n              } else {\n                throw new Error(\"Unexpected callback case\");\n              }\n              return;\n            }\n            const action = this.actionHandler[data.action];\n            if (!action) {\n              throw new Error(`Unknown action from worker: ${data.action}`);\n            }\n            if (data.callbackId) {\n              const cbSourceName = this.sourceName;\n              const cbTargetName = data.sourceName;\n              new Promise(function (resolve) {\n                resolve(action(data.data));\n              }).then(function (result) {\n                comObj.postMessage({\n                  sourceName: cbSourceName,\n                  targetName: cbTargetName,\n                  callback: CallbackKind.DATA,\n                  callbackId: data.callbackId,\n                  data: result\n                });\n              }, function (reason) {\n                comObj.postMessage({\n                  sourceName: cbSourceName,\n                  targetName: cbTargetName,\n                  callback: CallbackKind.ERROR,\n                  callbackId: data.callbackId,\n                  reason: wrapReason(reason)\n                });\n              });\n              return;\n            }\n            if (data.streamId) {\n              this._createStreamSink(data);\n              return;\n            }\n            action(data.data);\n          };\n          comObj.addEventListener(\"message\", this._onComObjOnMessage);\n        }\n        on(actionName, handler) {\n          const ah = this.actionHandler;\n          if (ah[actionName]) {\n            throw new Error(`There is already an actionName called \"${actionName}\"`);\n          }\n          ah[actionName] = handler;\n        }\n        send(actionName, data, transfers) {\n          this.comObj.postMessage({\n            sourceName: this.sourceName,\n            targetName: this.targetName,\n            action: actionName,\n            data\n          }, transfers);\n        }\n        sendWithPromise(actionName, data, transfers) {\n          const callbackId = this.callbackId++;\n          const capability = (0, _util.createPromiseCapability)();\n          this.callbackCapabilities[callbackId] = capability;\n          try {\n            this.comObj.postMessage({\n              sourceName: this.sourceName,\n              targetName: this.targetName,\n              action: actionName,\n              callbackId,\n              data\n            }, transfers);\n          } catch (ex) {\n            capability.reject(ex);\n          }\n          return capability.promise;\n        }\n        sendWithStream(actionName, data, queueingStrategy, transfers) {\n          const streamId = this.streamId++,\n            sourceName = this.sourceName,\n            targetName = this.targetName,\n            comObj = this.comObj;\n          return new ReadableStream({\n            start: controller => {\n              const startCapability = (0, _util.createPromiseCapability)();\n              this.streamControllers[streamId] = {\n                controller,\n                startCall: startCapability,\n                pullCall: null,\n                cancelCall: null,\n                isClosed: false\n              };\n              comObj.postMessage({\n                sourceName,\n                targetName,\n                action: actionName,\n                streamId,\n                data,\n                desiredSize: controller.desiredSize\n              }, transfers);\n              return startCapability.promise;\n            },\n            pull: controller => {\n              const pullCapability = (0, _util.createPromiseCapability)();\n              this.streamControllers[streamId].pullCall = pullCapability;\n              comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.PULL,\n                streamId,\n                desiredSize: controller.desiredSize\n              });\n              return pullCapability.promise;\n            },\n            cancel: reason => {\n              (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n              const cancelCapability = (0, _util.createPromiseCapability)();\n              this.streamControllers[streamId].cancelCall = cancelCapability;\n              this.streamControllers[streamId].isClosed = true;\n              comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.CANCEL,\n                streamId,\n                reason: wrapReason(reason)\n              });\n              return cancelCapability.promise;\n            }\n          }, queueingStrategy);\n        }\n        _createStreamSink(data) {\n          const streamId = data.streamId,\n            sourceName = this.sourceName,\n            targetName = data.sourceName,\n            comObj = this.comObj;\n          const self = this,\n            action = this.actionHandler[data.action];\n          const streamSink = {\n            enqueue(chunk, size = 1, transfers) {\n              if (this.isCancelled) {\n                return;\n              }\n              const lastDesiredSize = this.desiredSize;\n              this.desiredSize -= size;\n              if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                this.sinkCapability = (0, _util.createPromiseCapability)();\n                this.ready = this.sinkCapability.promise;\n              }\n              comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.ENQUEUE,\n                streamId,\n                chunk\n              }, transfers);\n            },\n            close() {\n              if (this.isCancelled) {\n                return;\n              }\n              this.isCancelled = true;\n              comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.CLOSE,\n                streamId\n              });\n              delete self.streamSinks[streamId];\n            },\n            error(reason) {\n              (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n              if (this.isCancelled) {\n                return;\n              }\n              this.isCancelled = true;\n              comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.ERROR,\n                streamId,\n                reason: wrapReason(reason)\n              });\n            },\n            sinkCapability: (0, _util.createPromiseCapability)(),\n            onPull: null,\n            onCancel: null,\n            isCancelled: false,\n            desiredSize: data.desiredSize,\n            ready: null\n          };\n          streamSink.sinkCapability.resolve();\n          streamSink.ready = streamSink.sinkCapability.promise;\n          this.streamSinks[streamId] = streamSink;\n          new Promise(function (resolve) {\n            resolve(action(data.data, streamSink));\n          }).then(function () {\n            comObj.postMessage({\n              sourceName,\n              targetName,\n              stream: StreamKind.START_COMPLETE,\n              streamId,\n              success: true\n            });\n          }, function (reason) {\n            comObj.postMessage({\n              sourceName,\n              targetName,\n              stream: StreamKind.START_COMPLETE,\n              streamId,\n              reason: wrapReason(reason)\n            });\n          });\n        }\n        _processStreamMessage(data) {\n          const streamId = data.streamId,\n            sourceName = this.sourceName,\n            targetName = data.sourceName,\n            comObj = this.comObj;\n          const streamController = this.streamControllers[streamId],\n            streamSink = this.streamSinks[streamId];\n          switch (data.stream) {\n            case StreamKind.START_COMPLETE:\n              if (data.success) {\n                streamController.startCall.resolve();\n              } else {\n                streamController.startCall.reject(wrapReason(data.reason));\n              }\n              break;\n            case StreamKind.PULL_COMPLETE:\n              if (data.success) {\n                streamController.pullCall.resolve();\n              } else {\n                streamController.pullCall.reject(wrapReason(data.reason));\n              }\n              break;\n            case StreamKind.PULL:\n              if (!streamSink) {\n                comObj.postMessage({\n                  sourceName,\n                  targetName,\n                  stream: StreamKind.PULL_COMPLETE,\n                  streamId,\n                  success: true\n                });\n                break;\n              }\n              if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                streamSink.sinkCapability.resolve();\n              }\n              streamSink.desiredSize = data.desiredSize;\n              new Promise(function (resolve) {\n                resolve(streamSink.onPull && streamSink.onPull());\n              }).then(function () {\n                comObj.postMessage({\n                  sourceName,\n                  targetName,\n                  stream: StreamKind.PULL_COMPLETE,\n                  streamId,\n                  success: true\n                });\n              }, function (reason) {\n                comObj.postMessage({\n                  sourceName,\n                  targetName,\n                  stream: StreamKind.PULL_COMPLETE,\n                  streamId,\n                  reason: wrapReason(reason)\n                });\n              });\n              break;\n            case StreamKind.ENQUEUE:\n              (0, _util.assert)(streamController, \"enqueue should have stream controller\");\n              if (streamController.isClosed) {\n                break;\n              }\n              streamController.controller.enqueue(data.chunk);\n              break;\n            case StreamKind.CLOSE:\n              (0, _util.assert)(streamController, \"close should have stream controller\");\n              if (streamController.isClosed) {\n                break;\n              }\n              streamController.isClosed = true;\n              streamController.controller.close();\n              this._deleteStreamController(streamController, streamId);\n              break;\n            case StreamKind.ERROR:\n              (0, _util.assert)(streamController, \"error should have stream controller\");\n              streamController.controller.error(wrapReason(data.reason));\n              this._deleteStreamController(streamController, streamId);\n              break;\n            case StreamKind.CANCEL_COMPLETE:\n              if (data.success) {\n                streamController.cancelCall.resolve();\n              } else {\n                streamController.cancelCall.reject(wrapReason(data.reason));\n              }\n              this._deleteStreamController(streamController, streamId);\n              break;\n            case StreamKind.CANCEL:\n              if (!streamSink) {\n                break;\n              }\n              new Promise(function (resolve) {\n                resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));\n              }).then(function () {\n                comObj.postMessage({\n                  sourceName,\n                  targetName,\n                  stream: StreamKind.CANCEL_COMPLETE,\n                  streamId,\n                  success: true\n                });\n              }, function (reason) {\n                comObj.postMessage({\n                  sourceName,\n                  targetName,\n                  stream: StreamKind.CANCEL_COMPLETE,\n                  streamId,\n                  reason: wrapReason(reason)\n                });\n              });\n              streamSink.sinkCapability.reject(wrapReason(data.reason));\n              streamSink.isCancelled = true;\n              delete this.streamSinks[streamId];\n              break;\n            default:\n              throw new Error(\"Unexpected stream case\");\n          }\n        }\n        async _deleteStreamController(streamController, streamId) {\n          await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);\n          delete this.streamControllers[streamId];\n        }\n        destroy() {\n          this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n        }\n      }\n      exports.MessageHandler = MessageHandler;\n\n      /***/\n    }), (/* 14 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.Metadata = void 0;\n      var _util = __w_pdfjs_require__(2);\n      class Metadata {\n        #metadataMap;\n        #data;\n        constructor({\n          parsedData,\n          rawData\n        }) {\n          this.#metadataMap = parsedData;\n          this.#data = rawData;\n        }\n        getRaw() {\n          return this.#data;\n        }\n        get(name) {\n          return this.#metadataMap.get(name) ?? null;\n        }\n        getAll() {\n          return (0, _util.objectFromMap)(this.#metadataMap);\n        }\n        has(name) {\n          return this.#metadataMap.has(name);\n        }\n      }\n      exports.Metadata = Metadata;\n\n      /***/\n    }), (/* 15 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.OptionalContentConfig = void 0;\n      var _util = __w_pdfjs_require__(2);\n      class OptionalContentGroup {\n        constructor(name, intent) {\n          this.visible = true;\n          this.name = name;\n          this.intent = intent;\n        }\n      }\n      class OptionalContentConfig {\n        constructor(data) {\n          this.name = null;\n          this.creator = null;\n          this._order = null;\n          this._groups = new Map();\n          if (data === null) {\n            return;\n          }\n          this.name = data.name;\n          this.creator = data.creator;\n          this._order = data.order;\n          for (const group of data.groups) {\n            this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n          }\n          if (data.baseState === \"OFF\") {\n            for (const group of this._groups) {\n              group.visible = false;\n            }\n          }\n          for (const on of data.on) {\n            this._groups.get(on).visible = true;\n          }\n          for (const off of data.off) {\n            this._groups.get(off).visible = false;\n          }\n        }\n        _evaluateVisibilityExpression(array) {\n          const length = array.length;\n          if (length < 2) {\n            return true;\n          }\n          const operator = array[0];\n          for (let i = 1; i < length; i++) {\n            const element = array[i];\n            let state;\n            if (Array.isArray(element)) {\n              state = this._evaluateVisibilityExpression(element);\n            } else if (this._groups.has(element)) {\n              state = this._groups.get(element).visible;\n            } else {\n              (0, _util.warn)(`Optional content group not found: ${element}`);\n              return true;\n            }\n            switch (operator) {\n              case \"And\":\n                if (!state) {\n                  return false;\n                }\n                break;\n              case \"Or\":\n                if (state) {\n                  return true;\n                }\n                break;\n              case \"Not\":\n                return !state;\n              default:\n                return true;\n            }\n          }\n          return operator === \"And\";\n        }\n        isVisible(group) {\n          if (this._groups.size === 0) {\n            return true;\n          }\n          if (!group) {\n            (0, _util.warn)(\"Optional content group not defined.\");\n            return true;\n          }\n          if (group.type === \"OCG\") {\n            if (!this._groups.has(group.id)) {\n              (0, _util.warn)(`Optional content group not found: ${group.id}`);\n              return true;\n            }\n            return this._groups.get(group.id).visible;\n          } else if (group.type === \"OCMD\") {\n            if (group.expression) {\n              return this._evaluateVisibilityExpression(group.expression);\n            }\n            if (!group.policy || group.policy === \"AnyOn\") {\n              for (const id of group.ids) {\n                if (!this._groups.has(id)) {\n                  (0, _util.warn)(`Optional content group not found: ${id}`);\n                  return true;\n                }\n                if (this._groups.get(id).visible) {\n                  return true;\n                }\n              }\n              return false;\n            } else if (group.policy === \"AllOn\") {\n              for (const id of group.ids) {\n                if (!this._groups.has(id)) {\n                  (0, _util.warn)(`Optional content group not found: ${id}`);\n                  return true;\n                }\n                if (!this._groups.get(id).visible) {\n                  return false;\n                }\n              }\n              return true;\n            } else if (group.policy === \"AnyOff\") {\n              for (const id of group.ids) {\n                if (!this._groups.has(id)) {\n                  (0, _util.warn)(`Optional content group not found: ${id}`);\n                  return true;\n                }\n                if (!this._groups.get(id).visible) {\n                  return true;\n                }\n              }\n              return false;\n            } else if (group.policy === \"AllOff\") {\n              for (const id of group.ids) {\n                if (!this._groups.has(id)) {\n                  (0, _util.warn)(`Optional content group not found: ${id}`);\n                  return true;\n                }\n                if (this._groups.get(id).visible) {\n                  return false;\n                }\n              }\n              return true;\n            }\n            (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\n            return true;\n          }\n          (0, _util.warn)(`Unknown group type ${group.type}.`);\n          return true;\n        }\n        setVisibility(id, visible = true) {\n          if (!this._groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return;\n          }\n          this._groups.get(id).visible = !!visible;\n        }\n        getOrder() {\n          if (!this._groups.size) {\n            return null;\n          }\n          if (this._order) {\n            return this._order.slice();\n          }\n          return Array.from(this._groups.keys());\n        }\n        getGroups() {\n          return this._groups.size > 0 ? (0, _util.objectFromMap)(this._groups) : null;\n        }\n        getGroup(id) {\n          return this._groups.get(id) || null;\n        }\n      }\n      exports.OptionalContentConfig = OptionalContentConfig;\n\n      /***/\n    }), (/* 16 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.PDFDataTransportStream = void 0;\n      var _util = __w_pdfjs_require__(2);\n      var _display_utils = __w_pdfjs_require__(1);\n      class PDFDataTransportStream {\n        constructor(params, pdfDataRangeTransport) {\n          (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n          this._queuedChunks = [];\n          this._progressiveDone = params.progressiveDone || false;\n          this._contentDispositionFilename = params.contentDispositionFilename || null;\n          const initialData = params.initialData;\n          if (initialData?.length > 0) {\n            const buffer = new Uint8Array(initialData).buffer;\n            this._queuedChunks.push(buffer);\n          }\n          this._pdfDataRangeTransport = pdfDataRangeTransport;\n          this._isStreamingSupported = !params.disableStream;\n          this._isRangeSupported = !params.disableRange;\n          this._contentLength = params.length;\n          this._fullRequestReader = null;\n          this._rangeReaders = [];\n          this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n            this._onReceiveData({\n              begin,\n              chunk\n            });\n          });\n          this._pdfDataRangeTransport.addProgressListener((loaded, total) => {\n            this._onProgress({\n              loaded,\n              total\n            });\n          });\n          this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n            this._onReceiveData({\n              chunk\n            });\n          });\n          this._pdfDataRangeTransport.addProgressiveDoneListener(() => {\n            this._onProgressiveDone();\n          });\n          this._pdfDataRangeTransport.transportReady();\n        }\n        _onReceiveData(args) {\n          const buffer = new Uint8Array(args.chunk).buffer;\n          if (args.begin === undefined) {\n            if (this._fullRequestReader) {\n              this._fullRequestReader._enqueue(buffer);\n            } else {\n              this._queuedChunks.push(buffer);\n            }\n          } else {\n            const found = this._rangeReaders.some(function (rangeReader) {\n              if (rangeReader._begin !== args.begin) {\n                return false;\n              }\n              rangeReader._enqueue(buffer);\n              return true;\n            });\n            (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n          }\n        }\n        get _progressiveDataLength() {\n          return this._fullRequestReader?._loaded ?? 0;\n        }\n        _onProgress(evt) {\n          if (evt.total === undefined) {\n            const firstReader = this._rangeReaders[0];\n            if (firstReader?.onProgress) {\n              firstReader.onProgress({\n                loaded: evt.loaded\n              });\n            }\n          } else {\n            const fullReader = this._fullRequestReader;\n            if (fullReader?.onProgress) {\n              fullReader.onProgress({\n                loaded: evt.loaded,\n                total: evt.total\n              });\n            }\n          }\n        }\n        _onProgressiveDone() {\n          if (this._fullRequestReader) {\n            this._fullRequestReader.progressiveDone();\n          }\n          this._progressiveDone = true;\n        }\n        _removeRangeReader(reader) {\n          const i = this._rangeReaders.indexOf(reader);\n          if (i >= 0) {\n            this._rangeReaders.splice(i, 1);\n          }\n        }\n        getFullReader() {\n          (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n          const queuedChunks = this._queuedChunks;\n          this._queuedChunks = null;\n          return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n        }\n        getRangeReader(begin, end) {\n          if (end <= this._progressiveDataLength) {\n            return null;\n          }\n          const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n          this._pdfDataRangeTransport.requestDataRange(begin, end);\n          this._rangeReaders.push(reader);\n          return reader;\n        }\n        cancelAllRequests(reason) {\n          if (this._fullRequestReader) {\n            this._fullRequestReader.cancel(reason);\n          }\n          for (const reader of this._rangeReaders.slice(0)) {\n            reader.cancel(reason);\n          }\n          this._pdfDataRangeTransport.abort();\n        }\n      }\n      exports.PDFDataTransportStream = PDFDataTransportStream;\n      class PDFDataTransportStreamReader {\n        constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {\n          this._stream = stream;\n          this._done = progressiveDone || false;\n          this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;\n          this._queuedChunks = queuedChunks || [];\n          this._loaded = 0;\n          for (const chunk of this._queuedChunks) {\n            this._loaded += chunk.byteLength;\n          }\n          this._requests = [];\n          this._headersReady = Promise.resolve();\n          stream._fullRequestReader = this;\n          this.onProgress = null;\n        }\n        _enqueue(chunk) {\n          if (this._done) {\n            return;\n          }\n          if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n              value: chunk,\n              done: false\n            });\n          } else {\n            this._queuedChunks.push(chunk);\n          }\n          this._loaded += chunk.byteLength;\n        }\n        get headersReady() {\n          return this._headersReady;\n        }\n        get filename() {\n          return this._filename;\n        }\n        get isRangeSupported() {\n          return this._stream._isRangeSupported;\n        }\n        get isStreamingSupported() {\n          return this._stream._isStreamingSupported;\n        }\n        get contentLength() {\n          return this._stream._contentLength;\n        }\n        async read() {\n          if (this._queuedChunks.length > 0) {\n            const chunk = this._queuedChunks.shift();\n            return {\n              value: chunk,\n              done: false\n            };\n          }\n          if (this._done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          const requestCapability = (0, _util.createPromiseCapability)();\n          this._requests.push(requestCapability);\n          return requestCapability.promise;\n        }\n        cancel(reason) {\n          this._done = true;\n          for (const requestCapability of this._requests) {\n            requestCapability.resolve({\n              value: undefined,\n              done: true\n            });\n          }\n          this._requests.length = 0;\n        }\n        progressiveDone() {\n          if (this._done) {\n            return;\n          }\n          this._done = true;\n        }\n      }\n      class PDFDataTransportStreamRangeReader {\n        constructor(stream, begin, end) {\n          this._stream = stream;\n          this._begin = begin;\n          this._end = end;\n          this._queuedChunk = null;\n          this._requests = [];\n          this._done = false;\n          this.onProgress = null;\n        }\n        _enqueue(chunk) {\n          if (this._done) {\n            return;\n          }\n          if (this._requests.length === 0) {\n            this._queuedChunk = chunk;\n          } else {\n            const requestsCapability = this._requests.shift();\n            requestsCapability.resolve({\n              value: chunk,\n              done: false\n            });\n            for (const requestCapability of this._requests) {\n              requestCapability.resolve({\n                value: undefined,\n                done: true\n              });\n            }\n            this._requests.length = 0;\n          }\n          this._done = true;\n          this._stream._removeRangeReader(this);\n        }\n        get isStreamingSupported() {\n          return false;\n        }\n        async read() {\n          if (this._queuedChunk) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n              value: chunk,\n              done: false\n            };\n          }\n          if (this._done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          const requestCapability = (0, _util.createPromiseCapability)();\n          this._requests.push(requestCapability);\n          return requestCapability.promise;\n        }\n        cancel(reason) {\n          this._done = true;\n          for (const requestCapability of this._requests) {\n            requestCapability.resolve({\n              value: undefined,\n              done: true\n            });\n          }\n          this._requests.length = 0;\n          this._stream._removeRangeReader(this);\n        }\n      }\n\n      /***/\n    }), (/* 17 */\n    /***/(__unused_webpack_module, exports) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.XfaText = void 0;\n      class XfaText {\n        static textContent(xfa) {\n          const items = [];\n          const output = {\n            items,\n            styles: Object.create(null)\n          };\n          function walk(node) {\n            if (!node) {\n              return;\n            }\n            let str = null;\n            const name = node.name;\n            if (name === \"#text\") {\n              str = node.value;\n            } else if (!XfaText.shouldBuildText(name)) {\n              return;\n            } else if (node?.attributes?.textContent) {\n              str = node.attributes.textContent;\n            } else if (node.value) {\n              str = node.value;\n            }\n            if (str !== null) {\n              items.push({\n                str\n              });\n            }\n            if (!node.children) {\n              return;\n            }\n            for (const child of node.children) {\n              walk(child);\n            }\n          }\n          walk(xfa);\n          return output;\n        }\n        static shouldBuildText(name) {\n          return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n        }\n      }\n      exports.XfaText = XfaText;\n\n      /***/\n    }), (/* 18 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.AnnotationLayer = void 0;\n      var _util = __w_pdfjs_require__(2);\n      var _display_utils = __w_pdfjs_require__(1);\n      var _annotation_storage = __w_pdfjs_require__(9);\n      var _scripting_utils = __w_pdfjs_require__(19);\n      var _xfa_layer = __w_pdfjs_require__(20);\n      const DEFAULT_TAB_INDEX = 1000;\n      const GetElementsByNameSet = new WeakSet();\n      class AnnotationElementFactory {\n        static create(parameters) {\n          const subtype = parameters.data.annotationType;\n          switch (subtype) {\n            case _util.AnnotationType.LINK:\n              return new LinkAnnotationElement(parameters);\n            case _util.AnnotationType.TEXT:\n              return new TextAnnotationElement(parameters);\n            case _util.AnnotationType.WIDGET:\n              const fieldType = parameters.data.fieldType;\n              switch (fieldType) {\n                case \"Tx\":\n                  return new TextWidgetAnnotationElement(parameters);\n                case \"Btn\":\n                  if (parameters.data.radioButton) {\n                    return new RadioButtonWidgetAnnotationElement(parameters);\n                  } else if (parameters.data.checkBox) {\n                    return new CheckboxWidgetAnnotationElement(parameters);\n                  }\n                  return new PushButtonWidgetAnnotationElement(parameters);\n                case \"Ch\":\n                  return new ChoiceWidgetAnnotationElement(parameters);\n              }\n              return new WidgetAnnotationElement(parameters);\n            case _util.AnnotationType.POPUP:\n              return new PopupAnnotationElement(parameters);\n            case _util.AnnotationType.FREETEXT:\n              return new FreeTextAnnotationElement(parameters);\n            case _util.AnnotationType.LINE:\n              return new LineAnnotationElement(parameters);\n            case _util.AnnotationType.SQUARE:\n              return new SquareAnnotationElement(parameters);\n            case _util.AnnotationType.CIRCLE:\n              return new CircleAnnotationElement(parameters);\n            case _util.AnnotationType.POLYLINE:\n              return new PolylineAnnotationElement(parameters);\n            case _util.AnnotationType.CARET:\n              return new CaretAnnotationElement(parameters);\n            case _util.AnnotationType.INK:\n              return new InkAnnotationElement(parameters);\n            case _util.AnnotationType.POLYGON:\n              return new PolygonAnnotationElement(parameters);\n            case _util.AnnotationType.HIGHLIGHT:\n              return new HighlightAnnotationElement(parameters);\n            case _util.AnnotationType.UNDERLINE:\n              return new UnderlineAnnotationElement(parameters);\n            case _util.AnnotationType.SQUIGGLY:\n              return new SquigglyAnnotationElement(parameters);\n            case _util.AnnotationType.STRIKEOUT:\n              return new StrikeOutAnnotationElement(parameters);\n            case _util.AnnotationType.STAMP:\n              return new StampAnnotationElement(parameters);\n            case _util.AnnotationType.FILEATTACHMENT:\n              return new FileAttachmentAnnotationElement(parameters);\n            default:\n              return new AnnotationElement(parameters);\n          }\n        }\n      }\n      class AnnotationElement {\n        constructor(parameters, {\n          isRenderable = false,\n          ignoreBorder = false,\n          createQuadrilaterals = false\n        } = {}) {\n          this.isRenderable = isRenderable;\n          this.data = parameters.data;\n          this.layer = parameters.layer;\n          this.page = parameters.page;\n          this.viewport = parameters.viewport;\n          this.linkService = parameters.linkService;\n          this.downloadManager = parameters.downloadManager;\n          this.imageResourcesPath = parameters.imageResourcesPath;\n          this.renderForms = parameters.renderForms;\n          this.svgFactory = parameters.svgFactory;\n          this.annotationStorage = parameters.annotationStorage;\n          this.enableScripting = parameters.enableScripting;\n          this.hasJSActions = parameters.hasJSActions;\n          this._fieldObjects = parameters.fieldObjects;\n          this._mouseState = parameters.mouseState;\n          if (isRenderable) {\n            this.container = this._createContainer(ignoreBorder);\n          }\n          if (createQuadrilaterals) {\n            this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);\n          }\n        }\n        _createContainer(ignoreBorder = false) {\n          const data = this.data,\n            page = this.page,\n            viewport = this.viewport;\n          const container = document.createElement(\"section\");\n          let width = data.rect[2] - data.rect[0];\n          let height = data.rect[3] - data.rect[1];\n          container.setAttribute(\"data-annotation-id\", data.id);\n          const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n          if (data.hasOwnCanvas) {\n            const transform = viewport.transform.slice();\n            const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale(transform);\n            width = Math.ceil(width * scaleX);\n            height = Math.ceil(height * scaleY);\n            rect[0] *= scaleX;\n            rect[1] *= scaleY;\n            for (let i = 0; i < 4; i++) {\n              transform[i] = Math.sign(transform[i]);\n            }\n            container.style.transform = `matrix(${transform.join(\",\")})`;\n          } else {\n            container.style.transform = `matrix(${viewport.transform.join(\",\")})`;\n          }\n          container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;\n          if (!ignoreBorder && data.borderStyle.width > 0) {\n            container.style.borderWidth = `${data.borderStyle.width}px`;\n            if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {\n              width -= 2 * data.borderStyle.width;\n              height -= 2 * data.borderStyle.width;\n            }\n            const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n            const verticalRadius = data.borderStyle.verticalCornerRadius;\n            if (horizontalRadius > 0 || verticalRadius > 0) {\n              const radius = `${horizontalRadius}px / ${verticalRadius}px`;\n              container.style.borderRadius = radius;\n            }\n            switch (data.borderStyle.style) {\n              case _util.AnnotationBorderStyleType.SOLID:\n                container.style.borderStyle = \"solid\";\n                break;\n              case _util.AnnotationBorderStyleType.DASHED:\n                container.style.borderStyle = \"dashed\";\n                break;\n              case _util.AnnotationBorderStyleType.BEVELED:\n                (0, _util.warn)(\"Unimplemented border style: beveled\");\n                break;\n              case _util.AnnotationBorderStyleType.INSET:\n                (0, _util.warn)(\"Unimplemented border style: inset\");\n                break;\n              case _util.AnnotationBorderStyleType.UNDERLINE:\n                container.style.borderBottomStyle = \"solid\";\n                break;\n              default:\n                break;\n            }\n            const borderColor = data.borderColor || data.color || null;\n            if (borderColor) {\n              container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);\n            } else {\n              container.style.borderWidth = 0;\n            }\n          }\n          container.style.left = `${rect[0]}px`;\n          container.style.top = `${rect[1]}px`;\n          if (data.hasOwnCanvas) {\n            container.style.width = container.style.height = \"auto\";\n          } else {\n            container.style.width = `${width}px`;\n            container.style.height = `${height}px`;\n          }\n          return container;\n        }\n        _createQuadrilaterals(ignoreBorder = false) {\n          if (!this.data.quadPoints) {\n            return null;\n          }\n          const quadrilaterals = [];\n          const savedRect = this.data.rect;\n          for (const quadPoint of this.data.quadPoints) {\n            this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];\n            quadrilaterals.push(this._createContainer(ignoreBorder));\n          }\n          this.data.rect = savedRect;\n          return quadrilaterals;\n        }\n        _createPopup(trigger, data) {\n          let container = this.container;\n          if (this.quadrilaterals) {\n            trigger = trigger || this.quadrilaterals;\n            container = this.quadrilaterals[0];\n          }\n          if (!trigger) {\n            trigger = document.createElement(\"div\");\n            trigger.style.height = container.style.height;\n            trigger.style.width = container.style.width;\n            container.appendChild(trigger);\n          }\n          const popupElement = new PopupElement({\n            container,\n            trigger,\n            color: data.color,\n            titleObj: data.titleObj,\n            modificationDate: data.modificationDate,\n            contentsObj: data.contentsObj,\n            richText: data.richText,\n            hideWrapper: true\n          });\n          const popup = popupElement.render();\n          popup.style.left = container.style.width;\n          container.appendChild(popup);\n        }\n        _renderQuadrilaterals(className) {\n          for (const quadrilateral of this.quadrilaterals) {\n            quadrilateral.className = className;\n          }\n          return this.quadrilaterals;\n        }\n        render() {\n          (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n        }\n        _getElementsByName(name, skipId = null) {\n          const fields = [];\n          if (this._fieldObjects) {\n            const fieldObj = this._fieldObjects[name];\n            if (fieldObj) {\n              for (const {\n                page,\n                id,\n                exportValues\n              } of fieldObj) {\n                if (page === -1) {\n                  continue;\n                }\n                if (id === skipId) {\n                  continue;\n                }\n                const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                const domElement = document.getElementById(id);\n                if (domElement && !GetElementsByNameSet.has(domElement)) {\n                  (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);\n                  continue;\n                }\n                fields.push({\n                  id,\n                  exportValue,\n                  domElement\n                });\n              }\n            }\n            return fields;\n          }\n          for (const domElement of document.getElementsByName(name)) {\n            const {\n              id,\n              exportValue\n            } = domElement;\n            if (id === skipId) {\n              continue;\n            }\n            if (!GetElementsByNameSet.has(domElement)) {\n              continue;\n            }\n            fields.push({\n              id,\n              exportValue,\n              domElement\n            });\n          }\n          return fields;\n        }\n        static get platform() {\n          const platform = typeof navigator !== \"undefined\" ? navigator.platform : \"\";\n          return (0, _util.shadow)(this, \"platform\", {\n            isWin: platform.includes(\"Win\"),\n            isMac: platform.includes(\"Mac\")\n          });\n        }\n      }\n      class LinkAnnotationElement extends AnnotationElement {\n        constructor(parameters, options = null) {\n          const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.resetForm || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions[\"Mouse Up\"] || parameters.data.actions[\"Mouse Down\"]));\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: !!options?.ignoreBorder,\n            createQuadrilaterals: true\n          });\n        }\n        render() {\n          const {\n            data,\n            linkService\n          } = this;\n          const link = document.createElement(\"a\");\n          if (data.url) {\n            if (!linkService.addLinkAttributes) {\n              (0, _util.warn)(\"LinkAnnotationElement.render - missing `addLinkAttributes`-method on the `linkService`-instance.\");\n            }\n            linkService.addLinkAttributes?.(link, data.url, data.newWindow);\n          } else if (data.action) {\n            this._bindNamedAction(link, data.action);\n          } else if (data.dest) {\n            this._bindLink(link, data.dest);\n          } else {\n            let hasClickAction = false;\n            if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n              hasClickAction = true;\n              this._bindJSAction(link, data);\n            }\n            if (data.resetForm) {\n              this._bindResetFormAction(link, data.resetForm);\n            } else if (!hasClickAction) {\n              this._bindLink(link, \"\");\n            }\n          }\n          if (this.quadrilaterals) {\n            return this._renderQuadrilaterals(\"linkAnnotation\").map((quadrilateral, index) => {\n              const linkElement = index === 0 ? link : link.cloneNode();\n              quadrilateral.appendChild(linkElement);\n              return quadrilateral;\n            });\n          }\n          this.container.className = \"linkAnnotation\";\n          this.container.appendChild(link);\n          return this.container;\n        }\n        _bindLink(link, destination) {\n          link.href = this.linkService.getDestinationHash(destination);\n          link.onclick = () => {\n            if (destination) {\n              this.linkService.goToDestination(destination);\n            }\n            return false;\n          };\n          if (destination || destination === \"\") {\n            link.className = \"internalLink\";\n          }\n        }\n        _bindNamedAction(link, action) {\n          link.href = this.linkService.getAnchorUrl(\"\");\n          link.onclick = () => {\n            this.linkService.executeNamedAction(action);\n            return false;\n          };\n          link.className = \"internalLink\";\n        }\n        _bindJSAction(link, data) {\n          link.href = this.linkService.getAnchorUrl(\"\");\n          const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n          for (const name of Object.keys(data.actions)) {\n            const jsName = map.get(name);\n            if (!jsName) {\n              continue;\n            }\n            link[jsName] = () => {\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id: data.id,\n                  name\n                }\n              });\n              return false;\n            };\n          }\n          if (!link.onclick) {\n            link.onclick = () => false;\n          }\n          link.className = \"internalLink\";\n        }\n        _bindResetFormAction(link, resetForm) {\n          const otherClickAction = link.onclick;\n          if (!otherClickAction) {\n            link.href = this.linkService.getAnchorUrl(\"\");\n          }\n          link.className = \"internalLink\";\n          if (!this._fieldObjects) {\n            (0, _util.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n            if (!otherClickAction) {\n              link.onclick = () => false;\n            }\n            return;\n          }\n          link.onclick = () => {\n            if (otherClickAction) {\n              otherClickAction();\n            }\n            const {\n              fields: resetFormFields,\n              refs: resetFormRefs,\n              include\n            } = resetForm;\n            const allFields = [];\n            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n              const fieldIds = new Set(resetFormRefs);\n              for (const fieldName of resetFormFields) {\n                const fields = this._fieldObjects[fieldName] || [];\n                for (const {\n                  id\n                } of fields) {\n                  fieldIds.add(id);\n                }\n              }\n              for (const fields of Object.values(this._fieldObjects)) {\n                for (const field of fields) {\n                  if (fieldIds.has(field.id) === include) {\n                    allFields.push(field);\n                  }\n                }\n              }\n            } else {\n              for (const fields of Object.values(this._fieldObjects)) {\n                allFields.push(...fields);\n              }\n            }\n            const storage = this.annotationStorage;\n            const allIds = [];\n            for (const field of allFields) {\n              const {\n                id\n              } = field;\n              allIds.push(id);\n              switch (field.type) {\n                case \"text\":\n                  {\n                    const value = field.defaultValue || \"\";\n                    storage.setValue(id, {\n                      value,\n                      valueAsString: value\n                    });\n                    break;\n                  }\n                case \"checkbox\":\n                case \"radiobutton\":\n                  {\n                    const value = field.defaultValue === field.exportValues;\n                    storage.setValue(id, {\n                      value\n                    });\n                    break;\n                  }\n                case \"combobox\":\n                case \"listbox\":\n                  {\n                    const value = field.defaultValue || \"\";\n                    storage.setValue(id, {\n                      value\n                    });\n                    break;\n                  }\n                default:\n                  continue;\n              }\n              const domElement = document.getElementById(id);\n              if (!domElement || !GetElementsByNameSet.has(domElement)) {\n                continue;\n              }\n              domElement.dispatchEvent(new Event(\"resetform\"));\n            }\n            if (this.enableScripting) {\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id: \"app\",\n                  ids: allIds,\n                  name: \"ResetForm\"\n                }\n              });\n            }\n            return false;\n          };\n        }\n      }\n      class TextAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable\n          });\n        }\n        render() {\n          this.container.className = \"textAnnotation\";\n          const image = document.createElement(\"img\");\n          image.style.height = this.container.style.height;\n          image.style.width = this.container.style.width;\n          image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n          image.alt = \"[{{type}} Annotation]\";\n          image.dataset.l10nId = \"text_annotation_type\";\n          image.dataset.l10nArgs = JSON.stringify({\n            type: this.data.name\n          });\n          if (!this.data.hasPopup) {\n            this._createPopup(image, this.data);\n          }\n          this.container.appendChild(image);\n          return this.container;\n        }\n      }\n      class WidgetAnnotationElement extends AnnotationElement {\n        render() {\n          if (this.data.alternativeText) {\n            this.container.title = this.data.alternativeText;\n          }\n          return this.container;\n        }\n        _getKeyModifier(event) {\n          const {\n            isWin,\n            isMac\n          } = AnnotationElement.platform;\n          return isWin && event.ctrlKey || isMac && event.metaKey;\n        }\n        _setEventListener(element, baseName, eventName, valueGetter) {\n          if (baseName.includes(\"mouse\")) {\n            element.addEventListener(baseName, event => {\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id: this.data.id,\n                  name: eventName,\n                  value: valueGetter(event),\n                  shift: event.shiftKey,\n                  modifier: this._getKeyModifier(event)\n                }\n              });\n            });\n          } else {\n            element.addEventListener(baseName, event => {\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id: this.data.id,\n                  name: eventName,\n                  value: event.target.checked\n                }\n              });\n            });\n          }\n        }\n        _setEventListeners(element, names, getter) {\n          for (const [baseName, eventName] of names) {\n            if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n              this._setEventListener(element, baseName, eventName, getter);\n            }\n          }\n        }\n        _setBackgroundColor(element) {\n          const color = this.data.backgroundColor || null;\n          element.style.backgroundColor = color === null ? \"transparent\" : _util.Util.makeHexColor(color[0], color[1], color[2]);\n        }\n        _dispatchEventFromSandbox(actions, jsEvent) {\n          const setColor = (jsName, styleName, event) => {\n            const color = event.detail[jsName];\n            event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));\n          };\n          const commonActions = {\n            display: event => {\n              const hidden = event.detail.display % 2 === 1;\n              event.target.style.visibility = hidden ? \"hidden\" : \"visible\";\n              this.annotationStorage.setValue(this.data.id, {\n                hidden,\n                print: event.detail.display === 0 || event.detail.display === 3\n              });\n            },\n            print: event => {\n              this.annotationStorage.setValue(this.data.id, {\n                print: event.detail.print\n              });\n            },\n            hidden: event => {\n              event.target.style.visibility = event.detail.hidden ? \"hidden\" : \"visible\";\n              this.annotationStorage.setValue(this.data.id, {\n                hidden: event.detail.hidden\n              });\n            },\n            focus: event => {\n              setTimeout(() => event.target.focus({\n                preventScroll: false\n              }), 0);\n            },\n            userName: event => {\n              event.target.title = event.detail.userName;\n            },\n            readonly: event => {\n              if (event.detail.readonly) {\n                event.target.setAttribute(\"readonly\", \"\");\n              } else {\n                event.target.removeAttribute(\"readonly\");\n              }\n            },\n            required: event => {\n              if (event.detail.required) {\n                event.target.setAttribute(\"required\", \"\");\n              } else {\n                event.target.removeAttribute(\"required\");\n              }\n            },\n            bgColor: event => {\n              setColor(\"bgColor\", \"backgroundColor\", event);\n            },\n            fillColor: event => {\n              setColor(\"fillColor\", \"backgroundColor\", event);\n            },\n            fgColor: event => {\n              setColor(\"fgColor\", \"color\", event);\n            },\n            textColor: event => {\n              setColor(\"textColor\", \"color\", event);\n            },\n            borderColor: event => {\n              setColor(\"borderColor\", \"borderColor\", event);\n            },\n            strokeColor: event => {\n              setColor(\"strokeColor\", \"borderColor\", event);\n            }\n          };\n          for (const name of Object.keys(jsEvent.detail)) {\n            const action = actions[name] || commonActions[name];\n            if (action) {\n              action(jsEvent);\n            }\n          }\n        }\n      }\n      class TextWidgetAnnotationElement extends WidgetAnnotationElement {\n        constructor(parameters) {\n          const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n          super(parameters, {\n            isRenderable\n          });\n        }\n        setPropertyOnSiblings(base, key, value, keyInStorage) {\n          const storage = this.annotationStorage;\n          for (const element of this._getElementsByName(base.name, base.id)) {\n            if (element.domElement) {\n              element.domElement[key] = value;\n            }\n            storage.setValue(element.id, {\n              [keyInStorage]: value\n            });\n          }\n        }\n        render() {\n          const storage = this.annotationStorage;\n          const id = this.data.id;\n          this.container.className = \"textWidgetAnnotation\";\n          let element = null;\n          if (this.renderForms) {\n            const storedData = storage.getValue(id, {\n              value: this.data.fieldValue,\n              valueAsString: this.data.fieldValue\n            });\n            const textContent = storedData.valueAsString || storedData.value || \"\";\n            const elementData = {\n              userValue: null,\n              formattedValue: null,\n              beforeInputSelectionRange: null,\n              beforeInputValue: null\n            };\n            if (this.data.multiLine) {\n              element = document.createElement(\"textarea\");\n              element.textContent = textContent;\n            } else {\n              element = document.createElement(\"input\");\n              element.type = \"text\";\n              element.setAttribute(\"value\", textContent);\n            }\n            GetElementsByNameSet.add(element);\n            element.disabled = this.data.readOnly;\n            element.name = this.data.fieldName;\n            element.tabIndex = DEFAULT_TAB_INDEX;\n            elementData.userValue = textContent;\n            element.setAttribute(\"id\", id);\n            element.addEventListener(\"input\", event => {\n              storage.setValue(id, {\n                value: event.target.value\n              });\n              this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n            });\n            element.addEventListener(\"resetform\", event => {\n              const defaultValue = this.data.defaultFieldValue || \"\";\n              element.value = elementData.userValue = defaultValue;\n              delete elementData.formattedValue;\n            });\n            let blurListener = event => {\n              if (elementData.formattedValue) {\n                event.target.value = elementData.formattedValue;\n              }\n              event.target.scrollLeft = 0;\n              elementData.beforeInputSelectionRange = null;\n            };\n            if (this.enableScripting && this.hasJSActions) {\n              element.addEventListener(\"focus\", event => {\n                if (elementData.userValue) {\n                  event.target.value = elementData.userValue;\n                }\n              });\n              element.addEventListener(\"updatefromsandbox\", jsEvent => {\n                const actions = {\n                  value(event) {\n                    elementData.userValue = event.detail.value || \"\";\n                    storage.setValue(id, {\n                      value: elementData.userValue.toString()\n                    });\n                    if (!elementData.formattedValue) {\n                      event.target.value = elementData.userValue;\n                    }\n                  },\n                  valueAsString(event) {\n                    elementData.formattedValue = event.detail.valueAsString || \"\";\n                    if (event.target !== document.activeElement) {\n                      event.target.value = elementData.formattedValue;\n                    }\n                    storage.setValue(id, {\n                      formattedValue: elementData.formattedValue\n                    });\n                  },\n                  selRange(event) {\n                    const [selStart, selEnd] = event.detail.selRange;\n                    if (selStart >= 0 && selEnd < event.target.value.length) {\n                      event.target.setSelectionRange(selStart, selEnd);\n                    }\n                  }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n              });\n              element.addEventListener(\"keydown\", event => {\n                elementData.beforeInputValue = event.target.value;\n                let commitKey = -1;\n                if (event.key === \"Escape\") {\n                  commitKey = 0;\n                } else if (event.key === \"Enter\") {\n                  commitKey = 2;\n                } else if (event.key === \"Tab\") {\n                  commitKey = 3;\n                }\n                if (commitKey === -1) {\n                  return;\n                }\n                elementData.userValue = event.target.value;\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                  source: this,\n                  detail: {\n                    id,\n                    name: \"Keystroke\",\n                    value: event.target.value,\n                    willCommit: true,\n                    commitKey,\n                    selStart: event.target.selectionStart,\n                    selEnd: event.target.selectionEnd\n                  }\n                });\n              });\n              const _blurListener = blurListener;\n              blurListener = null;\n              element.addEventListener(\"blur\", event => {\n                if (this._mouseState.isDown) {\n                  elementData.userValue = event.target.value;\n                  this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                      id,\n                      name: \"Keystroke\",\n                      value: event.target.value,\n                      willCommit: true,\n                      commitKey: 1,\n                      selStart: event.target.selectionStart,\n                      selEnd: event.target.selectionEnd\n                    }\n                  });\n                }\n                _blurListener(event);\n              });\n              element.addEventListener(\"mousedown\", event => {\n                elementData.beforeInputValue = event.target.value;\n                elementData.beforeInputSelectionRange = null;\n              });\n              element.addEventListener(\"keyup\", event => {\n                if (event.target.selectionStart === event.target.selectionEnd) {\n                  elementData.beforeInputSelectionRange = null;\n                }\n              });\n              element.addEventListener(\"select\", event => {\n                elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];\n              });\n              if (this.data.actions?.Keystroke) {\n                element.addEventListener(\"input\", event => {\n                  let selStart = -1;\n                  let selEnd = -1;\n                  if (elementData.beforeInputSelectionRange) {\n                    [selStart, selEnd] = elementData.beforeInputSelectionRange;\n                  }\n                  this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                      id,\n                      name: \"Keystroke\",\n                      value: elementData.beforeInputValue,\n                      change: event.data,\n                      willCommit: false,\n                      selStart,\n                      selEnd\n                    }\n                  });\n                });\n              }\n              this._setEventListeners(element, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\n            }\n            if (blurListener) {\n              element.addEventListener(\"blur\", blurListener);\n            }\n            if (this.data.maxLen !== null) {\n              element.maxLength = this.data.maxLen;\n            }\n            if (this.data.comb) {\n              const fieldWidth = this.data.rect[2] - this.data.rect[0];\n              const combWidth = fieldWidth / this.data.maxLen;\n              element.classList.add(\"comb\");\n              element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;\n            }\n          } else {\n            element = document.createElement(\"div\");\n            element.textContent = this.data.fieldValue;\n            element.style.verticalAlign = \"middle\";\n            element.style.display = \"table-cell\";\n          }\n          this._setTextStyle(element);\n          this._setBackgroundColor(element);\n          this.container.appendChild(element);\n          return this.container;\n        }\n        _setTextStyle(element) {\n          const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n          const {\n            fontSize,\n            fontColor\n          } = this.data.defaultAppearanceData;\n          const style = element.style;\n          if (fontSize) {\n            style.fontSize = `${fontSize}px`;\n          }\n          style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n          if (this.data.textAlignment !== null) {\n            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n          }\n        }\n      }\n      class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n        constructor(parameters) {\n          super(parameters, {\n            isRenderable: parameters.renderForms\n          });\n        }\n        render() {\n          const storage = this.annotationStorage;\n          const data = this.data;\n          const id = data.id;\n          let value = storage.getValue(id, {\n            value: data.exportValue === data.fieldValue\n          }).value;\n          if (typeof value === \"string\") {\n            value = value !== \"Off\";\n            storage.setValue(id, {\n              value\n            });\n          }\n          this.container.className = \"buttonWidgetAnnotation checkBox\";\n          const element = document.createElement(\"input\");\n          GetElementsByNameSet.add(element);\n          element.disabled = data.readOnly;\n          element.type = \"checkbox\";\n          element.name = data.fieldName;\n          if (value) {\n            element.setAttribute(\"checked\", true);\n          }\n          element.setAttribute(\"id\", id);\n          element.setAttribute(\"exportValue\", data.exportValue);\n          element.tabIndex = DEFAULT_TAB_INDEX;\n          element.addEventListener(\"change\", event => {\n            const {\n              name,\n              checked\n            } = event.target;\n            for (const checkbox of this._getElementsByName(name, id)) {\n              const curChecked = checked && checkbox.exportValue === data.exportValue;\n              if (checkbox.domElement) {\n                checkbox.domElement.checked = curChecked;\n              }\n              storage.setValue(checkbox.id, {\n                value: curChecked\n              });\n            }\n            storage.setValue(id, {\n              value: checked\n            });\n          });\n          element.addEventListener(\"resetform\", event => {\n            const defaultValue = data.defaultFieldValue || \"Off\";\n            event.target.checked = defaultValue === data.exportValue;\n          });\n          if (this.enableScripting && this.hasJSActions) {\n            element.addEventListener(\"updatefromsandbox\", jsEvent => {\n              const actions = {\n                value(event) {\n                  event.target.checked = event.detail.value !== \"Off\";\n                  storage.setValue(id, {\n                    value: event.target.checked\n                  });\n                }\n              };\n              this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n          }\n          this._setBackgroundColor(element);\n          this.container.appendChild(element);\n          return this.container;\n        }\n      }\n      class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n        constructor(parameters) {\n          super(parameters, {\n            isRenderable: parameters.renderForms\n          });\n        }\n        render() {\n          this.container.className = \"buttonWidgetAnnotation radioButton\";\n          const storage = this.annotationStorage;\n          const data = this.data;\n          const id = data.id;\n          let value = storage.getValue(id, {\n            value: data.fieldValue === data.buttonValue\n          }).value;\n          if (typeof value === \"string\") {\n            value = value !== data.buttonValue;\n            storage.setValue(id, {\n              value\n            });\n          }\n          const element = document.createElement(\"input\");\n          GetElementsByNameSet.add(element);\n          element.disabled = data.readOnly;\n          element.type = \"radio\";\n          element.name = data.fieldName;\n          if (value) {\n            element.setAttribute(\"checked\", true);\n          }\n          element.setAttribute(\"id\", id);\n          element.tabIndex = DEFAULT_TAB_INDEX;\n          element.addEventListener(\"change\", event => {\n            const {\n              name,\n              checked\n            } = event.target;\n            for (const radio of this._getElementsByName(name, id)) {\n              storage.setValue(radio.id, {\n                value: false\n              });\n            }\n            storage.setValue(id, {\n              value: checked\n            });\n          });\n          element.addEventListener(\"resetform\", event => {\n            const defaultValue = data.defaultFieldValue;\n            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n          });\n          if (this.enableScripting && this.hasJSActions) {\n            const pdfButtonValue = data.buttonValue;\n            element.addEventListener(\"updatefromsandbox\", jsEvent => {\n              const actions = {\n                value: event => {\n                  const checked = pdfButtonValue === event.detail.value;\n                  for (const radio of this._getElementsByName(event.target.name)) {\n                    const curChecked = checked && radio.id === id;\n                    if (radio.domElement) {\n                      radio.domElement.checked = curChecked;\n                    }\n                    storage.setValue(radio.id, {\n                      value: curChecked\n                    });\n                  }\n                }\n              };\n              this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n          }\n          this._setBackgroundColor(element);\n          this.container.appendChild(element);\n          return this.container;\n        }\n      }\n      class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n        constructor(parameters) {\n          super(parameters, {\n            ignoreBorder: parameters.data.hasAppearance\n          });\n        }\n        render() {\n          const container = super.render();\n          container.className = \"buttonWidgetAnnotation pushButton\";\n          if (this.data.alternativeText) {\n            container.title = this.data.alternativeText;\n          }\n          return container;\n        }\n      }\n      class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n        constructor(parameters) {\n          super(parameters, {\n            isRenderable: parameters.renderForms\n          });\n        }\n        render() {\n          this.container.className = \"choiceWidgetAnnotation\";\n          const storage = this.annotationStorage;\n          const id = this.data.id;\n          storage.getValue(id, {\n            value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined\n          });\n          let {\n            fontSize\n          } = this.data.defaultAppearanceData;\n          if (!fontSize) {\n            fontSize = 9;\n          }\n          const fontSizeStyle = `calc(${fontSize}px * var(--zoom-factor))`;\n          const selectElement = document.createElement(\"select\");\n          GetElementsByNameSet.add(selectElement);\n          selectElement.disabled = this.data.readOnly;\n          selectElement.name = this.data.fieldName;\n          selectElement.setAttribute(\"id\", id);\n          selectElement.tabIndex = DEFAULT_TAB_INDEX;\n          selectElement.style.fontSize = `${fontSize}px`;\n          if (!this.data.combo) {\n            selectElement.size = this.data.options.length;\n            if (this.data.multiSelect) {\n              selectElement.multiple = true;\n            }\n          }\n          selectElement.addEventListener(\"resetform\", event => {\n            const defaultValue = this.data.defaultFieldValue;\n            for (const option of selectElement.options) {\n              option.selected = option.value === defaultValue;\n            }\n          });\n          for (const option of this.data.options) {\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = option.displayValue;\n            optionElement.value = option.exportValue;\n            if (this.data.combo) {\n              optionElement.style.fontSize = fontSizeStyle;\n            }\n            if (this.data.fieldValue.includes(option.exportValue)) {\n              optionElement.setAttribute(\"selected\", true);\n            }\n            selectElement.appendChild(optionElement);\n          }\n          const getValue = (event, isExport) => {\n            const name = isExport ? \"value\" : \"textContent\";\n            const options = event.target.options;\n            if (!event.target.multiple) {\n              return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n            }\n            return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);\n          };\n          const getItems = event => {\n            const options = event.target.options;\n            return Array.prototype.map.call(options, option => {\n              return {\n                displayValue: option.textContent,\n                exportValue: option.value\n              };\n            });\n          };\n          if (this.enableScripting && this.hasJSActions) {\n            selectElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n              const actions = {\n                value(event) {\n                  const value = event.detail.value;\n                  const values = new Set(Array.isArray(value) ? value : [value]);\n                  for (const option of selectElement.options) {\n                    option.selected = values.has(option.value);\n                  }\n                  storage.setValue(id, {\n                    value: getValue(event, true)\n                  });\n                },\n                multipleSelection(event) {\n                  selectElement.multiple = true;\n                },\n                remove(event) {\n                  const options = selectElement.options;\n                  const index = event.detail.remove;\n                  options[index].selected = false;\n                  selectElement.remove(index);\n                  if (options.length > 0) {\n                    const i = Array.prototype.findIndex.call(options, option => option.selected);\n                    if (i === -1) {\n                      options[0].selected = true;\n                    }\n                  }\n                  storage.setValue(id, {\n                    value: getValue(event, true),\n                    items: getItems(event)\n                  });\n                },\n                clear(event) {\n                  while (selectElement.length !== 0) {\n                    selectElement.remove(0);\n                  }\n                  storage.setValue(id, {\n                    value: null,\n                    items: []\n                  });\n                },\n                insert(event) {\n                  const {\n                    index,\n                    displayValue,\n                    exportValue\n                  } = event.detail.insert;\n                  const optionElement = document.createElement(\"option\");\n                  optionElement.textContent = displayValue;\n                  optionElement.value = exportValue;\n                  selectElement.insertBefore(optionElement, selectElement.children[index]);\n                  storage.setValue(id, {\n                    value: getValue(event, true),\n                    items: getItems(event)\n                  });\n                },\n                items(event) {\n                  const {\n                    items\n                  } = event.detail;\n                  while (selectElement.length !== 0) {\n                    selectElement.remove(0);\n                  }\n                  for (const item of items) {\n                    const {\n                      displayValue,\n                      exportValue\n                    } = item;\n                    const optionElement = document.createElement(\"option\");\n                    optionElement.textContent = displayValue;\n                    optionElement.value = exportValue;\n                    selectElement.appendChild(optionElement);\n                  }\n                  if (selectElement.options.length > 0) {\n                    selectElement.options[0].selected = true;\n                  }\n                  storage.setValue(id, {\n                    value: getValue(event, true),\n                    items: getItems(event)\n                  });\n                },\n                indices(event) {\n                  const indices = new Set(event.detail.indices);\n                  for (const option of event.target.options) {\n                    option.selected = indices.has(option.index);\n                  }\n                  storage.setValue(id, {\n                    value: getValue(event, true)\n                  });\n                },\n                editable(event) {\n                  event.target.disabled = !event.detail.editable;\n                }\n              };\n              this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            selectElement.addEventListener(\"input\", event => {\n              const exportValue = getValue(event, true);\n              const value = getValue(event, false);\n              storage.setValue(id, {\n                value: exportValue\n              });\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id,\n                  name: \"Keystroke\",\n                  value,\n                  changeEx: exportValue,\n                  willCommit: true,\n                  commitKey: 1,\n                  keyDown: false\n                }\n              });\n            });\n            this._setEventListeners(selectElement, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"]], event => event.target.checked);\n          } else {\n            selectElement.addEventListener(\"input\", function (event) {\n              storage.setValue(id, {\n                value: getValue(event)\n              });\n            });\n          }\n          this._setBackgroundColor(selectElement);\n          this.container.appendChild(selectElement);\n          return this.container;\n        }\n      }\n      class PopupAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable\n          });\n        }\n        render() {\n          const IGNORE_TYPES = [\"Line\", \"Square\", \"Circle\", \"PolyLine\", \"Polygon\", \"Ink\"];\n          this.container.className = \"popupAnnotation\";\n          if (IGNORE_TYPES.includes(this.data.parentType)) {\n            return this.container;\n          }\n          const selector = `[data-annotation-id=\"${this.data.parentId}\"]`;\n          const parentElements = this.layer.querySelectorAll(selector);\n          if (parentElements.length === 0) {\n            return this.container;\n          }\n          const popup = new PopupElement({\n            container: this.container,\n            trigger: Array.from(parentElements),\n            color: this.data.color,\n            titleObj: this.data.titleObj,\n            modificationDate: this.data.modificationDate,\n            contentsObj: this.data.contentsObj,\n            richText: this.data.richText\n          });\n          const page = this.page;\n          const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);\n          const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];\n          const popupTop = rect[1];\n          this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;\n          this.container.style.left = `${popupLeft}px`;\n          this.container.style.top = `${popupTop}px`;\n          this.container.appendChild(popup.render());\n          return this.container;\n        }\n      }\n      class PopupElement {\n        constructor(parameters) {\n          this.container = parameters.container;\n          this.trigger = parameters.trigger;\n          this.color = parameters.color;\n          this.titleObj = parameters.titleObj;\n          this.modificationDate = parameters.modificationDate;\n          this.contentsObj = parameters.contentsObj;\n          this.richText = parameters.richText;\n          this.hideWrapper = parameters.hideWrapper || false;\n          this.pinned = false;\n        }\n        render() {\n          const BACKGROUND_ENLIGHT = 0.7;\n          const wrapper = document.createElement(\"div\");\n          wrapper.className = \"popupWrapper\";\n          this.hideElement = this.hideWrapper ? wrapper : this.container;\n          this.hideElement.hidden = true;\n          const popup = document.createElement(\"div\");\n          popup.className = \"popup\";\n          const color = this.color;\n          if (color) {\n            const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n            const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n            const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n            popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);\n          }\n          const title = document.createElement(\"h1\");\n          title.dir = this.titleObj.dir;\n          title.textContent = this.titleObj.str;\n          popup.appendChild(title);\n          const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);\n          if (dateObject) {\n            const modificationDate = document.createElement(\"span\");\n            modificationDate.className = \"popupDate\";\n            modificationDate.textContent = \"{{date}}, {{time}}\";\n            modificationDate.dataset.l10nId = \"annotation_date_string\";\n            modificationDate.dataset.l10nArgs = JSON.stringify({\n              date: dateObject.toLocaleDateString(),\n              time: dateObject.toLocaleTimeString()\n            });\n            popup.appendChild(modificationDate);\n          }\n          if (this.richText?.str && (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) {\n            _xfa_layer.XfaLayer.render({\n              xfaHtml: this.richText.html,\n              intent: \"richText\",\n              div: popup\n            });\n            popup.lastChild.className = \"richText popupContent\";\n          } else {\n            const contents = this._formatContents(this.contentsObj);\n            popup.appendChild(contents);\n          }\n          if (!Array.isArray(this.trigger)) {\n            this.trigger = [this.trigger];\n          }\n          for (const element of this.trigger) {\n            element.addEventListener(\"click\", this._toggle.bind(this));\n            element.addEventListener(\"mouseover\", this._show.bind(this, false));\n            element.addEventListener(\"mouseout\", this._hide.bind(this, false));\n          }\n          popup.addEventListener(\"click\", this._hide.bind(this, true));\n          wrapper.appendChild(popup);\n          return wrapper;\n        }\n        _formatContents({\n          str,\n          dir\n        }) {\n          const p = document.createElement(\"p\");\n          p.className = \"popupContent\";\n          p.dir = dir;\n          const lines = str.split(/(?:\\r\\n?|\\n)/);\n          for (let i = 0, ii = lines.length; i < ii; ++i) {\n            const line = lines[i];\n            p.appendChild(document.createTextNode(line));\n            if (i < ii - 1) {\n              p.appendChild(document.createElement(\"br\"));\n            }\n          }\n          return p;\n        }\n        _toggle() {\n          if (this.pinned) {\n            this._hide(true);\n          } else {\n            this._show(true);\n          }\n        }\n        _show(pin = false) {\n          if (pin) {\n            this.pinned = true;\n          }\n          if (this.hideElement.hidden) {\n            this.hideElement.hidden = false;\n            this.container.style.zIndex += 1;\n          }\n        }\n        _hide(unpin = true) {\n          if (unpin) {\n            this.pinned = false;\n          }\n          if (!this.hideElement.hidden && !this.pinned) {\n            this.hideElement.hidden = true;\n            this.container.style.zIndex -= 1;\n          }\n        }\n      }\n      class FreeTextAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true\n          });\n        }\n        render() {\n          this.container.className = \"freeTextAnnotation\";\n          if (!this.data.hasPopup) {\n            this._createPopup(null, this.data);\n          }\n          return this.container;\n        }\n      }\n      class LineAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true\n          });\n        }\n        render() {\n          this.container.className = \"lineAnnotation\";\n          const data = this.data;\n          const width = data.rect[2] - data.rect[0];\n          const height = data.rect[3] - data.rect[1];\n          const svg = this.svgFactory.create(width, height);\n          const line = this.svgFactory.createElement(\"svg:line\");\n          line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n          line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n          line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n          line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n          line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n          line.setAttribute(\"stroke\", \"transparent\");\n          line.setAttribute(\"fill\", \"transparent\");\n          svg.appendChild(line);\n          this.container.append(svg);\n          this._createPopup(line, data);\n          return this.container;\n        }\n      }\n      class SquareAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true\n          });\n        }\n        render() {\n          this.container.className = \"squareAnnotation\";\n          const data = this.data;\n          const width = data.rect[2] - data.rect[0];\n          const height = data.rect[3] - data.rect[1];\n          const svg = this.svgFactory.create(width, height);\n          const borderWidth = data.borderStyle.width;\n          const square = this.svgFactory.createElement(\"svg:rect\");\n          square.setAttribute(\"x\", borderWidth / 2);\n          square.setAttribute(\"y\", borderWidth / 2);\n          square.setAttribute(\"width\", width - borderWidth);\n          square.setAttribute(\"height\", height - borderWidth);\n          square.setAttribute(\"stroke-width\", borderWidth || 1);\n          square.setAttribute(\"stroke\", \"transparent\");\n          square.setAttribute(\"fill\", \"transparent\");\n          svg.appendChild(square);\n          this.container.append(svg);\n          this._createPopup(square, data);\n          return this.container;\n        }\n      }\n      class CircleAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true\n          });\n        }\n        render() {\n          this.container.className = \"circleAnnotation\";\n          const data = this.data;\n          const width = data.rect[2] - data.rect[0];\n          const height = data.rect[3] - data.rect[1];\n          const svg = this.svgFactory.create(width, height);\n          const borderWidth = data.borderStyle.width;\n          const circle = this.svgFactory.createElement(\"svg:ellipse\");\n          circle.setAttribute(\"cx\", width / 2);\n          circle.setAttribute(\"cy\", height / 2);\n          circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n          circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n          circle.setAttribute(\"stroke-width\", borderWidth || 1);\n          circle.setAttribute(\"stroke\", \"transparent\");\n          circle.setAttribute(\"fill\", \"transparent\");\n          svg.appendChild(circle);\n          this.container.append(svg);\n          this._createPopup(circle, data);\n          return this.container;\n        }\n      }\n      class PolylineAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true\n          });\n          this.containerClassName = \"polylineAnnotation\";\n          this.svgElementName = \"svg:polyline\";\n        }\n        render() {\n          this.container.className = this.containerClassName;\n          const data = this.data;\n          const width = data.rect[2] - data.rect[0];\n          const height = data.rect[3] - data.rect[1];\n          const svg = this.svgFactory.create(width, height);\n          let points = [];\n          for (const coordinate of data.vertices) {\n            const x = coordinate.x - data.rect[0];\n            const y = data.rect[3] - coordinate.y;\n            points.push(x + \",\" + y);\n          }\n          points = points.join(\" \");\n          const polyline = this.svgFactory.createElement(this.svgElementName);\n          polyline.setAttribute(\"points\", points);\n          polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n          polyline.setAttribute(\"stroke\", \"transparent\");\n          polyline.setAttribute(\"fill\", \"transparent\");\n          svg.appendChild(polyline);\n          this.container.append(svg);\n          this._createPopup(polyline, data);\n          return this.container;\n        }\n      }\n      class PolygonAnnotationElement extends PolylineAnnotationElement {\n        constructor(parameters) {\n          super(parameters);\n          this.containerClassName = \"polygonAnnotation\";\n          this.svgElementName = \"svg:polygon\";\n        }\n      }\n      class CaretAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true\n          });\n        }\n        render() {\n          this.container.className = \"caretAnnotation\";\n          if (!this.data.hasPopup) {\n            this._createPopup(null, this.data);\n          }\n          return this.container;\n        }\n      }\n      class InkAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true\n          });\n          this.containerClassName = \"inkAnnotation\";\n          this.svgElementName = \"svg:polyline\";\n        }\n        render() {\n          this.container.className = this.containerClassName;\n          const data = this.data;\n          const width = data.rect[2] - data.rect[0];\n          const height = data.rect[3] - data.rect[1];\n          const svg = this.svgFactory.create(width, height);\n          for (const inkList of data.inkLists) {\n            let points = [];\n            for (const coordinate of inkList) {\n              const x = coordinate.x - data.rect[0];\n              const y = data.rect[3] - coordinate.y;\n              points.push(`${x},${y}`);\n            }\n            points = points.join(\" \");\n            const polyline = this.svgFactory.createElement(this.svgElementName);\n            polyline.setAttribute(\"points\", points);\n            polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n            polyline.setAttribute(\"stroke\", \"transparent\");\n            polyline.setAttribute(\"fill\", \"transparent\");\n            this._createPopup(polyline, data);\n            svg.appendChild(polyline);\n          }\n          this.container.append(svg);\n          return this.container;\n        }\n      }\n      class HighlightAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n          });\n        }\n        render() {\n          if (!this.data.hasPopup) {\n            this._createPopup(null, this.data);\n          }\n          if (this.quadrilaterals) {\n            return this._renderQuadrilaterals(\"highlightAnnotation\");\n          }\n          this.container.className = \"highlightAnnotation\";\n          return this.container;\n        }\n      }\n      class UnderlineAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n          });\n        }\n        render() {\n          if (!this.data.hasPopup) {\n            this._createPopup(null, this.data);\n          }\n          if (this.quadrilaterals) {\n            return this._renderQuadrilaterals(\"underlineAnnotation\");\n          }\n          this.container.className = \"underlineAnnotation\";\n          return this.container;\n        }\n      }\n      class SquigglyAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n          });\n        }\n        render() {\n          if (!this.data.hasPopup) {\n            this._createPopup(null, this.data);\n          }\n          if (this.quadrilaterals) {\n            return this._renderQuadrilaterals(\"squigglyAnnotation\");\n          }\n          this.container.className = \"squigglyAnnotation\";\n          return this.container;\n        }\n      }\n      class StrikeOutAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n          });\n        }\n        render() {\n          if (!this.data.hasPopup) {\n            this._createPopup(null, this.data);\n          }\n          if (this.quadrilaterals) {\n            return this._renderQuadrilaterals(\"strikeoutAnnotation\");\n          }\n          this.container.className = \"strikeoutAnnotation\";\n          return this.container;\n        }\n      }\n      class StampAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);\n          super(parameters, {\n            isRenderable,\n            ignoreBorder: true\n          });\n        }\n        render() {\n          this.container.className = \"stampAnnotation\";\n          if (!this.data.hasPopup) {\n            this._createPopup(null, this.data);\n          }\n          return this.container;\n        }\n      }\n      class FileAttachmentAnnotationElement extends AnnotationElement {\n        constructor(parameters) {\n          super(parameters, {\n            isRenderable: true\n          });\n          const {\n            filename,\n            content\n          } = this.data.file;\n          this.filename = (0, _display_utils.getFilenameFromUrl)(filename);\n          this.content = content;\n          this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n            source: this,\n            id: (0, _util.stringToPDFString)(filename),\n            filename,\n            content\n          });\n        }\n        render() {\n          this.container.className = \"fileAttachmentAnnotation\";\n          const trigger = document.createElement(\"div\");\n          trigger.style.height = this.container.style.height;\n          trigger.style.width = this.container.style.width;\n          trigger.addEventListener(\"dblclick\", this._download.bind(this));\n          if (!this.data.hasPopup && (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) {\n            this._createPopup(trigger, this.data);\n          }\n          this.container.appendChild(trigger);\n          return this.container;\n        }\n        _download() {\n          this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);\n        }\n      }\n      class AnnotationLayer {\n        static render(parameters) {\n          const sortedAnnotations = [],\n            popupAnnotations = [];\n          for (const data of parameters.annotations) {\n            if (!data) {\n              continue;\n            }\n            if (data.annotationType === _util.AnnotationType.POPUP) {\n              popupAnnotations.push(data);\n              continue;\n            }\n            sortedAnnotations.push(data);\n          }\n          if (popupAnnotations.length) {\n            sortedAnnotations.push(...popupAnnotations);\n          }\n          const div = parameters.div;\n          for (const data of sortedAnnotations) {\n            const element = AnnotationElementFactory.create({\n              data,\n              layer: div,\n              page: parameters.page,\n              viewport: parameters.viewport,\n              linkService: parameters.linkService,\n              downloadManager: parameters.downloadManager,\n              imageResourcesPath: parameters.imageResourcesPath || \"\",\n              renderForms: parameters.renderForms !== false,\n              svgFactory: new _display_utils.DOMSVGFactory(),\n              annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),\n              enableScripting: parameters.enableScripting,\n              hasJSActions: parameters.hasJSActions,\n              fieldObjects: parameters.fieldObjects,\n              mouseState: parameters.mouseState || {\n                isDown: false\n              }\n            });\n            if (element.isRenderable) {\n              const rendered = element.render();\n              if (data.hidden) {\n                rendered.style.visibility = \"hidden\";\n              }\n              if (Array.isArray(rendered)) {\n                for (const renderedElement of rendered) {\n                  div.appendChild(renderedElement);\n                }\n              } else {\n                if (element instanceof PopupAnnotationElement) {\n                  div.prepend(rendered);\n                } else {\n                  div.appendChild(rendered);\n                }\n              }\n            }\n          }\n          this.#setAnnotationCanvasMap(div, parameters.annotationCanvasMap);\n        }\n        static update(parameters) {\n          const {\n            page,\n            viewport,\n            annotations,\n            annotationCanvasMap,\n            div\n          } = parameters;\n          const transform = viewport.transform;\n          const matrix = `matrix(${transform.join(\",\")})`;\n          let scale, ownMatrix;\n          for (const data of annotations) {\n            const elements = div.querySelectorAll(`[data-annotation-id=\"${data.id}\"]`);\n            if (elements) {\n              for (const element of elements) {\n                if (data.hasOwnCanvas) {\n                  const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n                  if (!ownMatrix) {\n                    scale = Math.abs(transform[0] || transform[1]);\n                    const ownTransform = transform.slice();\n                    for (let i = 0; i < 4; i++) {\n                      ownTransform[i] = Math.sign(ownTransform[i]);\n                    }\n                    ownMatrix = `matrix(${ownTransform.join(\",\")})`;\n                  }\n                  const left = rect[0] * scale;\n                  const top = rect[1] * scale;\n                  element.style.left = `${left}px`;\n                  element.style.top = `${top}px`;\n                  element.style.transformOrigin = `${-left}px ${-top}px`;\n                  element.style.transform = ownMatrix;\n                } else {\n                  element.style.transform = matrix;\n                }\n              }\n            }\n          }\n          this.#setAnnotationCanvasMap(div, annotationCanvasMap);\n          div.hidden = false;\n        }\n        static #setAnnotationCanvasMap(div, annotationCanvasMap) {\n          if (!annotationCanvasMap) {\n            return;\n          }\n          for (const [id, canvas] of annotationCanvasMap) {\n            const element = div.querySelector(`[data-annotation-id=\"${id}\"]`);\n            if (!element) {\n              continue;\n            }\n            const {\n              firstChild\n            } = element;\n            if (firstChild.nodeName === \"CANVAS\") {\n              element.replaceChild(canvas, firstChild);\n            } else {\n              element.insertBefore(canvas, firstChild);\n            }\n          }\n          annotationCanvasMap.clear();\n        }\n      }\n      exports.AnnotationLayer = AnnotationLayer;\n\n      /***/\n    }), (/* 19 */\n    /***/(__unused_webpack_module, exports) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.ColorConverters = void 0;\n      function makeColorComp(n) {\n        return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n      }\n      class ColorConverters {\n        static CMYK_G([c, y, m, k]) {\n          return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n        }\n        static G_CMYK([g]) {\n          return [\"CMYK\", 0, 0, 0, 1 - g];\n        }\n        static G_RGB([g]) {\n          return [\"RGB\", g, g, g];\n        }\n        static G_HTML([g]) {\n          const G = makeColorComp(g);\n          return `#${G}${G}${G}`;\n        }\n        static RGB_G([r, g, b]) {\n          return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n        }\n        static RGB_HTML([r, g, b]) {\n          const R = makeColorComp(r);\n          const G = makeColorComp(g);\n          const B = makeColorComp(b);\n          return `#${R}${G}${B}`;\n        }\n        static T_HTML() {\n          return \"#00000000\";\n        }\n        static CMYK_RGB([c, y, m, k]) {\n          return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n        }\n        static CMYK_HTML(components) {\n          return this.RGB_HTML(this.CMYK_RGB(components));\n        }\n        static RGB_CMYK([r, g, b]) {\n          const c = 1 - r;\n          const m = 1 - g;\n          const y = 1 - b;\n          const k = Math.min(c, m, y);\n          return [\"CMYK\", c, m, y, k];\n        }\n      }\n      exports.ColorConverters = ColorConverters;\n\n      /***/\n    }), (/* 20 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.XfaLayer = void 0;\n      var _util = __w_pdfjs_require__(2);\n      var _xfa_text = __w_pdfjs_require__(17);\n      class XfaLayer {\n        static setupStorage(html, id, element, storage, intent) {\n          const storedData = storage.getValue(id, {\n            value: null\n          });\n          switch (element.name) {\n            case \"textarea\":\n              if (storedData.value !== null) {\n                html.textContent = storedData.value;\n              }\n              if (intent === \"print\") {\n                break;\n              }\n              html.addEventListener(\"input\", event => {\n                storage.setValue(id, {\n                  value: event.target.value\n                });\n              });\n              break;\n            case \"input\":\n              if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                if (storedData.value === element.attributes.xfaOn) {\n                  html.setAttribute(\"checked\", true);\n                } else if (storedData.value === element.attributes.xfaOff) {\n                  html.removeAttribute(\"checked\");\n                }\n                if (intent === \"print\") {\n                  break;\n                }\n                html.addEventListener(\"change\", event => {\n                  storage.setValue(id, {\n                    value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                  });\n                });\n              } else {\n                if (storedData.value !== null) {\n                  html.setAttribute(\"value\", storedData.value);\n                }\n                if (intent === \"print\") {\n                  break;\n                }\n                html.addEventListener(\"input\", event => {\n                  storage.setValue(id, {\n                    value: event.target.value\n                  });\n                });\n              }\n              break;\n            case \"select\":\n              if (storedData.value !== null) {\n                for (const option of element.children) {\n                  if (option.attributes.value === storedData.value) {\n                    option.attributes.selected = true;\n                  }\n                }\n              }\n              html.addEventListener(\"input\", event => {\n                const options = event.target.options;\n                const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                storage.setValue(id, {\n                  value\n                });\n              });\n              break;\n          }\n        }\n        static setAttributes({\n          html,\n          element,\n          storage = null,\n          intent,\n          linkService\n        }) {\n          const {\n            attributes\n          } = element;\n          const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n          if (attributes.type === \"radio\") {\n            attributes.name = `${attributes.name}-${intent}`;\n          }\n          for (const [key, value] of Object.entries(attributes)) {\n            if (value === null || value === undefined || key === \"dataId\") {\n              continue;\n            }\n            if (key !== \"style\") {\n              if (key === \"textContent\") {\n                html.textContent = value;\n              } else if (key === \"class\") {\n                if (value.length) {\n                  html.setAttribute(key, value.join(\" \"));\n                }\n              } else {\n                if (isHTMLAnchorElement && (key === \"href\" || key === \"newWindow\")) {\n                  continue;\n                }\n                html.setAttribute(key, value);\n              }\n            } else {\n              Object.assign(html.style, value);\n            }\n          }\n          if (isHTMLAnchorElement) {\n            if (!linkService.addLinkAttributes) {\n              (0, _util.warn)(\"XfaLayer.setAttribute - missing `addLinkAttributes`-method on the `linkService`-instance.\");\n            }\n            linkService.addLinkAttributes?.(html, attributes.href, attributes.newWindow);\n          }\n          if (storage && attributes.dataId) {\n            this.setupStorage(html, attributes.dataId, element, storage);\n          }\n        }\n        static render(parameters) {\n          const storage = parameters.annotationStorage;\n          const linkService = parameters.linkService;\n          const root = parameters.xfaHtml;\n          const intent = parameters.intent || \"display\";\n          const rootHtml = document.createElement(root.name);\n          if (root.attributes) {\n            this.setAttributes({\n              html: rootHtml,\n              element: root,\n              intent,\n              linkService\n            });\n          }\n          const stack = [[root, -1, rootHtml]];\n          const rootDiv = parameters.div;\n          rootDiv.appendChild(rootHtml);\n          if (parameters.viewport) {\n            const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n            rootDiv.style.transform = transform;\n          }\n          if (intent !== \"richText\") {\n            rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n          }\n          const textDivs = [];\n          while (stack.length > 0) {\n            const [parent, i, html] = stack[stack.length - 1];\n            if (i + 1 === parent.children.length) {\n              stack.pop();\n              continue;\n            }\n            const child = parent.children[++stack[stack.length - 1][1]];\n            if (child === null) {\n              continue;\n            }\n            const {\n              name\n            } = child;\n            if (name === \"#text\") {\n              const node = document.createTextNode(child.value);\n              textDivs.push(node);\n              html.appendChild(node);\n              continue;\n            }\n            let childHtml;\n            if (child?.attributes?.xmlns) {\n              childHtml = document.createElementNS(child.attributes.xmlns, name);\n            } else {\n              childHtml = document.createElement(name);\n            }\n            html.appendChild(childHtml);\n            if (child.attributes) {\n              this.setAttributes({\n                html: childHtml,\n                element: child,\n                storage,\n                intent,\n                linkService\n              });\n            }\n            if (child.children && child.children.length > 0) {\n              stack.push([child, -1, childHtml]);\n            } else if (child.value) {\n              const node = document.createTextNode(child.value);\n              if (_xfa_text.XfaText.shouldBuildText(name)) {\n                textDivs.push(node);\n              }\n              childHtml.appendChild(node);\n            }\n          }\n          for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")) {\n            el.setAttribute(\"readOnly\", true);\n          }\n          return {\n            textDivs\n          };\n        }\n        static update(parameters) {\n          const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n          parameters.div.style.transform = transform;\n          parameters.div.hidden = false;\n        }\n      }\n      exports.XfaLayer = XfaLayer;\n\n      /***/\n    }), (/* 21 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.renderTextLayer = renderTextLayer;\n      var _util = __w_pdfjs_require__(2);\n      const MAX_TEXT_DIVS_TO_RENDER = 100000;\n      const DEFAULT_FONT_SIZE = 30;\n      const DEFAULT_FONT_ASCENT = 0.8;\n      const ascentCache = new Map();\n      const AllWhitespaceRegexp = /^\\s+$/g;\n      function getAscent(fontFamily, ctx) {\n        const cachedAscent = ascentCache.get(fontFamily);\n        if (cachedAscent) {\n          return cachedAscent;\n        }\n        ctx.save();\n        ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;\n        const metrics = ctx.measureText(\"\");\n        let ascent = metrics.fontBoundingBoxAscent;\n        let descent = Math.abs(metrics.fontBoundingBoxDescent);\n        if (ascent) {\n          ctx.restore();\n          const ratio = ascent / (ascent + descent);\n          ascentCache.set(fontFamily, ratio);\n          return ratio;\n        }\n        ctx.strokeStyle = \"red\";\n        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n        ctx.strokeText(\"g\", 0, 0);\n        let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n        descent = 0;\n        for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {\n          if (pixels[i] > 0) {\n            descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n            break;\n          }\n        }\n        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n        ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n        pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n        ascent = 0;\n        for (let i = 0, ii = pixels.length; i < ii; i += 4) {\n          if (pixels[i] > 0) {\n            ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n            break;\n          }\n        }\n        ctx.restore();\n        if (ascent) {\n          const ratio = ascent / (ascent + descent);\n          ascentCache.set(fontFamily, ratio);\n          return ratio;\n        }\n        ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n        return DEFAULT_FONT_ASCENT;\n      }\n      function appendText(task, geom, styles, ctx) {\n        const textDiv = document.createElement(\"span\");\n        const textDivProperties = task._enhanceTextSelection ? {\n          angle: 0,\n          canvasWidth: 0,\n          hasText: geom.str !== \"\",\n          hasEOL: geom.hasEOL,\n          originalTransform: null,\n          paddingBottom: 0,\n          paddingLeft: 0,\n          paddingRight: 0,\n          paddingTop: 0,\n          scale: 1\n        } : {\n          angle: 0,\n          canvasWidth: 0,\n          hasText: geom.str !== \"\",\n          hasEOL: geom.hasEOL\n        };\n        task._textDivs.push(textDiv);\n        const tx = _util.Util.transform(task._viewport.transform, geom.transform);\n        let angle = Math.atan2(tx[1], tx[0]);\n        const style = styles[geom.fontName];\n        if (style.vertical) {\n          angle += Math.PI / 2;\n        }\n        const fontHeight = Math.hypot(tx[2], tx[3]);\n        const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);\n        let left, top;\n        if (angle === 0) {\n          left = tx[4];\n          top = tx[5] - fontAscent;\n        } else {\n          left = tx[4] + fontAscent * Math.sin(angle);\n          top = tx[5] - fontAscent * Math.cos(angle);\n        }\n        textDiv.style.left = `${left}px`;\n        textDiv.style.top = `${top}px`;\n        textDiv.style.fontSize = `${fontHeight}px`;\n        textDiv.style.fontFamily = style.fontFamily;\n        textDiv.setAttribute(\"role\", \"presentation\");\n        textDiv.textContent = geom.str;\n        textDiv.dir = geom.dir;\n        if (task._fontInspectorEnabled) {\n          textDiv.dataset.fontName = geom.fontName;\n        }\n        if (angle !== 0) {\n          textDivProperties.angle = angle * (180 / Math.PI);\n        }\n        let shouldScaleText = false;\n        if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {\n          shouldScaleText = true;\n        } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n          const absScaleX = Math.abs(geom.transform[0]),\n            absScaleY = Math.abs(geom.transform[3]);\n          if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n            shouldScaleText = true;\n          }\n        }\n        if (shouldScaleText) {\n          if (style.vertical) {\n            textDivProperties.canvasWidth = geom.height * task._viewport.scale;\n          } else {\n            textDivProperties.canvasWidth = geom.width * task._viewport.scale;\n          }\n        }\n        task._textDivProperties.set(textDiv, textDivProperties);\n        if (task._textContentStream) {\n          task._layoutText(textDiv);\n        }\n        if (task._enhanceTextSelection && textDivProperties.hasText) {\n          let angleCos = 1,\n            angleSin = 0;\n          if (angle !== 0) {\n            angleCos = Math.cos(angle);\n            angleSin = Math.sin(angle);\n          }\n          const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;\n          const divHeight = fontHeight;\n          let m, b;\n          if (angle !== 0) {\n            m = [angleCos, angleSin, -angleSin, angleCos, left, top];\n            b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\n          } else {\n            b = [left, top, left + divWidth, top + divHeight];\n          }\n          task._bounds.push({\n            left: b[0],\n            top: b[1],\n            right: b[2],\n            bottom: b[3],\n            div: textDiv,\n            size: [divWidth, divHeight],\n            m\n          });\n        }\n      }\n      function render(task) {\n        if (task._canceled) {\n          return;\n        }\n        const textDivs = task._textDivs;\n        const capability = task._capability;\n        const textDivsLength = textDivs.length;\n        if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n          task._renderingDone = true;\n          capability.resolve();\n          return;\n        }\n        if (!task._textContentStream) {\n          for (let i = 0; i < textDivsLength; i++) {\n            task._layoutText(textDivs[i]);\n          }\n        }\n        task._renderingDone = true;\n        capability.resolve();\n      }\n      function findPositiveMin(ts, offset, count) {\n        let result = 0;\n        for (let i = 0; i < count; i++) {\n          const t = ts[offset++];\n          if (t > 0) {\n            result = result ? Math.min(t, result) : t;\n          }\n        }\n        return result;\n      }\n      function expand(task) {\n        const bounds = task._bounds;\n        const viewport = task._viewport;\n        const expanded = expandBounds(viewport.width, viewport.height, bounds);\n        for (let i = 0; i < expanded.length; i++) {\n          const div = bounds[i].div;\n          const divProperties = task._textDivProperties.get(div);\n          if (divProperties.angle === 0) {\n            divProperties.paddingLeft = bounds[i].left - expanded[i].left;\n            divProperties.paddingTop = bounds[i].top - expanded[i].top;\n            divProperties.paddingRight = expanded[i].right - bounds[i].right;\n            divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\n            task._textDivProperties.set(div, divProperties);\n            continue;\n          }\n          const e = expanded[i],\n            b = bounds[i];\n          const m = b.m,\n            c = m[0],\n            s = m[1];\n          const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\n          const ts = new Float64Array(64);\n          for (let j = 0, jj = points.length; j < jj; j++) {\n            const t = _util.Util.applyTransform(points[j], m);\n            ts[j + 0] = c && (e.left - t[0]) / c;\n            ts[j + 4] = s && (e.top - t[1]) / s;\n            ts[j + 8] = c && (e.right - t[0]) / c;\n            ts[j + 12] = s && (e.bottom - t[1]) / s;\n            ts[j + 16] = s && (e.left - t[0]) / -s;\n            ts[j + 20] = c && (e.top - t[1]) / c;\n            ts[j + 24] = s && (e.right - t[0]) / -s;\n            ts[j + 28] = c && (e.bottom - t[1]) / c;\n            ts[j + 32] = c && (e.left - t[0]) / -c;\n            ts[j + 36] = s && (e.top - t[1]) / -s;\n            ts[j + 40] = c && (e.right - t[0]) / -c;\n            ts[j + 44] = s && (e.bottom - t[1]) / -s;\n            ts[j + 48] = s && (e.left - t[0]) / s;\n            ts[j + 52] = c && (e.top - t[1]) / -c;\n            ts[j + 56] = s && (e.right - t[0]) / s;\n            ts[j + 60] = c && (e.bottom - t[1]) / -c;\n          }\n          const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\n          divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\n          divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\n          divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\n          divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\n          task._textDivProperties.set(div, divProperties);\n        }\n      }\n      function expandBounds(width, height, boxes) {\n        const bounds = boxes.map(function (box, i) {\n          return {\n            x1: box.left,\n            y1: box.top,\n            x2: box.right,\n            y2: box.bottom,\n            index: i,\n            x1New: undefined,\n            x2New: undefined\n          };\n        });\n        expandBoundsLTR(width, bounds);\n        const expanded = new Array(boxes.length);\n        for (const b of bounds) {\n          const i = b.index;\n          expanded[i] = {\n            left: b.x1New,\n            top: 0,\n            right: b.x2New,\n            bottom: 0\n          };\n        }\n        boxes.map(function (box, i) {\n          const e = expanded[i],\n            b = bounds[i];\n          b.x1 = box.top;\n          b.y1 = width - e.right;\n          b.x2 = box.bottom;\n          b.y2 = width - e.left;\n          b.index = i;\n          b.x1New = undefined;\n          b.x2New = undefined;\n        });\n        expandBoundsLTR(height, bounds);\n        for (const b of bounds) {\n          const i = b.index;\n          expanded[i].top = b.x1New;\n          expanded[i].bottom = b.x2New;\n        }\n        return expanded;\n      }\n      function expandBoundsLTR(width, bounds) {\n        bounds.sort(function (a, b) {\n          return a.x1 - b.x1 || a.index - b.index;\n        });\n        const fakeBoundary = {\n          x1: -Infinity,\n          y1: -Infinity,\n          x2: 0,\n          y2: Infinity,\n          index: -1,\n          x1New: 0,\n          x2New: 0\n        };\n        const horizon = [{\n          start: -Infinity,\n          end: Infinity,\n          boundary: fakeBoundary\n        }];\n        for (const boundary of bounds) {\n          let i = 0;\n          while (i < horizon.length && horizon[i].end <= boundary.y1) {\n            i++;\n          }\n          let j = horizon.length - 1;\n          while (j >= 0 && horizon[j].start >= boundary.y2) {\n            j--;\n          }\n          let horizonPart, affectedBoundary;\n          let q,\n            k,\n            maxXNew = -Infinity;\n          for (q = i; q <= j; q++) {\n            horizonPart = horizon[q];\n            affectedBoundary = horizonPart.boundary;\n            let xNew;\n            if (affectedBoundary.x2 > boundary.x1) {\n              xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;\n            } else if (affectedBoundary.x2New === undefined) {\n              xNew = (affectedBoundary.x2 + boundary.x1) / 2;\n            } else {\n              xNew = affectedBoundary.x2New;\n            }\n            if (xNew > maxXNew) {\n              maxXNew = xNew;\n            }\n          }\n          boundary.x1New = maxXNew;\n          for (q = i; q <= j; q++) {\n            horizonPart = horizon[q];\n            affectedBoundary = horizonPart.boundary;\n            if (affectedBoundary.x2New === undefined) {\n              if (affectedBoundary.x2 > boundary.x1) {\n                if (affectedBoundary.index > boundary.index) {\n                  affectedBoundary.x2New = affectedBoundary.x2;\n                }\n              } else {\n                affectedBoundary.x2New = maxXNew;\n              }\n            } else if (affectedBoundary.x2New > maxXNew) {\n              affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\n            }\n          }\n          const changedHorizon = [];\n          let lastBoundary = null;\n          for (q = i; q <= j; q++) {\n            horizonPart = horizon[q];\n            affectedBoundary = horizonPart.boundary;\n            const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\n            if (lastBoundary === useBoundary) {\n              changedHorizon[changedHorizon.length - 1].end = horizonPart.end;\n            } else {\n              changedHorizon.push({\n                start: horizonPart.start,\n                end: horizonPart.end,\n                boundary: useBoundary\n              });\n              lastBoundary = useBoundary;\n            }\n          }\n          if (horizon[i].start < boundary.y1) {\n            changedHorizon[0].start = boundary.y1;\n            changedHorizon.unshift({\n              start: horizon[i].start,\n              end: boundary.y1,\n              boundary: horizon[i].boundary\n            });\n          }\n          if (boundary.y2 < horizon[j].end) {\n            changedHorizon[changedHorizon.length - 1].end = boundary.y2;\n            changedHorizon.push({\n              start: boundary.y2,\n              end: horizon[j].end,\n              boundary: horizon[j].boundary\n            });\n          }\n          for (q = i; q <= j; q++) {\n            horizonPart = horizon[q];\n            affectedBoundary = horizonPart.boundary;\n            if (affectedBoundary.x2New !== undefined) {\n              continue;\n            }\n            let used = false;\n            for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {\n              used = horizon[k].boundary === affectedBoundary;\n            }\n            for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {\n              used = horizon[k].boundary === affectedBoundary;\n            }\n            for (k = 0; !used && k < changedHorizon.length; k++) {\n              used = changedHorizon[k].boundary === affectedBoundary;\n            }\n            if (!used) {\n              affectedBoundary.x2New = maxXNew;\n            }\n          }\n          Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));\n        }\n        for (const horizonPart of horizon) {\n          const affectedBoundary = horizonPart.boundary;\n          if (affectedBoundary.x2New === undefined) {\n            affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\n          }\n        }\n      }\n      class TextLayerRenderTask {\n        constructor({\n          textContent,\n          textContentStream,\n          container,\n          viewport,\n          textDivs,\n          textContentItemsStr,\n          enhanceTextSelection\n        }) {\n          this._textContent = textContent;\n          this._textContentStream = textContentStream;\n          this._container = container;\n          this._document = container.ownerDocument;\n          this._viewport = viewport;\n          this._textDivs = textDivs || [];\n          this._textContentItemsStr = textContentItemsStr || [];\n          this._enhanceTextSelection = !!enhanceTextSelection;\n          this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n          this._reader = null;\n          this._layoutTextLastFontSize = null;\n          this._layoutTextLastFontFamily = null;\n          this._layoutTextCtx = null;\n          this._textDivProperties = new WeakMap();\n          this._renderingDone = false;\n          this._canceled = false;\n          this._capability = (0, _util.createPromiseCapability)();\n          this._renderTimer = null;\n          this._bounds = [];\n          this._capability.promise.finally(() => {\n            if (!this._enhanceTextSelection) {\n              this._textDivProperties = null;\n            }\n            if (this._layoutTextCtx) {\n              this._layoutTextCtx.canvas.width = 0;\n              this._layoutTextCtx.canvas.height = 0;\n              this._layoutTextCtx = null;\n            }\n          }).catch(() => {});\n        }\n        get promise() {\n          return this._capability.promise;\n        }\n        cancel() {\n          this._canceled = true;\n          if (this._reader) {\n            this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\")).catch(() => {});\n            this._reader = null;\n          }\n          if (this._renderTimer !== null) {\n            clearTimeout(this._renderTimer);\n            this._renderTimer = null;\n          }\n          this._capability.reject(new Error(\"TextLayer task cancelled.\"));\n        }\n        _processItems(items, styleCache) {\n          for (let i = 0, len = items.length; i < len; i++) {\n            if (items[i].str === undefined) {\n              if (items[i].type === \"beginMarkedContentProps\" || items[i].type === \"beginMarkedContent\") {\n                const parent = this._container;\n                this._container = document.createElement(\"span\");\n                this._container.classList.add(\"markedContent\");\n                if (items[i].id !== null) {\n                  this._container.setAttribute(\"id\", `${items[i].id}`);\n                }\n                parent.appendChild(this._container);\n              } else if (items[i].type === \"endMarkedContent\") {\n                this._container = this._container.parentNode;\n              }\n              continue;\n            }\n            this._textContentItemsStr.push(items[i].str);\n            appendText(this, items[i], styleCache, this._layoutTextCtx);\n          }\n        }\n        _layoutText(textDiv) {\n          const textDivProperties = this._textDivProperties.get(textDiv);\n          let transform = \"\";\n          if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {\n            const {\n              fontSize,\n              fontFamily\n            } = textDiv.style;\n            if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {\n              this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;\n              this._layoutTextLastFontSize = fontSize;\n              this._layoutTextLastFontFamily = fontFamily;\n            }\n            const {\n              width\n            } = this._layoutTextCtx.measureText(textDiv.textContent);\n            if (width > 0) {\n              const scale = textDivProperties.canvasWidth / width;\n              if (this._enhanceTextSelection) {\n                textDivProperties.scale = scale;\n              }\n              transform = `scaleX(${scale})`;\n            }\n          }\n          if (textDivProperties.angle !== 0) {\n            transform = `rotate(${textDivProperties.angle}deg) ${transform}`;\n          }\n          if (transform.length > 0) {\n            if (this._enhanceTextSelection) {\n              textDivProperties.originalTransform = transform;\n            }\n            textDiv.style.transform = transform;\n          }\n          if (textDivProperties.hasText) {\n            this._container.appendChild(textDiv);\n          }\n          if (textDivProperties.hasEOL) {\n            const br = document.createElement(\"br\");\n            br.setAttribute(\"role\", \"presentation\");\n            this._container.appendChild(br);\n          }\n        }\n        _render(timeout = 0) {\n          const capability = (0, _util.createPromiseCapability)();\n          let styleCache = Object.create(null);\n          const canvas = this._document.createElement(\"canvas\");\n          canvas.height = canvas.width = DEFAULT_FONT_SIZE;\n          canvas.mozOpaque = true;\n          this._layoutTextCtx = canvas.getContext(\"2d\", {\n            alpha: false\n          });\n          if (this._textContent) {\n            const textItems = this._textContent.items;\n            const textStyles = this._textContent.styles;\n            this._processItems(textItems, textStyles);\n            capability.resolve();\n          } else if (this._textContentStream) {\n            const pump = () => {\n              this._reader.read().then(({\n                value,\n                done\n              }) => {\n                if (done) {\n                  capability.resolve();\n                  return;\n                }\n                Object.assign(styleCache, value.styles);\n                this._processItems(value.items, styleCache);\n                pump();\n              }, capability.reject);\n            };\n            this._reader = this._textContentStream.getReader();\n            pump();\n          } else {\n            throw new Error('Neither \"textContent\" nor \"textContentStream\" parameters specified.');\n          }\n          capability.promise.then(() => {\n            styleCache = null;\n            if (!timeout) {\n              render(this);\n            } else {\n              this._renderTimer = setTimeout(() => {\n                render(this);\n                this._renderTimer = null;\n              }, timeout);\n            }\n          }, this._capability.reject);\n        }\n        expandTextDivs(expandDivs = false) {\n          if (!this._enhanceTextSelection || !this._renderingDone) {\n            return;\n          }\n          if (this._bounds !== null) {\n            expand(this);\n            this._bounds = null;\n          }\n          const transformBuf = [],\n            paddingBuf = [];\n          for (let i = 0, ii = this._textDivs.length; i < ii; i++) {\n            const div = this._textDivs[i];\n            const divProps = this._textDivProperties.get(div);\n            if (!divProps.hasText) {\n              continue;\n            }\n            if (expandDivs) {\n              transformBuf.length = 0;\n              paddingBuf.length = 0;\n              if (divProps.originalTransform) {\n                transformBuf.push(divProps.originalTransform);\n              }\n              if (divProps.paddingTop > 0) {\n                paddingBuf.push(`${divProps.paddingTop}px`);\n                transformBuf.push(`translateY(${-divProps.paddingTop}px)`);\n              } else {\n                paddingBuf.push(0);\n              }\n              if (divProps.paddingRight > 0) {\n                paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);\n              } else {\n                paddingBuf.push(0);\n              }\n              if (divProps.paddingBottom > 0) {\n                paddingBuf.push(`${divProps.paddingBottom}px`);\n              } else {\n                paddingBuf.push(0);\n              }\n              if (divProps.paddingLeft > 0) {\n                paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);\n                transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);\n              } else {\n                paddingBuf.push(0);\n              }\n              div.style.padding = paddingBuf.join(\" \");\n              if (transformBuf.length) {\n                div.style.transform = transformBuf.join(\" \");\n              }\n            } else {\n              div.style.padding = null;\n              div.style.transform = divProps.originalTransform;\n            }\n          }\n        }\n      }\n      function renderTextLayer(renderParameters) {\n        const task = new TextLayerRenderTask({\n          textContent: renderParameters.textContent,\n          textContentStream: renderParameters.textContentStream,\n          container: renderParameters.container,\n          viewport: renderParameters.viewport,\n          textDivs: renderParameters.textDivs,\n          textContentItemsStr: renderParameters.textContentItemsStr,\n          enhanceTextSelection: renderParameters.enhanceTextSelection\n        });\n        task._render(renderParameters.timeout);\n        return task;\n      }\n\n      /***/\n    }), (/* 22 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.SVGGraphics = void 0;\n      var _util = __w_pdfjs_require__(2);\n      var _display_utils = __w_pdfjs_require__(1);\n      var _is_node = __w_pdfjs_require__(4);\n      let SVGGraphics = class {\n        constructor() {\n          (0, _util.unreachable)(\"Not implemented: SVGGraphics\");\n        }\n      };\n      exports.SVGGraphics = SVGGraphics;\n      {\n        const SVG_DEFAULTS = {\n          fontStyle: \"normal\",\n          fontWeight: \"normal\",\n          fillColor: \"#000000\"\n        };\n        const XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n        const XLINK_NS = \"http://www.w3.org/1999/xlink\";\n        const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n        const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n        const convertImgDataToPng = function () {\n          const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n          const CHUNK_WRAPPER_SIZE = 12;\n          const crcTable = new Int32Array(256);\n          for (let i = 0; i < 256; i++) {\n            let c = i;\n            for (let h = 0; h < 8; h++) {\n              if (c & 1) {\n                c = 0xedb88320 ^ c >> 1 & 0x7fffffff;\n              } else {\n                c = c >> 1 & 0x7fffffff;\n              }\n            }\n            crcTable[i] = c;\n          }\n          function crc32(data, start, end) {\n            let crc = -1;\n            for (let i = start; i < end; i++) {\n              const a = (crc ^ data[i]) & 0xff;\n              const b = crcTable[a];\n              crc = crc >>> 8 ^ b;\n            }\n            return crc ^ -1;\n          }\n          function writePngChunk(type, body, data, offset) {\n            let p = offset;\n            const len = body.length;\n            data[p] = len >> 24 & 0xff;\n            data[p + 1] = len >> 16 & 0xff;\n            data[p + 2] = len >> 8 & 0xff;\n            data[p + 3] = len & 0xff;\n            p += 4;\n            data[p] = type.charCodeAt(0) & 0xff;\n            data[p + 1] = type.charCodeAt(1) & 0xff;\n            data[p + 2] = type.charCodeAt(2) & 0xff;\n            data[p + 3] = type.charCodeAt(3) & 0xff;\n            p += 4;\n            data.set(body, p);\n            p += body.length;\n            const crc = crc32(data, offset + 4, p);\n            data[p] = crc >> 24 & 0xff;\n            data[p + 1] = crc >> 16 & 0xff;\n            data[p + 2] = crc >> 8 & 0xff;\n            data[p + 3] = crc & 0xff;\n          }\n          function adler32(data, start, end) {\n            let a = 1;\n            let b = 0;\n            for (let i = start; i < end; ++i) {\n              a = (a + (data[i] & 0xff)) % 65521;\n              b = (b + a) % 65521;\n            }\n            return b << 16 | a;\n          }\n          function deflateSync(literals) {\n            if (!_is_node.isNodeJS) {\n              return deflateSyncUncompressed(literals);\n            }\n            try {\n              let input;\n              if (parseInt(process.versions.node) >= 8) {\n                input = literals;\n              } else {\n                input = Buffer.from(literals);\n              }\n              const output = require(\"zlib\").deflateSync(input, {\n                level: 9\n              });\n              return output instanceof Uint8Array ? output : new Uint8Array(output);\n            } catch (e) {\n              (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n            }\n            return deflateSyncUncompressed(literals);\n          }\n          function deflateSyncUncompressed(literals) {\n            let len = literals.length;\n            const maxBlockLength = 0xffff;\n            const deflateBlocks = Math.ceil(len / maxBlockLength);\n            const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n            let pi = 0;\n            idat[pi++] = 0x78;\n            idat[pi++] = 0x9c;\n            let pos = 0;\n            while (len > maxBlockLength) {\n              idat[pi++] = 0x00;\n              idat[pi++] = 0xff;\n              idat[pi++] = 0xff;\n              idat[pi++] = 0x00;\n              idat[pi++] = 0x00;\n              idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n              pi += maxBlockLength;\n              pos += maxBlockLength;\n              len -= maxBlockLength;\n            }\n            idat[pi++] = 0x01;\n            idat[pi++] = len & 0xff;\n            idat[pi++] = len >> 8 & 0xff;\n            idat[pi++] = ~len & 0xffff & 0xff;\n            idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n            idat.set(literals.subarray(pos), pi);\n            pi += literals.length - pos;\n            const adler = adler32(literals, 0, literals.length);\n            idat[pi++] = adler >> 24 & 0xff;\n            idat[pi++] = adler >> 16 & 0xff;\n            idat[pi++] = adler >> 8 & 0xff;\n            idat[pi++] = adler & 0xff;\n            return idat;\n          }\n          function encode(imgData, kind, forceDataSchema, isMask) {\n            const width = imgData.width;\n            const height = imgData.height;\n            let bitDepth, colorType, lineSize;\n            const bytes = imgData.data;\n            switch (kind) {\n              case _util.ImageKind.GRAYSCALE_1BPP:\n                colorType = 0;\n                bitDepth = 1;\n                lineSize = width + 7 >> 3;\n                break;\n              case _util.ImageKind.RGB_24BPP:\n                colorType = 2;\n                bitDepth = 8;\n                lineSize = width * 3;\n                break;\n              case _util.ImageKind.RGBA_32BPP:\n                colorType = 6;\n                bitDepth = 8;\n                lineSize = width * 4;\n                break;\n              default:\n                throw new Error(\"invalid format\");\n            }\n            const literals = new Uint8Array((1 + lineSize) * height);\n            let offsetLiterals = 0,\n              offsetBytes = 0;\n            for (let y = 0; y < height; ++y) {\n              literals[offsetLiterals++] = 0;\n              literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n              offsetBytes += lineSize;\n              offsetLiterals += lineSize;\n            }\n            if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n              offsetLiterals = 0;\n              for (let y = 0; y < height; y++) {\n                offsetLiterals++;\n                for (let i = 0; i < lineSize; i++) {\n                  literals[offsetLiterals++] ^= 0xff;\n                }\n              }\n            }\n            const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n            const idat = deflateSync(literals);\n            const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n            const data = new Uint8Array(pngLength);\n            let offset = 0;\n            data.set(PNG_HEADER, offset);\n            offset += PNG_HEADER.length;\n            writePngChunk(\"IHDR\", ihdr, data, offset);\n            offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n            writePngChunk(\"IDATA\", idat, data, offset);\n            offset += CHUNK_WRAPPER_SIZE + idat.length;\n            writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n            return (0, _util.createObjectURL)(data, \"image/png\", forceDataSchema);\n          }\n          return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n            const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n            return encode(imgData, kind, forceDataSchema, isMask);\n          };\n        }();\n        class SVGExtraState {\n          constructor() {\n            this.fontSizeScale = 1;\n            this.fontWeight = SVG_DEFAULTS.fontWeight;\n            this.fontSize = 0;\n            this.textMatrix = _util.IDENTITY_MATRIX;\n            this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n            this.leading = 0;\n            this.textRenderingMode = _util.TextRenderingMode.FILL;\n            this.textMatrixScale = 1;\n            this.x = 0;\n            this.y = 0;\n            this.lineX = 0;\n            this.lineY = 0;\n            this.charSpacing = 0;\n            this.wordSpacing = 0;\n            this.textHScale = 1;\n            this.textRise = 0;\n            this.fillColor = SVG_DEFAULTS.fillColor;\n            this.strokeColor = \"#000000\";\n            this.fillAlpha = 1;\n            this.strokeAlpha = 1;\n            this.lineWidth = 1;\n            this.lineJoin = \"\";\n            this.lineCap = \"\";\n            this.miterLimit = 0;\n            this.dashArray = [];\n            this.dashPhase = 0;\n            this.dependencies = [];\n            this.activeClipUrl = null;\n            this.clipGroup = null;\n            this.maskId = \"\";\n          }\n          clone() {\n            return Object.create(this);\n          }\n          setCurrentPoint(x, y) {\n            this.x = x;\n            this.y = y;\n          }\n        }\n        function opListToTree(opList) {\n          let opTree = [];\n          const tmp = [];\n          for (const opListElement of opList) {\n            if (opListElement.fn === \"save\") {\n              opTree.push({\n                fnId: 92,\n                fn: \"group\",\n                items: []\n              });\n              tmp.push(opTree);\n              opTree = opTree[opTree.length - 1].items;\n              continue;\n            }\n            if (opListElement.fn === \"restore\") {\n              opTree = tmp.pop();\n            } else {\n              opTree.push(opListElement);\n            }\n          }\n          return opTree;\n        }\n        function pf(value) {\n          if (Number.isInteger(value)) {\n            return value.toString();\n          }\n          const s = value.toFixed(10);\n          let i = s.length - 1;\n          if (s[i] !== \"0\") {\n            return s;\n          }\n          do {\n            i--;\n          } while (s[i] === \"0\");\n          return s.substring(0, s[i] === \".\" ? i : i + 1);\n        }\n        function pm(m) {\n          if (m[4] === 0 && m[5] === 0) {\n            if (m[1] === 0 && m[2] === 0) {\n              if (m[0] === 1 && m[3] === 1) {\n                return \"\";\n              }\n              return `scale(${pf(m[0])} ${pf(m[3])})`;\n            }\n            if (m[0] === m[3] && m[1] === -m[2]) {\n              const a = Math.acos(m[0]) * 180 / Math.PI;\n              return `rotate(${pf(a)})`;\n            }\n          } else {\n            if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n              return `translate(${pf(m[4])} ${pf(m[5])})`;\n            }\n          }\n          return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\n        }\n        let clipCount = 0;\n        let maskCount = 0;\n        let shadingCount = 0;\n        exports.SVGGraphics = SVGGraphics = class {\n          constructor(commonObjs, objs, forceDataSchema = false) {\n            this.svgFactory = new _display_utils.DOMSVGFactory();\n            this.current = new SVGExtraState();\n            this.transformMatrix = _util.IDENTITY_MATRIX;\n            this.transformStack = [];\n            this.extraStack = [];\n            this.commonObjs = commonObjs;\n            this.objs = objs;\n            this.pendingClip = null;\n            this.pendingEOFill = false;\n            this.embedFonts = false;\n            this.embeddedFonts = Object.create(null);\n            this.cssStyle = null;\n            this.forceDataSchema = !!forceDataSchema;\n            this._operatorIdMapping = [];\n            for (const op in _util.OPS) {\n              this._operatorIdMapping[_util.OPS[op]] = op;\n            }\n          }\n          save() {\n            this.transformStack.push(this.transformMatrix);\n            const old = this.current;\n            this.extraStack.push(old);\n            this.current = old.clone();\n          }\n          restore() {\n            this.transformMatrix = this.transformStack.pop();\n            this.current = this.extraStack.pop();\n            this.pendingClip = null;\n            this.tgrp = null;\n          }\n          group(items) {\n            this.save();\n            this.executeOpTree(items);\n            this.restore();\n          }\n          loadDependencies(operatorList) {\n            const fnArray = operatorList.fnArray;\n            const argsArray = operatorList.argsArray;\n            for (let i = 0, ii = fnArray.length; i < ii; i++) {\n              if (fnArray[i] !== _util.OPS.dependency) {\n                continue;\n              }\n              for (const obj of argsArray[i]) {\n                const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\n                const promise = new Promise(resolve => {\n                  objsPool.get(obj, resolve);\n                });\n                this.current.dependencies.push(promise);\n              }\n            }\n            return Promise.all(this.current.dependencies);\n          }\n          transform(a, b, c, d, e, f) {\n            const transformMatrix = [a, b, c, d, e, f];\n            this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n            this.tgrp = null;\n          }\n          getSVG(operatorList, viewport) {\n            this.viewport = viewport;\n            const svgElement = this._initialize(viewport);\n            return this.loadDependencies(operatorList).then(() => {\n              this.transformMatrix = _util.IDENTITY_MATRIX;\n              this.executeOpTree(this.convertOpList(operatorList));\n              return svgElement;\n            });\n          }\n          convertOpList(operatorList) {\n            const operatorIdMapping = this._operatorIdMapping;\n            const argsArray = operatorList.argsArray;\n            const fnArray = operatorList.fnArray;\n            const opList = [];\n            for (let i = 0, ii = fnArray.length; i < ii; i++) {\n              const fnId = fnArray[i];\n              opList.push({\n                fnId,\n                fn: operatorIdMapping[fnId],\n                args: argsArray[i]\n              });\n            }\n            return opListToTree(opList);\n          }\n          executeOpTree(opTree) {\n            for (const opTreeElement of opTree) {\n              const fn = opTreeElement.fn;\n              const fnId = opTreeElement.fnId;\n              const args = opTreeElement.args;\n              switch (fnId | 0) {\n                case _util.OPS.beginText:\n                  this.beginText();\n                  break;\n                case _util.OPS.dependency:\n                  break;\n                case _util.OPS.setLeading:\n                  this.setLeading(args);\n                  break;\n                case _util.OPS.setLeadingMoveText:\n                  this.setLeadingMoveText(args[0], args[1]);\n                  break;\n                case _util.OPS.setFont:\n                  this.setFont(args);\n                  break;\n                case _util.OPS.showText:\n                  this.showText(args[0]);\n                  break;\n                case _util.OPS.showSpacedText:\n                  this.showText(args[0]);\n                  break;\n                case _util.OPS.endText:\n                  this.endText();\n                  break;\n                case _util.OPS.moveText:\n                  this.moveText(args[0], args[1]);\n                  break;\n                case _util.OPS.setCharSpacing:\n                  this.setCharSpacing(args[0]);\n                  break;\n                case _util.OPS.setWordSpacing:\n                  this.setWordSpacing(args[0]);\n                  break;\n                case _util.OPS.setHScale:\n                  this.setHScale(args[0]);\n                  break;\n                case _util.OPS.setTextMatrix:\n                  this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n                  break;\n                case _util.OPS.setTextRise:\n                  this.setTextRise(args[0]);\n                  break;\n                case _util.OPS.setTextRenderingMode:\n                  this.setTextRenderingMode(args[0]);\n                  break;\n                case _util.OPS.setLineWidth:\n                  this.setLineWidth(args[0]);\n                  break;\n                case _util.OPS.setLineJoin:\n                  this.setLineJoin(args[0]);\n                  break;\n                case _util.OPS.setLineCap:\n                  this.setLineCap(args[0]);\n                  break;\n                case _util.OPS.setMiterLimit:\n                  this.setMiterLimit(args[0]);\n                  break;\n                case _util.OPS.setFillRGBColor:\n                  this.setFillRGBColor(args[0], args[1], args[2]);\n                  break;\n                case _util.OPS.setStrokeRGBColor:\n                  this.setStrokeRGBColor(args[0], args[1], args[2]);\n                  break;\n                case _util.OPS.setStrokeColorN:\n                  this.setStrokeColorN(args);\n                  break;\n                case _util.OPS.setFillColorN:\n                  this.setFillColorN(args);\n                  break;\n                case _util.OPS.shadingFill:\n                  this.shadingFill(args[0]);\n                  break;\n                case _util.OPS.setDash:\n                  this.setDash(args[0], args[1]);\n                  break;\n                case _util.OPS.setRenderingIntent:\n                  this.setRenderingIntent(args[0]);\n                  break;\n                case _util.OPS.setFlatness:\n                  this.setFlatness(args[0]);\n                  break;\n                case _util.OPS.setGState:\n                  this.setGState(args[0]);\n                  break;\n                case _util.OPS.fill:\n                  this.fill();\n                  break;\n                case _util.OPS.eoFill:\n                  this.eoFill();\n                  break;\n                case _util.OPS.stroke:\n                  this.stroke();\n                  break;\n                case _util.OPS.fillStroke:\n                  this.fillStroke();\n                  break;\n                case _util.OPS.eoFillStroke:\n                  this.eoFillStroke();\n                  break;\n                case _util.OPS.clip:\n                  this.clip(\"nonzero\");\n                  break;\n                case _util.OPS.eoClip:\n                  this.clip(\"evenodd\");\n                  break;\n                case _util.OPS.paintSolidColorImageMask:\n                  this.paintSolidColorImageMask();\n                  break;\n                case _util.OPS.paintImageXObject:\n                  this.paintImageXObject(args[0]);\n                  break;\n                case _util.OPS.paintInlineImageXObject:\n                  this.paintInlineImageXObject(args[0]);\n                  break;\n                case _util.OPS.paintImageMaskXObject:\n                  this.paintImageMaskXObject(args[0]);\n                  break;\n                case _util.OPS.paintFormXObjectBegin:\n                  this.paintFormXObjectBegin(args[0], args[1]);\n                  break;\n                case _util.OPS.paintFormXObjectEnd:\n                  this.paintFormXObjectEnd();\n                  break;\n                case _util.OPS.closePath:\n                  this.closePath();\n                  break;\n                case _util.OPS.closeStroke:\n                  this.closeStroke();\n                  break;\n                case _util.OPS.closeFillStroke:\n                  this.closeFillStroke();\n                  break;\n                case _util.OPS.closeEOFillStroke:\n                  this.closeEOFillStroke();\n                  break;\n                case _util.OPS.nextLine:\n                  this.nextLine();\n                  break;\n                case _util.OPS.transform:\n                  this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n                  break;\n                case _util.OPS.constructPath:\n                  this.constructPath(args[0], args[1]);\n                  break;\n                case _util.OPS.endPath:\n                  this.endPath();\n                  break;\n                case 92:\n                  this.group(opTreeElement.items);\n                  break;\n                default:\n                  (0, _util.warn)(`Unimplemented operator ${fn}`);\n                  break;\n              }\n            }\n          }\n          setWordSpacing(wordSpacing) {\n            this.current.wordSpacing = wordSpacing;\n          }\n          setCharSpacing(charSpacing) {\n            this.current.charSpacing = charSpacing;\n          }\n          nextLine() {\n            this.moveText(0, this.current.leading);\n          }\n          setTextMatrix(a, b, c, d, e, f) {\n            const current = this.current;\n            current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n            current.textMatrixScale = Math.hypot(a, b);\n            current.x = current.lineX = 0;\n            current.y = current.lineY = 0;\n            current.xcoords = [];\n            current.ycoords = [];\n            current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n            current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n            current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n            current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n            current.txtElement = this.svgFactory.createElement(\"svg:text\");\n            current.txtElement.appendChild(current.tspan);\n          }\n          beginText() {\n            const current = this.current;\n            current.x = current.lineX = 0;\n            current.y = current.lineY = 0;\n            current.textMatrix = _util.IDENTITY_MATRIX;\n            current.lineMatrix = _util.IDENTITY_MATRIX;\n            current.textMatrixScale = 1;\n            current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n            current.txtElement = this.svgFactory.createElement(\"svg:text\");\n            current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n            current.xcoords = [];\n            current.ycoords = [];\n          }\n          moveText(x, y) {\n            const current = this.current;\n            current.x = current.lineX += x;\n            current.y = current.lineY += y;\n            current.xcoords = [];\n            current.ycoords = [];\n            current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n            current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n            current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n            current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n          }\n          showText(glyphs) {\n            const current = this.current;\n            const font = current.font;\n            const fontSize = current.fontSize;\n            if (fontSize === 0) {\n              return;\n            }\n            const fontSizeScale = current.fontSizeScale;\n            const charSpacing = current.charSpacing;\n            const wordSpacing = current.wordSpacing;\n            const fontDirection = current.fontDirection;\n            const textHScale = current.textHScale * fontDirection;\n            const vertical = font.vertical;\n            const spacingDir = vertical ? 1 : -1;\n            const defaultVMetrics = font.defaultVMetrics;\n            const widthAdvanceScale = fontSize * current.fontMatrix[0];\n            let x = 0;\n            for (const glyph of glyphs) {\n              if (glyph === null) {\n                x += fontDirection * wordSpacing;\n                continue;\n              } else if ((0, _util.isNum)(glyph)) {\n                x += spacingDir * glyph * fontSize / 1000;\n                continue;\n              }\n              const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n              const character = glyph.fontChar;\n              let scaledX, scaledY;\n              let width = glyph.width;\n              if (vertical) {\n                let vx;\n                const vmetric = glyph.vmetric || defaultVMetrics;\n                vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n                vx = -vx * widthAdvanceScale;\n                const vy = vmetric[2] * widthAdvanceScale;\n                width = vmetric ? -vmetric[0] : width;\n                scaledX = vx / fontSizeScale;\n                scaledY = (x + vy) / fontSizeScale;\n              } else {\n                scaledX = x / fontSizeScale;\n                scaledY = 0;\n              }\n              if (glyph.isInFont || font.missingFile) {\n                current.xcoords.push(current.x + scaledX);\n                if (vertical) {\n                  current.ycoords.push(-current.y + scaledY);\n                }\n                current.tspan.textContent += character;\n              } else {}\n              let charWidth;\n              if (vertical) {\n                charWidth = width * widthAdvanceScale - spacing * fontDirection;\n              } else {\n                charWidth = width * widthAdvanceScale + spacing * fontDirection;\n              }\n              x += charWidth;\n            }\n            current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n            if (vertical) {\n              current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n            } else {\n              current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n            }\n            if (vertical) {\n              current.y -= x;\n            } else {\n              current.x += x * textHScale;\n            }\n            current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n            current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n            if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n              current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n            }\n            if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n              current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n            }\n            const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n            if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n              if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n                current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n              }\n              if (current.fillAlpha < 1) {\n                current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n              }\n            } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n              current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n            } else {\n              current.tspan.setAttributeNS(null, \"fill\", \"none\");\n            }\n            if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n              const lineWidthScale = 1 / (current.textMatrixScale || 1);\n              this._setStrokeAttributes(current.tspan, lineWidthScale);\n            }\n            let textMatrix = current.textMatrix;\n            if (current.textRise !== 0) {\n              textMatrix = textMatrix.slice();\n              textMatrix[5] += current.textRise;\n            }\n            current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\n            current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n            current.txtElement.appendChild(current.tspan);\n            current.txtgrp.appendChild(current.txtElement);\n            this._ensureTransformGroup().appendChild(current.txtElement);\n          }\n          setLeadingMoveText(x, y) {\n            this.setLeading(-y);\n            this.moveText(x, y);\n          }\n          addFontStyle(fontObj) {\n            if (!fontObj.data) {\n              throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n            }\n            if (!this.cssStyle) {\n              this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n              this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n              this.defs.appendChild(this.cssStyle);\n            }\n            const url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n            this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`;\n          }\n          setFont(details) {\n            const current = this.current;\n            const fontObj = this.commonObjs.get(details[0]);\n            let size = details[1];\n            current.font = fontObj;\n            if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n              this.addFontStyle(fontObj);\n              this.embeddedFonts[fontObj.loadedName] = fontObj;\n            }\n            current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n            let bold = \"normal\";\n            if (fontObj.black) {\n              bold = \"900\";\n            } else if (fontObj.bold) {\n              bold = \"bold\";\n            }\n            const italic = fontObj.italic ? \"italic\" : \"normal\";\n            if (size < 0) {\n              size = -size;\n              current.fontDirection = -1;\n            } else {\n              current.fontDirection = 1;\n            }\n            current.fontSize = size;\n            current.fontFamily = fontObj.loadedName;\n            current.fontWeight = bold;\n            current.fontStyle = italic;\n            current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n            current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n            current.xcoords = [];\n            current.ycoords = [];\n          }\n          endText() {\n            const current = this.current;\n            if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {\n              current.element = current.txtElement;\n              this.clip(\"nonzero\");\n              this.endPath();\n            }\n          }\n          setLineWidth(width) {\n            if (width > 0) {\n              this.current.lineWidth = width;\n            }\n          }\n          setLineCap(style) {\n            this.current.lineCap = LINE_CAP_STYLES[style];\n          }\n          setLineJoin(style) {\n            this.current.lineJoin = LINE_JOIN_STYLES[style];\n          }\n          setMiterLimit(limit) {\n            this.current.miterLimit = limit;\n          }\n          setStrokeAlpha(strokeAlpha) {\n            this.current.strokeAlpha = strokeAlpha;\n          }\n          setStrokeRGBColor(r, g, b) {\n            this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n          }\n          setFillAlpha(fillAlpha) {\n            this.current.fillAlpha = fillAlpha;\n          }\n          setFillRGBColor(r, g, b) {\n            this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n            this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n            this.current.xcoords = [];\n            this.current.ycoords = [];\n          }\n          setStrokeColorN(args) {\n            this.current.strokeColor = this._makeColorN_Pattern(args);\n          }\n          setFillColorN(args) {\n            this.current.fillColor = this._makeColorN_Pattern(args);\n          }\n          shadingFill(args) {\n            const width = this.viewport.width;\n            const height = this.viewport.height;\n            const inv = _util.Util.inverseTransform(this.transformMatrix);\n            const bl = _util.Util.applyTransform([0, 0], inv);\n            const br = _util.Util.applyTransform([0, height], inv);\n            const ul = _util.Util.applyTransform([width, 0], inv);\n            const ur = _util.Util.applyTransform([width, height], inv);\n            const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n            const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n            const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n            const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n            const rect = this.svgFactory.createElement(\"svg:rect\");\n            rect.setAttributeNS(null, \"x\", x0);\n            rect.setAttributeNS(null, \"y\", y0);\n            rect.setAttributeNS(null, \"width\", x1 - x0);\n            rect.setAttributeNS(null, \"height\", y1 - y0);\n            rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n            if (this.current.fillAlpha < 1) {\n              rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n            }\n            this._ensureTransformGroup().appendChild(rect);\n          }\n          _makeColorN_Pattern(args) {\n            if (args[0] === \"TilingPattern\") {\n              return this._makeTilingPattern(args);\n            }\n            return this._makeShadingPattern(args);\n          }\n          _makeTilingPattern(args) {\n            const color = args[1];\n            const operatorList = args[2];\n            const matrix = args[3] || _util.IDENTITY_MATRIX;\n            const [x0, y0, x1, y1] = args[4];\n            const xstep = args[5];\n            const ystep = args[6];\n            const paintType = args[7];\n            const tilingId = `shading${shadingCount++}`;\n            const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);\n            const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\n            const txstep = xstep * xscale;\n            const tystep = ystep * yscale;\n            const tiling = this.svgFactory.createElement(\"svg:pattern\");\n            tiling.setAttributeNS(null, \"id\", tilingId);\n            tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n            tiling.setAttributeNS(null, \"width\", txstep);\n            tiling.setAttributeNS(null, \"height\", tystep);\n            tiling.setAttributeNS(null, \"x\", `${tx0}`);\n            tiling.setAttributeNS(null, \"y\", `${ty0}`);\n            const svg = this.svg;\n            const transformMatrix = this.transformMatrix;\n            const fillColor = this.current.fillColor;\n            const strokeColor = this.current.strokeColor;\n            const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n            this.svg = bbox;\n            this.transformMatrix = matrix;\n            if (paintType === 2) {\n              const cssColor = _util.Util.makeHexColor(...color);\n              this.current.fillColor = cssColor;\n              this.current.strokeColor = cssColor;\n            }\n            this.executeOpTree(this.convertOpList(operatorList));\n            this.svg = svg;\n            this.transformMatrix = transformMatrix;\n            this.current.fillColor = fillColor;\n            this.current.strokeColor = strokeColor;\n            tiling.appendChild(bbox.childNodes[0]);\n            this.defs.appendChild(tiling);\n            return `url(#${tilingId})`;\n          }\n          _makeShadingPattern(args) {\n            if (typeof args === \"string\") {\n              args = this.objs.get(args);\n            }\n            switch (args[0]) {\n              case \"RadialAxial\":\n                const shadingId = `shading${shadingCount++}`;\n                const colorStops = args[3];\n                let gradient;\n                switch (args[1]) {\n                  case \"axial\":\n                    const point0 = args[4];\n                    const point1 = args[5];\n                    gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n                    gradient.setAttributeNS(null, \"id\", shadingId);\n                    gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                    gradient.setAttributeNS(null, \"x1\", point0[0]);\n                    gradient.setAttributeNS(null, \"y1\", point0[1]);\n                    gradient.setAttributeNS(null, \"x2\", point1[0]);\n                    gradient.setAttributeNS(null, \"y2\", point1[1]);\n                    break;\n                  case \"radial\":\n                    const focalPoint = args[4];\n                    const circlePoint = args[5];\n                    const focalRadius = args[6];\n                    const circleRadius = args[7];\n                    gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n                    gradient.setAttributeNS(null, \"id\", shadingId);\n                    gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                    gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n                    gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n                    gradient.setAttributeNS(null, \"r\", circleRadius);\n                    gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n                    gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n                    gradient.setAttributeNS(null, \"fr\", focalRadius);\n                    break;\n                  default:\n                    throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n                }\n                for (const colorStop of colorStops) {\n                  const stop = this.svgFactory.createElement(\"svg:stop\");\n                  stop.setAttributeNS(null, \"offset\", colorStop[0]);\n                  stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n                  gradient.appendChild(stop);\n                }\n                this.defs.appendChild(gradient);\n                return `url(#${shadingId})`;\n              case \"Mesh\":\n                (0, _util.warn)(\"Unimplemented pattern Mesh\");\n                return null;\n              case \"Dummy\":\n                return \"hotpink\";\n              default:\n                throw new Error(`Unknown IR type: ${args[0]}`);\n            }\n          }\n          setDash(dashArray, dashPhase) {\n            this.current.dashArray = dashArray;\n            this.current.dashPhase = dashPhase;\n          }\n          constructPath(ops, args) {\n            const current = this.current;\n            let x = current.x,\n              y = current.y;\n            let d = [];\n            let j = 0;\n            for (const op of ops) {\n              switch (op | 0) {\n                case _util.OPS.rectangle:\n                  x = args[j++];\n                  y = args[j++];\n                  const width = args[j++];\n                  const height = args[j++];\n                  const xw = x + width;\n                  const yh = y + height;\n                  d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n                  break;\n                case _util.OPS.moveTo:\n                  x = args[j++];\n                  y = args[j++];\n                  d.push(\"M\", pf(x), pf(y));\n                  break;\n                case _util.OPS.lineTo:\n                  x = args[j++];\n                  y = args[j++];\n                  d.push(\"L\", pf(x), pf(y));\n                  break;\n                case _util.OPS.curveTo:\n                  x = args[j + 4];\n                  y = args[j + 5];\n                  d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n                  j += 6;\n                  break;\n                case _util.OPS.curveTo2:\n                  d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n                  x = args[j + 2];\n                  y = args[j + 3];\n                  j += 4;\n                  break;\n                case _util.OPS.curveTo3:\n                  x = args[j + 2];\n                  y = args[j + 3];\n                  d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n                  j += 4;\n                  break;\n                case _util.OPS.closePath:\n                  d.push(\"Z\");\n                  break;\n              }\n            }\n            d = d.join(\" \");\n            if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n              d = current.path.getAttributeNS(null, \"d\") + d;\n            } else {\n              current.path = this.svgFactory.createElement(\"svg:path\");\n              this._ensureTransformGroup().appendChild(current.path);\n            }\n            current.path.setAttributeNS(null, \"d\", d);\n            current.path.setAttributeNS(null, \"fill\", \"none\");\n            current.element = current.path;\n            current.setCurrentPoint(x, y);\n          }\n          endPath() {\n            const current = this.current;\n            current.path = null;\n            if (!this.pendingClip) {\n              return;\n            }\n            if (!current.element) {\n              this.pendingClip = null;\n              return;\n            }\n            const clipId = `clippath${clipCount++}`;\n            const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n            clipPath.setAttributeNS(null, \"id\", clipId);\n            clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n            const clipElement = current.element.cloneNode(true);\n            if (this.pendingClip === \"evenodd\") {\n              clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n            } else {\n              clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n            }\n            this.pendingClip = null;\n            clipPath.appendChild(clipElement);\n            this.defs.appendChild(clipPath);\n            if (current.activeClipUrl) {\n              current.clipGroup = null;\n              for (const prev of this.extraStack) {\n                prev.clipGroup = null;\n              }\n              clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n            }\n            current.activeClipUrl = `url(#${clipId})`;\n            this.tgrp = null;\n          }\n          clip(type) {\n            this.pendingClip = type;\n          }\n          closePath() {\n            const current = this.current;\n            if (current.path) {\n              const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\n              current.path.setAttributeNS(null, \"d\", d);\n            }\n          }\n          setLeading(leading) {\n            this.current.leading = -leading;\n          }\n          setTextRise(textRise) {\n            this.current.textRise = textRise;\n          }\n          setTextRenderingMode(textRenderingMode) {\n            this.current.textRenderingMode = textRenderingMode;\n          }\n          setHScale(scale) {\n            this.current.textHScale = scale / 100;\n          }\n          setRenderingIntent(intent) {}\n          setFlatness(flatness) {}\n          setGState(states) {\n            for (const [key, value] of states) {\n              switch (key) {\n                case \"LW\":\n                  this.setLineWidth(value);\n                  break;\n                case \"LC\":\n                  this.setLineCap(value);\n                  break;\n                case \"LJ\":\n                  this.setLineJoin(value);\n                  break;\n                case \"ML\":\n                  this.setMiterLimit(value);\n                  break;\n                case \"D\":\n                  this.setDash(value[0], value[1]);\n                  break;\n                case \"RI\":\n                  this.setRenderingIntent(value);\n                  break;\n                case \"FL\":\n                  this.setFlatness(value);\n                  break;\n                case \"Font\":\n                  this.setFont(value);\n                  break;\n                case \"CA\":\n                  this.setStrokeAlpha(value);\n                  break;\n                case \"ca\":\n                  this.setFillAlpha(value);\n                  break;\n                default:\n                  (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\n                  break;\n              }\n            }\n          }\n          fill() {\n            const current = this.current;\n            if (current.element) {\n              current.element.setAttributeNS(null, \"fill\", current.fillColor);\n              current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n              this.endPath();\n            }\n          }\n          stroke() {\n            const current = this.current;\n            if (current.element) {\n              this._setStrokeAttributes(current.element);\n              current.element.setAttributeNS(null, \"fill\", \"none\");\n              this.endPath();\n            }\n          }\n          _setStrokeAttributes(element, lineWidthScale = 1) {\n            const current = this.current;\n            let dashArray = current.dashArray;\n            if (lineWidthScale !== 1 && dashArray.length > 0) {\n              dashArray = dashArray.map(function (value) {\n                return lineWidthScale * value;\n              });\n            }\n            element.setAttributeNS(null, \"stroke\", current.strokeColor);\n            element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n            element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n            element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n            element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n            element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n            element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n            element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n          }\n          eoFill() {\n            if (this.current.element) {\n              this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n            }\n            this.fill();\n          }\n          fillStroke() {\n            this.stroke();\n            this.fill();\n          }\n          eoFillStroke() {\n            if (this.current.element) {\n              this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n            }\n            this.fillStroke();\n          }\n          closeStroke() {\n            this.closePath();\n            this.stroke();\n          }\n          closeFillStroke() {\n            this.closePath();\n            this.fillStroke();\n          }\n          closeEOFillStroke() {\n            this.closePath();\n            this.eoFillStroke();\n          }\n          paintSolidColorImageMask() {\n            const rect = this.svgFactory.createElement(\"svg:rect\");\n            rect.setAttributeNS(null, \"x\", \"0\");\n            rect.setAttributeNS(null, \"y\", \"0\");\n            rect.setAttributeNS(null, \"width\", \"1px\");\n            rect.setAttributeNS(null, \"height\", \"1px\");\n            rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n            this._ensureTransformGroup().appendChild(rect);\n          }\n          paintImageXObject(objId) {\n            const imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n            if (!imgData) {\n              (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\n              return;\n            }\n            this.paintInlineImageXObject(imgData);\n          }\n          paintInlineImageXObject(imgData, mask) {\n            const width = imgData.width;\n            const height = imgData.height;\n            const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n            const cliprect = this.svgFactory.createElement(\"svg:rect\");\n            cliprect.setAttributeNS(null, \"x\", \"0\");\n            cliprect.setAttributeNS(null, \"y\", \"0\");\n            cliprect.setAttributeNS(null, \"width\", pf(width));\n            cliprect.setAttributeNS(null, \"height\", pf(height));\n            this.current.element = cliprect;\n            this.clip(\"nonzero\");\n            const imgEl = this.svgFactory.createElement(\"svg:image\");\n            imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n            imgEl.setAttributeNS(null, \"x\", \"0\");\n            imgEl.setAttributeNS(null, \"y\", pf(-height));\n            imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n            imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n            imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\n            if (mask) {\n              mask.appendChild(imgEl);\n            } else {\n              this._ensureTransformGroup().appendChild(imgEl);\n            }\n          }\n          paintImageMaskXObject(imgData) {\n            const current = this.current;\n            const width = imgData.width;\n            const height = imgData.height;\n            const fillColor = current.fillColor;\n            current.maskId = `mask${maskCount++}`;\n            const mask = this.svgFactory.createElement(\"svg:mask\");\n            mask.setAttributeNS(null, \"id\", current.maskId);\n            const rect = this.svgFactory.createElement(\"svg:rect\");\n            rect.setAttributeNS(null, \"x\", \"0\");\n            rect.setAttributeNS(null, \"y\", \"0\");\n            rect.setAttributeNS(null, \"width\", pf(width));\n            rect.setAttributeNS(null, \"height\", pf(height));\n            rect.setAttributeNS(null, \"fill\", fillColor);\n            rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\n            this.defs.appendChild(mask);\n            this._ensureTransformGroup().appendChild(rect);\n            this.paintInlineImageXObject(imgData, mask);\n          }\n          paintFormXObjectBegin(matrix, bbox) {\n            if (Array.isArray(matrix) && matrix.length === 6) {\n              this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n            }\n            if (bbox) {\n              const width = bbox[2] - bbox[0];\n              const height = bbox[3] - bbox[1];\n              const cliprect = this.svgFactory.createElement(\"svg:rect\");\n              cliprect.setAttributeNS(null, \"x\", bbox[0]);\n              cliprect.setAttributeNS(null, \"y\", bbox[1]);\n              cliprect.setAttributeNS(null, \"width\", pf(width));\n              cliprect.setAttributeNS(null, \"height\", pf(height));\n              this.current.element = cliprect;\n              this.clip(\"nonzero\");\n              this.endPath();\n            }\n          }\n          paintFormXObjectEnd() {}\n          _initialize(viewport) {\n            const svg = this.svgFactory.create(viewport.width, viewport.height);\n            const definitions = this.svgFactory.createElement(\"svg:defs\");\n            svg.appendChild(definitions);\n            this.defs = definitions;\n            const rootGroup = this.svgFactory.createElement(\"svg:g\");\n            rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n            svg.appendChild(rootGroup);\n            this.svg = rootGroup;\n            return svg;\n          }\n          _ensureClipGroup() {\n            if (!this.current.clipGroup) {\n              const clipGroup = this.svgFactory.createElement(\"svg:g\");\n              clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n              this.svg.appendChild(clipGroup);\n              this.current.clipGroup = clipGroup;\n            }\n            return this.current.clipGroup;\n          }\n          _ensureTransformGroup() {\n            if (!this.tgrp) {\n              this.tgrp = this.svgFactory.createElement(\"svg:g\");\n              this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n              if (this.current.activeClipUrl) {\n                this._ensureClipGroup().appendChild(this.tgrp);\n              } else {\n                this.svg.appendChild(this.tgrp);\n              }\n            }\n            return this.tgrp;\n          }\n        };\n      }\n\n      /***/\n    }), (/* 23 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.PDFNodeStream = void 0;\n      var _util = __w_pdfjs_require__(2);\n      var _network_utils = __w_pdfjs_require__(24);\n      ;\n      const fs = require(\"fs\");\n      const http = require(\"http\");\n      const https = require(\"https\");\n      const url = require(\"url\");\n      const fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n      function parseUrl(sourceUrl) {\n        const parsedUrl = url.parse(sourceUrl);\n        if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n          return parsedUrl;\n        }\n        if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n          return url.parse(`file:///${sourceUrl}`);\n        }\n        if (!parsedUrl.host) {\n          parsedUrl.protocol = \"file:\";\n        }\n        return parsedUrl;\n      }\n      class PDFNodeStream {\n        constructor(source) {\n          this.source = source;\n          this.url = parseUrl(source.url);\n          this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n          this.isFsUrl = this.url.protocol === \"file:\";\n          this.httpHeaders = this.isHttp && source.httpHeaders || {};\n          this._fullRequestReader = null;\n          this._rangeRequestReaders = [];\n        }\n        get _progressiveDataLength() {\n          return this._fullRequestReader?._loaded ?? 0;\n        }\n        getFullReader() {\n          (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n          this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n          return this._fullRequestReader;\n        }\n        getRangeReader(start, end) {\n          if (end <= this._progressiveDataLength) {\n            return null;\n          }\n          const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n          this._rangeRequestReaders.push(rangeReader);\n          return rangeReader;\n        }\n        cancelAllRequests(reason) {\n          if (this._fullRequestReader) {\n            this._fullRequestReader.cancel(reason);\n          }\n          for (const reader of this._rangeRequestReaders.slice(0)) {\n            reader.cancel(reason);\n          }\n        }\n      }\n      exports.PDFNodeStream = PDFNodeStream;\n      class BaseFullReader {\n        constructor(stream) {\n          this._url = stream.url;\n          this._done = false;\n          this._storedError = null;\n          this.onProgress = null;\n          const source = stream.source;\n          this._contentLength = source.length;\n          this._loaded = 0;\n          this._filename = null;\n          this._disableRange = source.disableRange || false;\n          this._rangeChunkSize = source.rangeChunkSize;\n          if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n          }\n          this._isStreamingSupported = !source.disableStream;\n          this._isRangeSupported = !source.disableRange;\n          this._readableStream = null;\n          this._readCapability = (0, _util.createPromiseCapability)();\n          this._headersCapability = (0, _util.createPromiseCapability)();\n        }\n        get headersReady() {\n          return this._headersCapability.promise;\n        }\n        get filename() {\n          return this._filename;\n        }\n        get contentLength() {\n          return this._contentLength;\n        }\n        get isRangeSupported() {\n          return this._isRangeSupported;\n        }\n        get isStreamingSupported() {\n          return this._isStreamingSupported;\n        }\n        async read() {\n          await this._readCapability.promise;\n          if (this._done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          if (this._storedError) {\n            throw this._storedError;\n          }\n          const chunk = this._readableStream.read();\n          if (chunk === null) {\n            this._readCapability = (0, _util.createPromiseCapability)();\n            return this.read();\n          }\n          this._loaded += chunk.length;\n          if (this.onProgress) {\n            this.onProgress({\n              loaded: this._loaded,\n              total: this._contentLength\n            });\n          }\n          const buffer = new Uint8Array(chunk).buffer;\n          return {\n            value: buffer,\n            done: false\n          };\n        }\n        cancel(reason) {\n          if (!this._readableStream) {\n            this._error(reason);\n            return;\n          }\n          this._readableStream.destroy(reason);\n        }\n        _error(reason) {\n          this._storedError = reason;\n          this._readCapability.resolve();\n        }\n        _setReadableStream(readableStream) {\n          this._readableStream = readableStream;\n          readableStream.on(\"readable\", () => {\n            this._readCapability.resolve();\n          });\n          readableStream.on(\"end\", () => {\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n          });\n          readableStream.on(\"error\", reason => {\n            this._error(reason);\n          });\n          if (!this._isStreamingSupported && this._isRangeSupported) {\n            this._error(new _util.AbortException(\"streaming is disabled\"));\n          }\n          if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n          }\n        }\n      }\n      class BaseRangeReader {\n        constructor(stream) {\n          this._url = stream.url;\n          this._done = false;\n          this._storedError = null;\n          this.onProgress = null;\n          this._loaded = 0;\n          this._readableStream = null;\n          this._readCapability = (0, _util.createPromiseCapability)();\n          const source = stream.source;\n          this._isStreamingSupported = !source.disableStream;\n        }\n        get isStreamingSupported() {\n          return this._isStreamingSupported;\n        }\n        async read() {\n          await this._readCapability.promise;\n          if (this._done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          if (this._storedError) {\n            throw this._storedError;\n          }\n          const chunk = this._readableStream.read();\n          if (chunk === null) {\n            this._readCapability = (0, _util.createPromiseCapability)();\n            return this.read();\n          }\n          this._loaded += chunk.length;\n          if (this.onProgress) {\n            this.onProgress({\n              loaded: this._loaded\n            });\n          }\n          const buffer = new Uint8Array(chunk).buffer;\n          return {\n            value: buffer,\n            done: false\n          };\n        }\n        cancel(reason) {\n          if (!this._readableStream) {\n            this._error(reason);\n            return;\n          }\n          this._readableStream.destroy(reason);\n        }\n        _error(reason) {\n          this._storedError = reason;\n          this._readCapability.resolve();\n        }\n        _setReadableStream(readableStream) {\n          this._readableStream = readableStream;\n          readableStream.on(\"readable\", () => {\n            this._readCapability.resolve();\n          });\n          readableStream.on(\"end\", () => {\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n          });\n          readableStream.on(\"error\", reason => {\n            this._error(reason);\n          });\n          if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n          }\n        }\n      }\n      function createRequestOptions(parsedUrl, headers) {\n        return {\n          protocol: parsedUrl.protocol,\n          auth: parsedUrl.auth,\n          host: parsedUrl.hostname,\n          port: parsedUrl.port,\n          path: parsedUrl.path,\n          method: \"GET\",\n          headers\n        };\n      }\n      class PDFNodeStreamFullReader extends BaseFullReader {\n        constructor(stream) {\n          super(stream);\n          const handleResponse = response => {\n            if (response.statusCode === 404) {\n              const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n              this._storedError = error;\n              this._headersCapability.reject(error);\n              return;\n            }\n            this._headersCapability.resolve();\n            this._setReadableStream(response);\n            const getResponseHeader = name => {\n              return this._readableStream.headers[name.toLowerCase()];\n            };\n            const {\n              allowRangeRequests,\n              suggestedLength\n            } = (0, _network_utils.validateRangeRequestCapabilities)({\n              getResponseHeader,\n              isHttp: stream.isHttp,\n              rangeChunkSize: this._rangeChunkSize,\n              disableRange: this._disableRange\n            });\n            this._isRangeSupported = allowRangeRequests;\n            this._contentLength = suggestedLength || this._contentLength;\n            this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n          };\n          this._request = null;\n          if (this._url.protocol === \"http:\") {\n            this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n          } else {\n            this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n          }\n          this._request.on(\"error\", reason => {\n            this._storedError = reason;\n            this._headersCapability.reject(reason);\n          });\n          this._request.end();\n        }\n      }\n      class PDFNodeStreamRangeReader extends BaseRangeReader {\n        constructor(stream, start, end) {\n          super(stream);\n          this._httpHeaders = {};\n          for (const property in stream.httpHeaders) {\n            const value = stream.httpHeaders[property];\n            if (typeof value === \"undefined\") {\n              continue;\n            }\n            this._httpHeaders[property] = value;\n          }\n          this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n          const handleResponse = response => {\n            if (response.statusCode === 404) {\n              const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n              this._storedError = error;\n              return;\n            }\n            this._setReadableStream(response);\n          };\n          this._request = null;\n          if (this._url.protocol === \"http:\") {\n            this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n          } else {\n            this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n          }\n          this._request.on(\"error\", reason => {\n            this._storedError = reason;\n          });\n          this._request.end();\n        }\n      }\n      class PDFNodeStreamFsFullReader extends BaseFullReader {\n        constructor(stream) {\n          super(stream);\n          let path = decodeURIComponent(this._url.path);\n          if (fileUriRegex.test(this._url.href)) {\n            path = path.replace(/^\\//, \"\");\n          }\n          fs.lstat(path, (error, stat) => {\n            if (error) {\n              if (error.code === \"ENOENT\") {\n                error = new _util.MissingPDFException(`Missing PDF \"${path}\".`);\n              }\n              this._storedError = error;\n              this._headersCapability.reject(error);\n              return;\n            }\n            this._contentLength = stat.size;\n            this._setReadableStream(fs.createReadStream(path));\n            this._headersCapability.resolve();\n          });\n        }\n      }\n      class PDFNodeStreamFsRangeReader extends BaseRangeReader {\n        constructor(stream, start, end) {\n          super(stream);\n          let path = decodeURIComponent(this._url.path);\n          if (fileUriRegex.test(this._url.href)) {\n            path = path.replace(/^\\//, \"\");\n          }\n          this._setReadableStream(fs.createReadStream(path, {\n            start,\n            end: end - 1\n          }));\n        }\n      }\n\n      /***/\n    }), (/* 24 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.createResponseStatusError = createResponseStatusError;\n      exports.extractFilenameFromHeader = extractFilenameFromHeader;\n      exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\n      exports.validateResponseStatus = validateResponseStatus;\n      var _util = __w_pdfjs_require__(2);\n      var _content_disposition = __w_pdfjs_require__(25);\n      var _display_utils = __w_pdfjs_require__(1);\n      function validateRangeRequestCapabilities({\n        getResponseHeader,\n        isHttp,\n        rangeChunkSize,\n        disableRange\n      }) {\n        (0, _util.assert)(rangeChunkSize > 0, \"Range chunk size must be larger than zero\");\n        const returnValues = {\n          allowRangeRequests: false,\n          suggestedLength: undefined\n        };\n        const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n        if (!Number.isInteger(length)) {\n          return returnValues;\n        }\n        returnValues.suggestedLength = length;\n        if (length <= 2 * rangeChunkSize) {\n          return returnValues;\n        }\n        if (disableRange || !isHttp) {\n          return returnValues;\n        }\n        if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n          return returnValues;\n        }\n        const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n        if (contentEncoding !== \"identity\") {\n          return returnValues;\n        }\n        returnValues.allowRangeRequests = true;\n        return returnValues;\n      }\n      function extractFilenameFromHeader(getResponseHeader) {\n        const contentDisposition = getResponseHeader(\"Content-Disposition\");\n        if (contentDisposition) {\n          let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n          if (filename.includes(\"%\")) {\n            try {\n              filename = decodeURIComponent(filename);\n            } catch (ex) {}\n          }\n          if ((0, _display_utils.isPdfFile)(filename)) {\n            return filename;\n          }\n        }\n        return null;\n      }\n      function createResponseStatusError(status, url) {\n        if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n          return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n        }\n        return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n      }\n      function validateResponseStatus(status) {\n        return status === 200 || status === 206;\n      }\n\n      /***/\n    }), (/* 25 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n      var _util = __w_pdfjs_require__(2);\n      function getFilenameFromContentDispositionHeader(contentDisposition) {\n        let needsEncodingFixup = true;\n        let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n        if (tmp) {\n          tmp = tmp[1];\n          let filename = rfc2616unquote(tmp);\n          filename = unescape(filename);\n          filename = rfc5987decode(filename);\n          filename = rfc2047decode(filename);\n          return fixupEncoding(filename);\n        }\n        tmp = rfc2231getparam(contentDisposition);\n        if (tmp) {\n          const filename = rfc2047decode(tmp);\n          return fixupEncoding(filename);\n        }\n        tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n        if (tmp) {\n          tmp = tmp[1];\n          let filename = rfc2616unquote(tmp);\n          filename = rfc2047decode(filename);\n          return fixupEncoding(filename);\n        }\n        function toParamRegExp(attributePattern, flags) {\n          return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n        }\n        function textdecode(encoding, value) {\n          if (encoding) {\n            if (!/^[\\x00-\\xFF]+$/.test(value)) {\n              return value;\n            }\n            try {\n              const decoder = new TextDecoder(encoding, {\n                fatal: true\n              });\n              const buffer = (0, _util.stringToBytes)(value);\n              value = decoder.decode(buffer);\n              needsEncodingFixup = false;\n            } catch (e) {\n              if (/^utf-?8$/i.test(encoding)) {\n                try {\n                  value = decodeURIComponent(escape(value));\n                  needsEncodingFixup = false;\n                } catch (err) {}\n              }\n            }\n          }\n          return value;\n        }\n        function fixupEncoding(value) {\n          if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n            value = textdecode(\"utf-8\", value);\n            if (needsEncodingFixup) {\n              value = textdecode(\"iso-8859-1\", value);\n            }\n          }\n          return value;\n        }\n        function rfc2231getparam(contentDispositionStr) {\n          const matches = [];\n          let match;\n          const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n          while ((match = iter.exec(contentDispositionStr)) !== null) {\n            let [, n, quot, part] = match;\n            n = parseInt(n, 10);\n            if (n in matches) {\n              if (n === 0) {\n                break;\n              }\n              continue;\n            }\n            matches[n] = [quot, part];\n          }\n          const parts = [];\n          for (let n = 0; n < matches.length; ++n) {\n            if (!(n in matches)) {\n              break;\n            }\n            let [quot, part] = matches[n];\n            part = rfc2616unquote(part);\n            if (quot) {\n              part = unescape(part);\n              if (n === 0) {\n                part = rfc5987decode(part);\n              }\n            }\n            parts.push(part);\n          }\n          return parts.join(\"\");\n        }\n        function rfc2616unquote(value) {\n          if (value.startsWith('\"')) {\n            const parts = value.slice(1).split('\\\\\"');\n            for (let i = 0; i < parts.length; ++i) {\n              const quotindex = parts[i].indexOf('\"');\n              if (quotindex !== -1) {\n                parts[i] = parts[i].slice(0, quotindex);\n                parts.length = i + 1;\n              }\n              parts[i] = parts[i].replace(/\\\\(.)/g, \"$1\");\n            }\n            value = parts.join('\"');\n          }\n          return value;\n        }\n        function rfc5987decode(extvalue) {\n          const encodingend = extvalue.indexOf(\"'\");\n          if (encodingend === -1) {\n            return extvalue;\n          }\n          const encoding = extvalue.slice(0, encodingend);\n          const langvalue = extvalue.slice(encodingend + 1);\n          const value = langvalue.replace(/^[^']*'/, \"\");\n          return textdecode(encoding, value);\n        }\n        function rfc2047decode(value) {\n          if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n            return value;\n          }\n          return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n            if (encoding === \"q\" || encoding === \"Q\") {\n              text = text.replace(/_/g, \" \");\n              text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n                return String.fromCharCode(parseInt(hex, 16));\n              });\n              return textdecode(charset, text);\n            }\n            try {\n              text = atob(text);\n            } catch (e) {}\n            return textdecode(charset, text);\n          });\n        }\n        return \"\";\n      }\n\n      /***/\n    }), (/* 26 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.PDFNetworkStream = void 0;\n      var _util = __w_pdfjs_require__(2);\n      var _network_utils = __w_pdfjs_require__(24);\n      ;\n      const OK_RESPONSE = 200;\n      const PARTIAL_CONTENT_RESPONSE = 206;\n      function getArrayBuffer(xhr) {\n        const data = xhr.response;\n        if (typeof data !== \"string\") {\n          return data;\n        }\n        const array = (0, _util.stringToBytes)(data);\n        return array.buffer;\n      }\n      class NetworkManager {\n        constructor(url, args = {}) {\n          this.url = url;\n          this.isHttp = /^https?:/i.test(url);\n          this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);\n          this.withCredentials = args.withCredentials || false;\n          this.getXhr = args.getXhr || function NetworkManager_getXhr() {\n            return new XMLHttpRequest();\n          };\n          this.currXhrId = 0;\n          this.pendingRequests = Object.create(null);\n        }\n        requestRange(begin, end, listeners) {\n          const args = {\n            begin,\n            end\n          };\n          for (const prop in listeners) {\n            args[prop] = listeners[prop];\n          }\n          return this.request(args);\n        }\n        requestFull(listeners) {\n          return this.request(listeners);\n        }\n        request(args) {\n          const xhr = this.getXhr();\n          const xhrId = this.currXhrId++;\n          const pendingRequest = this.pendingRequests[xhrId] = {\n            xhr\n          };\n          xhr.open(\"GET\", this.url);\n          xhr.withCredentials = this.withCredentials;\n          for (const property in this.httpHeaders) {\n            const value = this.httpHeaders[property];\n            if (typeof value === \"undefined\") {\n              continue;\n            }\n            xhr.setRequestHeader(property, value);\n          }\n          if (this.isHttp && \"begin\" in args && \"end\" in args) {\n            xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n          } else {\n            pendingRequest.expectedStatus = OK_RESPONSE;\n          }\n          xhr.responseType = \"arraybuffer\";\n          if (args.onError) {\n            xhr.onerror = function (evt) {\n              args.onError(xhr.status);\n            };\n          }\n          xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n          xhr.onprogress = this.onProgress.bind(this, xhrId);\n          pendingRequest.onHeadersReceived = args.onHeadersReceived;\n          pendingRequest.onDone = args.onDone;\n          pendingRequest.onError = args.onError;\n          pendingRequest.onProgress = args.onProgress;\n          xhr.send(null);\n          return xhrId;\n        }\n        onProgress(xhrId, evt) {\n          const pendingRequest = this.pendingRequests[xhrId];\n          if (!pendingRequest) {\n            return;\n          }\n          pendingRequest.onProgress?.(evt);\n        }\n        onStateChange(xhrId, evt) {\n          const pendingRequest = this.pendingRequests[xhrId];\n          if (!pendingRequest) {\n            return;\n          }\n          const xhr = pendingRequest.xhr;\n          if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n            pendingRequest.onHeadersReceived();\n            delete pendingRequest.onHeadersReceived;\n          }\n          if (xhr.readyState !== 4) {\n            return;\n          }\n          if (!(xhrId in this.pendingRequests)) {\n            return;\n          }\n          delete this.pendingRequests[xhrId];\n          if (xhr.status === 0 && this.isHttp) {\n            pendingRequest.onError?.(xhr.status);\n            return;\n          }\n          const xhrStatus = xhr.status || OK_RESPONSE;\n          const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n          if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n            pendingRequest.onError?.(xhr.status);\n            return;\n          }\n          const chunk = getArrayBuffer(xhr);\n          if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n            const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n            const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n            pendingRequest.onDone({\n              begin: parseInt(matches[1], 10),\n              chunk\n            });\n          } else if (chunk) {\n            pendingRequest.onDone({\n              begin: 0,\n              chunk\n            });\n          } else {\n            pendingRequest.onError?.(xhr.status);\n          }\n        }\n        getRequestXhr(xhrId) {\n          return this.pendingRequests[xhrId].xhr;\n        }\n        isPendingRequest(xhrId) {\n          return xhrId in this.pendingRequests;\n        }\n        abortRequest(xhrId) {\n          const xhr = this.pendingRequests[xhrId].xhr;\n          delete this.pendingRequests[xhrId];\n          xhr.abort();\n        }\n      }\n      class PDFNetworkStream {\n        constructor(source) {\n          this._source = source;\n          this._manager = new NetworkManager(source.url, {\n            httpHeaders: source.httpHeaders,\n            withCredentials: source.withCredentials\n          });\n          this._rangeChunkSize = source.rangeChunkSize;\n          this._fullRequestReader = null;\n          this._rangeRequestReaders = [];\n        }\n        _onRangeRequestReaderClosed(reader) {\n          const i = this._rangeRequestReaders.indexOf(reader);\n          if (i >= 0) {\n            this._rangeRequestReaders.splice(i, 1);\n          }\n        }\n        getFullReader() {\n          (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n          this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n          return this._fullRequestReader;\n        }\n        getRangeReader(begin, end) {\n          const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n          reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n          this._rangeRequestReaders.push(reader);\n          return reader;\n        }\n        cancelAllRequests(reason) {\n          this._fullRequestReader?.cancel(reason);\n          for (const reader of this._rangeRequestReaders.slice(0)) {\n            reader.cancel(reason);\n          }\n        }\n      }\n      exports.PDFNetworkStream = PDFNetworkStream;\n      class PDFNetworkStreamFullRequestReader {\n        constructor(manager, source) {\n          this._manager = manager;\n          const args = {\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n          };\n          this._url = source.url;\n          this._fullRequestId = manager.requestFull(args);\n          this._headersReceivedCapability = (0, _util.createPromiseCapability)();\n          this._disableRange = source.disableRange || false;\n          this._contentLength = source.length;\n          this._rangeChunkSize = source.rangeChunkSize;\n          if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n          }\n          this._isStreamingSupported = false;\n          this._isRangeSupported = false;\n          this._cachedChunks = [];\n          this._requests = [];\n          this._done = false;\n          this._storedError = undefined;\n          this._filename = null;\n          this.onProgress = null;\n        }\n        _onHeadersReceived() {\n          const fullRequestXhrId = this._fullRequestId;\n          const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n          const getResponseHeader = name => {\n            return fullRequestXhr.getResponseHeader(name);\n          };\n          const {\n            allowRangeRequests,\n            suggestedLength\n          } = (0, _network_utils.validateRangeRequestCapabilities)({\n            getResponseHeader,\n            isHttp: this._manager.isHttp,\n            rangeChunkSize: this._rangeChunkSize,\n            disableRange: this._disableRange\n          });\n          if (allowRangeRequests) {\n            this._isRangeSupported = true;\n          }\n          this._contentLength = suggestedLength || this._contentLength;\n          this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n          if (this._isRangeSupported) {\n            this._manager.abortRequest(fullRequestXhrId);\n          }\n          this._headersReceivedCapability.resolve();\n        }\n        _onDone(data) {\n          if (data) {\n            if (this._requests.length > 0) {\n              const requestCapability = this._requests.shift();\n              requestCapability.resolve({\n                value: data.chunk,\n                done: false\n              });\n            } else {\n              this._cachedChunks.push(data.chunk);\n            }\n          }\n          this._done = true;\n          if (this._cachedChunks.length > 0) {\n            return;\n          }\n          for (const requestCapability of this._requests) {\n            requestCapability.resolve({\n              value: undefined,\n              done: true\n            });\n          }\n          this._requests.length = 0;\n        }\n        _onError(status) {\n          this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n          this._headersReceivedCapability.reject(this._storedError);\n          for (const requestCapability of this._requests) {\n            requestCapability.reject(this._storedError);\n          }\n          this._requests.length = 0;\n          this._cachedChunks.length = 0;\n        }\n        _onProgress(evt) {\n          this.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.lengthComputable ? evt.total : this._contentLength\n          });\n        }\n        get filename() {\n          return this._filename;\n        }\n        get isRangeSupported() {\n          return this._isRangeSupported;\n        }\n        get isStreamingSupported() {\n          return this._isStreamingSupported;\n        }\n        get contentLength() {\n          return this._contentLength;\n        }\n        get headersReady() {\n          return this._headersReceivedCapability.promise;\n        }\n        async read() {\n          if (this._storedError) {\n            throw this._storedError;\n          }\n          if (this._cachedChunks.length > 0) {\n            const chunk = this._cachedChunks.shift();\n            return {\n              value: chunk,\n              done: false\n            };\n          }\n          if (this._done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          const requestCapability = (0, _util.createPromiseCapability)();\n          this._requests.push(requestCapability);\n          return requestCapability.promise;\n        }\n        cancel(reason) {\n          this._done = true;\n          this._headersReceivedCapability.reject(reason);\n          for (const requestCapability of this._requests) {\n            requestCapability.resolve({\n              value: undefined,\n              done: true\n            });\n          }\n          this._requests.length = 0;\n          if (this._manager.isPendingRequest(this._fullRequestId)) {\n            this._manager.abortRequest(this._fullRequestId);\n          }\n          this._fullRequestReader = null;\n        }\n      }\n      class PDFNetworkStreamRangeRequestReader {\n        constructor(manager, begin, end) {\n          this._manager = manager;\n          const args = {\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n          };\n          this._url = manager.url;\n          this._requestId = manager.requestRange(begin, end, args);\n          this._requests = [];\n          this._queuedChunk = null;\n          this._done = false;\n          this._storedError = undefined;\n          this.onProgress = null;\n          this.onClosed = null;\n        }\n        _close() {\n          this.onClosed?.(this);\n        }\n        _onDone(data) {\n          const chunk = data.chunk;\n          if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n              value: chunk,\n              done: false\n            });\n          } else {\n            this._queuedChunk = chunk;\n          }\n          this._done = true;\n          for (const requestCapability of this._requests) {\n            requestCapability.resolve({\n              value: undefined,\n              done: true\n            });\n          }\n          this._requests.length = 0;\n          this._close();\n        }\n        _onError(status) {\n          this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n          for (const requestCapability of this._requests) {\n            requestCapability.reject(this._storedError);\n          }\n          this._requests.length = 0;\n          this._queuedChunk = null;\n        }\n        _onProgress(evt) {\n          if (!this.isStreamingSupported) {\n            this.onProgress?.({\n              loaded: evt.loaded\n            });\n          }\n        }\n        get isStreamingSupported() {\n          return false;\n        }\n        async read() {\n          if (this._storedError) {\n            throw this._storedError;\n          }\n          if (this._queuedChunk !== null) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n              value: chunk,\n              done: false\n            };\n          }\n          if (this._done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          const requestCapability = (0, _util.createPromiseCapability)();\n          this._requests.push(requestCapability);\n          return requestCapability.promise;\n        }\n        cancel(reason) {\n          this._done = true;\n          for (const requestCapability of this._requests) {\n            requestCapability.resolve({\n              value: undefined,\n              done: true\n            });\n          }\n          this._requests.length = 0;\n          if (this._manager.isPendingRequest(this._requestId)) {\n            this._manager.abortRequest(this._requestId);\n          }\n          this._close();\n        }\n      }\n\n      /***/\n    }), (/* 27 */\n    /***/(__unused_webpack_module, exports, __w_pdfjs_require__) => {\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.PDFFetchStream = void 0;\n      var _util = __w_pdfjs_require__(2);\n      var _network_utils = __w_pdfjs_require__(24);\n      ;\n      function createFetchOptions(headers, withCredentials, abortController) {\n        return {\n          method: \"GET\",\n          headers,\n          signal: abortController?.signal,\n          mode: \"cors\",\n          credentials: withCredentials ? \"include\" : \"same-origin\",\n          redirect: \"follow\"\n        };\n      }\n      function createHeaders(httpHeaders) {\n        const headers = new Headers();\n        for (const property in httpHeaders) {\n          const value = httpHeaders[property];\n          if (typeof value === \"undefined\") {\n            continue;\n          }\n          headers.append(property, value);\n        }\n        return headers;\n      }\n      class PDFFetchStream {\n        constructor(source) {\n          this.source = source;\n          this.isHttp = /^https?:/i.test(source.url);\n          this.httpHeaders = this.isHttp && source.httpHeaders || {};\n          this._fullRequestReader = null;\n          this._rangeRequestReaders = [];\n        }\n        get _progressiveDataLength() {\n          return this._fullRequestReader?._loaded ?? 0;\n        }\n        getFullReader() {\n          (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n          this._fullRequestReader = new PDFFetchStreamReader(this);\n          return this._fullRequestReader;\n        }\n        getRangeReader(begin, end) {\n          if (end <= this._progressiveDataLength) {\n            return null;\n          }\n          const reader = new PDFFetchStreamRangeReader(this, begin, end);\n          this._rangeRequestReaders.push(reader);\n          return reader;\n        }\n        cancelAllRequests(reason) {\n          if (this._fullRequestReader) {\n            this._fullRequestReader.cancel(reason);\n          }\n          for (const reader of this._rangeRequestReaders.slice(0)) {\n            reader.cancel(reason);\n          }\n        }\n      }\n      exports.PDFFetchStream = PDFFetchStream;\n      class PDFFetchStreamReader {\n        constructor(stream) {\n          this._stream = stream;\n          this._reader = null;\n          this._loaded = 0;\n          this._filename = null;\n          const source = stream.source;\n          this._withCredentials = source.withCredentials || false;\n          this._contentLength = source.length;\n          this._headersCapability = (0, _util.createPromiseCapability)();\n          this._disableRange = source.disableRange || false;\n          this._rangeChunkSize = source.rangeChunkSize;\n          if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n          }\n          if (typeof AbortController !== \"undefined\") {\n            this._abortController = new AbortController();\n          }\n          this._isStreamingSupported = !source.disableStream;\n          this._isRangeSupported = !source.disableRange;\n          this._headers = createHeaders(this._stream.httpHeaders);\n          const url = source.url;\n          fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n            if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n              throw (0, _network_utils.createResponseStatusError)(response.status, url);\n            }\n            this._reader = response.body.getReader();\n            this._headersCapability.resolve();\n            const getResponseHeader = name => {\n              return response.headers.get(name);\n            };\n            const {\n              allowRangeRequests,\n              suggestedLength\n            } = (0, _network_utils.validateRangeRequestCapabilities)({\n              getResponseHeader,\n              isHttp: this._stream.isHttp,\n              rangeChunkSize: this._rangeChunkSize,\n              disableRange: this._disableRange\n            });\n            this._isRangeSupported = allowRangeRequests;\n            this._contentLength = suggestedLength || this._contentLength;\n            this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n            if (!this._isStreamingSupported && this._isRangeSupported) {\n              this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n            }\n          }).catch(this._headersCapability.reject);\n          this.onProgress = null;\n        }\n        get headersReady() {\n          return this._headersCapability.promise;\n        }\n        get filename() {\n          return this._filename;\n        }\n        get contentLength() {\n          return this._contentLength;\n        }\n        get isRangeSupported() {\n          return this._isRangeSupported;\n        }\n        get isStreamingSupported() {\n          return this._isStreamingSupported;\n        }\n        async read() {\n          await this._headersCapability.promise;\n          const {\n            value,\n            done\n          } = await this._reader.read();\n          if (done) {\n            return {\n              value,\n              done\n            };\n          }\n          this._loaded += value.byteLength;\n          if (this.onProgress) {\n            this.onProgress({\n              loaded: this._loaded,\n              total: this._contentLength\n            });\n          }\n          const buffer = new Uint8Array(value).buffer;\n          return {\n            value: buffer,\n            done: false\n          };\n        }\n        cancel(reason) {\n          if (this._reader) {\n            this._reader.cancel(reason);\n          }\n          if (this._abortController) {\n            this._abortController.abort();\n          }\n        }\n      }\n      class PDFFetchStreamRangeReader {\n        constructor(stream, begin, end) {\n          this._stream = stream;\n          this._reader = null;\n          this._loaded = 0;\n          const source = stream.source;\n          this._withCredentials = source.withCredentials || false;\n          this._readCapability = (0, _util.createPromiseCapability)();\n          this._isStreamingSupported = !source.disableStream;\n          if (typeof AbortController !== \"undefined\") {\n            this._abortController = new AbortController();\n          }\n          this._headers = createHeaders(this._stream.httpHeaders);\n          this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n          const url = source.url;\n          fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n            if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n              throw (0, _network_utils.createResponseStatusError)(response.status, url);\n            }\n            this._readCapability.resolve();\n            this._reader = response.body.getReader();\n          }).catch(this._readCapability.reject);\n          this.onProgress = null;\n        }\n        get isStreamingSupported() {\n          return this._isStreamingSupported;\n        }\n        async read() {\n          await this._readCapability.promise;\n          const {\n            value,\n            done\n          } = await this._reader.read();\n          if (done) {\n            return {\n              value,\n              done\n            };\n          }\n          this._loaded += value.byteLength;\n          if (this.onProgress) {\n            this.onProgress({\n              loaded: this._loaded\n            });\n          }\n          const buffer = new Uint8Array(value).buffer;\n          return {\n            value: buffer,\n            done: false\n          };\n        }\n        cancel(reason) {\n          if (this._reader) {\n            this._reader.cancel(reason);\n          }\n          if (this._abortController) {\n            this._abortController.abort();\n          }\n        }\n      }\n\n      /***/\n    }\n    /******/)];\n    /************************************************************************/\n    /******/ // The module cache\n    /******/\n    var __webpack_module_cache__ = {};\n    /******/\n    /******/ // The require function\n    /******/\n    function __w_pdfjs_require__(moduleId) {\n      /******/ // Check if module is in cache\n      /******/var cachedModule = __webpack_module_cache__[moduleId];\n      /******/\n      if (cachedModule !== undefined) {\n        /******/return cachedModule.exports;\n        /******/\n      }\n      /******/ // Create a new module (and put it into the cache)\n      /******/\n      var module = __webpack_module_cache__[moduleId] = {\n        /******/ // no module.id needed\n        /******/ // no module.loaded needed\n        /******/exports: {}\n        /******/\n      };\n      /******/\n      /******/ // Execute the module function\n      /******/\n      __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);\n      /******/\n      /******/ // Return the exports of the module\n      /******/\n      return module.exports;\n      /******/\n    }\n    /******/\n    /************************************************************************/\n    var __webpack_exports__ = {};\n    // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n    (() => {\n      var exports = __webpack_exports__;\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      Object.defineProperty(exports, \"AnnotationLayer\", {\n        enumerable: true,\n        get: function () {\n          return _annotation_layer.AnnotationLayer;\n        }\n      });\n      Object.defineProperty(exports, \"AnnotationMode\", {\n        enumerable: true,\n        get: function () {\n          return _util.AnnotationMode;\n        }\n      });\n      Object.defineProperty(exports, \"CMapCompressionType\", {\n        enumerable: true,\n        get: function () {\n          return _util.CMapCompressionType;\n        }\n      });\n      Object.defineProperty(exports, \"GlobalWorkerOptions\", {\n        enumerable: true,\n        get: function () {\n          return _worker_options.GlobalWorkerOptions;\n        }\n      });\n      Object.defineProperty(exports, \"InvalidPDFException\", {\n        enumerable: true,\n        get: function () {\n          return _util.InvalidPDFException;\n        }\n      });\n      Object.defineProperty(exports, \"LinkTarget\", {\n        enumerable: true,\n        get: function () {\n          return _display_utils.LinkTarget;\n        }\n      });\n      Object.defineProperty(exports, \"LoopbackPort\", {\n        enumerable: true,\n        get: function () {\n          return _api.LoopbackPort;\n        }\n      });\n      Object.defineProperty(exports, \"MissingPDFException\", {\n        enumerable: true,\n        get: function () {\n          return _util.MissingPDFException;\n        }\n      });\n      Object.defineProperty(exports, \"OPS\", {\n        enumerable: true,\n        get: function () {\n          return _util.OPS;\n        }\n      });\n      Object.defineProperty(exports, \"PDFDataRangeTransport\", {\n        enumerable: true,\n        get: function () {\n          return _api.PDFDataRangeTransport;\n        }\n      });\n      Object.defineProperty(exports, \"PDFDateString\", {\n        enumerable: true,\n        get: function () {\n          return _display_utils.PDFDateString;\n        }\n      });\n      Object.defineProperty(exports, \"PDFWorker\", {\n        enumerable: true,\n        get: function () {\n          return _api.PDFWorker;\n        }\n      });\n      Object.defineProperty(exports, \"PasswordResponses\", {\n        enumerable: true,\n        get: function () {\n          return _util.PasswordResponses;\n        }\n      });\n      Object.defineProperty(exports, \"PermissionFlag\", {\n        enumerable: true,\n        get: function () {\n          return _util.PermissionFlag;\n        }\n      });\n      Object.defineProperty(exports, \"PixelsPerInch\", {\n        enumerable: true,\n        get: function () {\n          return _display_utils.PixelsPerInch;\n        }\n      });\n      Object.defineProperty(exports, \"RenderingCancelledException\", {\n        enumerable: true,\n        get: function () {\n          return _display_utils.RenderingCancelledException;\n        }\n      });\n      Object.defineProperty(exports, \"SVGGraphics\", {\n        enumerable: true,\n        get: function () {\n          return _svg.SVGGraphics;\n        }\n      });\n      Object.defineProperty(exports, \"UNSUPPORTED_FEATURES\", {\n        enumerable: true,\n        get: function () {\n          return _util.UNSUPPORTED_FEATURES;\n        }\n      });\n      Object.defineProperty(exports, \"UnexpectedResponseException\", {\n        enumerable: true,\n        get: function () {\n          return _util.UnexpectedResponseException;\n        }\n      });\n      Object.defineProperty(exports, \"Util\", {\n        enumerable: true,\n        get: function () {\n          return _util.Util;\n        }\n      });\n      Object.defineProperty(exports, \"VerbosityLevel\", {\n        enumerable: true,\n        get: function () {\n          return _util.VerbosityLevel;\n        }\n      });\n      Object.defineProperty(exports, \"XfaLayer\", {\n        enumerable: true,\n        get: function () {\n          return _xfa_layer.XfaLayer;\n        }\n      });\n      Object.defineProperty(exports, \"addLinkAttributes\", {\n        enumerable: true,\n        get: function () {\n          return _display_utils.addLinkAttributes;\n        }\n      });\n      Object.defineProperty(exports, \"build\", {\n        enumerable: true,\n        get: function () {\n          return _api.build;\n        }\n      });\n      Object.defineProperty(exports, \"createObjectURL\", {\n        enumerable: true,\n        get: function () {\n          return _util.createObjectURL;\n        }\n      });\n      Object.defineProperty(exports, \"createPromiseCapability\", {\n        enumerable: true,\n        get: function () {\n          return _util.createPromiseCapability;\n        }\n      });\n      Object.defineProperty(exports, \"createValidAbsoluteUrl\", {\n        enumerable: true,\n        get: function () {\n          return _util.createValidAbsoluteUrl;\n        }\n      });\n      Object.defineProperty(exports, \"getDocument\", {\n        enumerable: true,\n        get: function () {\n          return _api.getDocument;\n        }\n      });\n      Object.defineProperty(exports, \"getFilenameFromUrl\", {\n        enumerable: true,\n        get: function () {\n          return _display_utils.getFilenameFromUrl;\n        }\n      });\n      Object.defineProperty(exports, \"getPdfFilenameFromUrl\", {\n        enumerable: true,\n        get: function () {\n          return _display_utils.getPdfFilenameFromUrl;\n        }\n      });\n      Object.defineProperty(exports, \"getXfaPageViewport\", {\n        enumerable: true,\n        get: function () {\n          return _display_utils.getXfaPageViewport;\n        }\n      });\n      Object.defineProperty(exports, \"isPdfFile\", {\n        enumerable: true,\n        get: function () {\n          return _display_utils.isPdfFile;\n        }\n      });\n      Object.defineProperty(exports, \"loadScript\", {\n        enumerable: true,\n        get: function () {\n          return _display_utils.loadScript;\n        }\n      });\n      Object.defineProperty(exports, \"removeNullCharacters\", {\n        enumerable: true,\n        get: function () {\n          return _util.removeNullCharacters;\n        }\n      });\n      Object.defineProperty(exports, \"renderTextLayer\", {\n        enumerable: true,\n        get: function () {\n          return _text_layer.renderTextLayer;\n        }\n      });\n      Object.defineProperty(exports, \"shadow\", {\n        enumerable: true,\n        get: function () {\n          return _util.shadow;\n        }\n      });\n      Object.defineProperty(exports, \"version\", {\n        enumerable: true,\n        get: function () {\n          return _api.version;\n        }\n      });\n      var _display_utils = __w_pdfjs_require__(1);\n      var _util = __w_pdfjs_require__(2);\n      var _api = __w_pdfjs_require__(6);\n      var _annotation_layer = __w_pdfjs_require__(18);\n      var _worker_options = __w_pdfjs_require__(12);\n      var _is_node = __w_pdfjs_require__(4);\n      var _text_layer = __w_pdfjs_require__(21);\n      var _svg = __w_pdfjs_require__(22);\n      var _xfa_layer = __w_pdfjs_require__(20);\n      const pdfjsVersion = '2.12.313';\n      const pdfjsBuild = 'a2ae56f39';\n      {\n        if (_is_node.isNodeJS) {\n          const {\n            PDFNodeStream\n          } = __w_pdfjs_require__(23);\n          (0, _api.setPDFNetworkStreamFactory)(params => {\n            return new PDFNodeStream(params);\n          });\n        } else {\n          const {\n            PDFNetworkStream\n          } = __w_pdfjs_require__(26);\n          const {\n            PDFFetchStream\n          } = __w_pdfjs_require__(27);\n          (0, _api.setPDFNetworkStreamFactory)(params => {\n            if ((0, _display_utils.isValidFetchUrl)(params.url)) {\n              return new PDFFetchStream(params);\n            }\n            return new PDFNetworkStream(params);\n          });\n        }\n      }\n    })();\n\n    /******/\n    return __webpack_exports__;\n    /******/\n  })();\n});","map":{"version":3,"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","pdfjsLib","_util","__w_pdfjs_require__","_base_factory","DEFAULT_LINK_REL","SVG_NS","PixelsPerInch","CSS","PDF","PDF_TO_CSS_UNITS","shadow","DOMCanvasFactory","BaseCanvasFactory","constructor","ownerDocument","globalThis","document","_document","_createCanvas","width","height","canvas","createElement","fetchData","url","asTypedArray","isValidFetchUrl","baseURI","response","fetch","ok","Error","statusText","Uint8Array","arrayBuffer","stringToBytes","text","Promise","resolve","reject","request","XMLHttpRequest","open","responseType","onreadystatechange","readyState","DONE","status","data","responseText","send","DOMCMapReaderFactory","BaseCMapReaderFactory","_fetchData","compressionType","isCompressed","then","cMapData","DOMStandardFontDataFactory","BaseStandardFontDataFactory","DOMSVGFactory","BaseSVGFactory","_createSVG","type","createElementNS","PageViewport","viewBox","scale","rotation","offsetX","offsetY","dontFlip","centerX","centerY","rotateA","rotateB","rotateC","rotateD","offsetCanvasX","offsetCanvasY","Math","abs","transform","clone","slice","convertToViewportPoint","x","y","Util","applyTransform","convertToViewportRectangle","rect","topLeft","bottomRight","convertToPdfPoint","applyInverseTransform","RenderingCancelledException","BaseException","msg","LinkTarget","NONE","SELF","BLANK","PARENT","TOP","addLinkAttributes","link","target","rel","enabled","assert","urlNullRemoved","removeNullCharacters","href","title","onclick","targetStr","isDataScheme","ii","length","i","trim","substring","toLowerCase","isPdfFile","filename","test","getFilenameFromUrl","anchor","indexOf","query","end","min","lastIndexOf","getPdfFilenameFromUrl","defaultFilename","warn","reURI","reFilename","splitURI","exec","suggestedFilename","includes","decodeURIComponent","ex","StatTimer","started","Object","create","times","time","name","Date","now","timeEnd","push","start","toString","outBuf","longest","duration","padEnd","join","baseUrl","protocol","URL","loadScript","src","removeScriptElement","script","onload","evt","remove","onerror","head","documentElement","appendChild","deprecated","details","console","log","pdfDateStringRegex","PDFDateString","toDateObject","input","isString","RegExp","matches","year","parseInt","month","day","hour","minute","second","universalTimeRelation","offsetHour","offsetMinute","UTC","getXfaPageViewport","xfaPage","attributes","style","IDENTITY_MATRIX","FONT_IDENTITY_MATRIX","RenderingIntentFlag","ANY","DISPLAY","PRINT","ANNOTATIONS_FORMS","ANNOTATIONS_STORAGE","ANNOTATIONS_DISABLE","OPLIST","AnnotationMode","DISABLE","ENABLE","ENABLE_FORMS","ENABLE_STORAGE","PermissionFlag","MODIFY_CONTENTS","COPY","MODIFY_ANNOTATIONS","FILL_INTERACTIVE_FORMS","COPY_FOR_ACCESSIBILITY","ASSEMBLE","PRINT_HIGH_QUALITY","TextRenderingMode","FILL","STROKE","FILL_STROKE","INVISIBLE","FILL_ADD_TO_PATH","STROKE_ADD_TO_PATH","FILL_STROKE_ADD_TO_PATH","ADD_TO_PATH","FILL_STROKE_MASK","ADD_TO_PATH_FLAG","ImageKind","GRAYSCALE_1BPP","RGB_24BPP","RGBA_32BPP","AnnotationType","TEXT","LINK","FREETEXT","LINE","SQUARE","CIRCLE","POLYGON","POLYLINE","HIGHLIGHT","UNDERLINE","SQUIGGLY","STRIKEOUT","STAMP","CARET","INK","POPUP","FILEATTACHMENT","SOUND","MOVIE","WIDGET","SCREEN","PRINTERMARK","TRAPNET","WATERMARK","THREED","REDACT","AnnotationStateModelType","MARKED","REVIEW","AnnotationMarkedState","UNMARKED","AnnotationReviewState","ACCEPTED","REJECTED","CANCELLED","COMPLETED","AnnotationReplyType","GROUP","REPLY","AnnotationFlag","HIDDEN","NOZOOM","NOROTATE","NOVIEW","READONLY","LOCKED","TOGGLENOVIEW","LOCKEDCONTENTS","AnnotationFieldFlag","REQUIRED","NOEXPORT","MULTILINE","PASSWORD","NOTOGGLETOOFF","RADIO","PUSHBUTTON","COMBO","EDIT","SORT","FILESELECT","MULTISELECT","DONOTSPELLCHECK","DONOTSCROLL","COMB","RICHTEXT","RADIOSINUNISON","COMMITONSELCHANGE","AnnotationBorderStyleType","SOLID","DASHED","BEVELED","INSET","AnnotationActionEventType","E","X","D","U","Fo","Bl","PO","PC","PV","PI","K","F","V","C","DocumentActionEventType","WC","WS","DS","WP","DP","PageActionEventType","O","StreamType","UNKNOWN","FLATE","LZW","DCT","JPX","JBIG","A85","AHX","CCF","RLX","FontType","TYPE1","TYPE1STANDARD","TYPE1C","CIDFONTTYPE0","CIDFONTTYPE0C","TRUETYPE","CIDFONTTYPE2","TYPE3","OPENTYPE","TYPE0","MMTYPE1","VerbosityLevel","ERRORS","WARNINGS","INFOS","CMapCompressionType","BINARY","STREAM","OPS","dependency","setLineWidth","setLineCap","setLineJoin","setMiterLimit","setDash","setRenderingIntent","setFlatness","setGState","save","restore","moveTo","lineTo","curveTo","curveTo2","curveTo3","closePath","rectangle","stroke","closeStroke","fill","eoFill","fillStroke","eoFillStroke","closeFillStroke","closeEOFillStroke","endPath","clip","eoClip","beginText","endText","setCharSpacing","setWordSpacing","setHScale","setLeading","setFont","setTextRenderingMode","setTextRise","moveText","setLeadingMoveText","setTextMatrix","nextLine","showText","showSpacedText","nextLineShowText","nextLineSetSpacingShowText","setCharWidth","setCharWidthAndBounds","setStrokeColorSpace","setFillColorSpace","setStrokeColor","setStrokeColorN","setFillColor","setFillColorN","setStrokeGray","setFillGray","setStrokeRGBColor","setFillRGBColor","setStrokeCMYKColor","setFillCMYKColor","shadingFill","beginInlineImage","beginImageData","endInlineImage","paintXObject","markPoint","markPointProps","beginMarkedContent","beginMarkedContentProps","endMarkedContent","beginCompat","endCompat","paintFormXObjectBegin","paintFormXObjectEnd","beginGroup","endGroup","beginAnnotations","endAnnotations","beginAnnotation","endAnnotation","paintJpegXObject","paintImageMaskXObject","paintImageMaskXObjectGroup","paintImageXObject","paintInlineImageXObject","paintInlineImageXObjectGroup","paintImageXObjectRepeat","paintImageMaskXObjectRepeat","paintSolidColorImageMask","constructPath","UNSUPPORTED_FEATURES","unknown","forms","javaScript","signatures","smask","shadingPattern","font","errorTilingPattern","errorExtGState","errorXObject","errorFontLoadType3","errorFontState","errorFontMissing","errorFontTranslate","errorColorSpace","errorOperatorList","errorFontToUnicode","errorFontLoadNative","errorFontBuildPath","errorFontGetPath","errorMarkedContent","errorContentSubStream","PasswordResponses","NEED_PASSWORD","INCORRECT_PASSWORD","verbosity","setVerbosityLevel","level","Number","isInteger","getVerbosityLevel","info","unreachable","cond","isSameOrigin","otherUrl","base","origin","e","other","_isValidProtocol","createValidAbsoluteUrl","options","addDefaultProtocol","startsWith","dots","match","tryConvertEncoding","stringToUTF8String","absoluteUrl","obj","prop","value","defineProperty","enumerable","configurable","writable","BaseExceptionClosure","message","prototype","PasswordException","code","UnknownErrorException","InvalidPDFException","MissingPDFException","UnexpectedResponseException","FormatError","AbortException","NullCharactersRegExp","InvisibleCharactersRegExp","str","replaceInvisible","replace","bytesToString","bytes","undefined","MAX_ARGUMENT_COUNT","String","fromCharCode","apply","strBuf","chunkEnd","chunk","subarray","charCodeAt","arrayByteLength","arr","byteLength","arraysToBytes","resultLength","pos","item","itemLength","set","string32","objectSize","keys","objectFromMap","map","key","isLittleEndian","buffer8","view32","Uint32Array","buffer","IsLittleEndianCached","isEvalSupported","Function","IsEvalSupportedCached","hexNumbers","Array","n","padStart","makeHexColor","r","g","b","m1","m2","p","m","xt","yt","d","getAxialAlignedBoundingBox","p1","p2","p3","p4","max","inverseTransform","apply3dTransform","v","singularValueDecompose2dScale","transpose","a","c","first","sqrt","sx","sy","normalizeRect","intersect","rect1","rect2","compare","orderedX","sort","orderedY","result","bezierBoundingBox","x0","y0","x1","y1","x2","y2","x3","y3","tvalues","bounds","t","t1","t2","b2ac","sqrtb2ac","j","mt","jlen","PDFStringTranslateTable","stringToPDFString","charAt","escapeString","isAscii","stringToUTF16BEString","buf","char","escape","utf8StringToString","unescape","encodeURIComponent","isBool","isNum","isArrayBuffer","isArrayEqual","arr1","arr2","getModificationDate","date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","createPromiseCapability","capability","isSettled","get","promise","reason","createObjectURL","contentType","forceDataSchema","Blob","digits","b1","b2","b3","d1","d2","d3","d4","_is_node","isNodeJS","process","versions","nw","electron","context","getContext","reset","canvasAndContext","destroy","catch","svg","setAttribute","_display_utils","_font_loader","_node_utils","_annotation_storage","_canvas","_worker_options","_message_handler","_metadata","_optional_content_config","_transport_stream","_xfa_text","DEFAULT_RANGE_CHUNK_SIZE","RENDERING_CANCELLED_TIMEOUT","DefaultCanvasFactory","NodeCanvasFactory","DefaultCMapReaderFactory","NodeCMapReaderFactory","DefaultStandardFontDataFactory","NodeStandardFontDataFactory","createPDFNetworkStream","setPDFNetworkStreamFactory","pdfNetworkStreamFactory","getDocument","task","PDFDocumentLoadingTask","source","PDFDataRangeTransport","range","params","rangeTransport","worker","window","location","Buffer","isNaN","rangeChunkSize","CMapReaderFactory","StandardFontDataFactory","ignoreErrors","stopAtErrors","fontExtraProperties","pdfBug","enableXfa","docBaseUrl","maxImageSize","useWorkerFetch","disableFontFace","useSystemFonts","disableRange","disableStream","disableAutoFetch","workerParams","port","GlobalWorkerOptions","workerPort","PDFWorker","fromPort","_worker","docId","destroyed","workerIdPromise","_fetchDocument","networkStreamPromise","networkStream","PDFDataTransportStream","initialData","progressiveDone","contentDispositionFilename","httpHeaders","withCredentials","all","workerId","messageHandler","MessageHandler","transport","WorkerTransport","_transport","_capability","pdfDataRangeTransport","sendWithPromise","apiVersion","password","cMapUrl","standardFontDataUrl","idCounters","doc","onPassword","onProgress","onUnsupportedFeature","_rangeListeners","_progressListeners","_progressiveReadListeners","_progressiveDoneListeners","_readyCapability","addRangeListener","listener","addProgressListener","addProgressiveReadListener","addProgressiveDoneListener","onDataRange","begin","onDataProgress","loaded","total","onDataProgressiveRead","onDataProgressiveDone","transportReady","requestDataRange","abort","PDFDocumentProxy","pdfInfo","_pdfInfo","fingerprints","stats","streamTypes","fontTypes","annotationStorage","numPages","isPureXfa","_htmlForXfa","allXfaHtml","getPage","pageNumber","getPageIndex","ref","getDestinations","getDestination","id","getPageLabels","getPageLayout","getPageMode","getViewerPreferences","getOpenAction","getAttachments","getJavaScript","getJSActions","getDocJSActions","getOutline","getOptionalContentConfig","getPermissions","getMetadata","getMarkInfo","getData","getDownloadInfo","downloadInfoCapability","cleanup","keepLoadedFonts","startCleanup","loadingTask","loadingParams","saveDocument","size","getFieldObjects","hasJSActions","getCalculationOrderIds","PDFPageProxy","pageIndex","pageInfo","_pageIndex","_pageInfo","_ownerDocument","_stats","_pdfBug","commonObjs","objs","PDFObjects","cleanupAfterRender","pendingCleanup","_intentStates","Map","_annotationPromises","rotate","userUnit","view","getViewport","getAnnotations","intent","intentArgs","getRenderingIntent","cacheKey","renderingIntent","annotations","annotation","titleObj","contentsObj","_jsActionsPromise","getPageJSActions","getXfa","children","render","canvasContext","viewport","annotationMode","imageLayer","canvasFactory","background","optionalContentConfigPromise","annotationCanvasMap","arguments","renderInteractiveForms","includeAnnotationStorage","intentState","streamReaderCancelTimeout","clearTimeout","canvasFactoryInstance","intentPrint","displayReadyCapability","operatorList","fnArray","argsArray","lastChunk","_pumpOperatorList","complete","error","renderTasks","delete","internalRenderTask","_tryCleanup","_abortOperatorList","InternalRenderTask","callback","useRequestAnimationFrame","Set","add","renderTask","transparency","optionalContentConfig","initializeGraphics","operatorListChanged","getOperatorList","opListReadCapability","opListTask","streamTextContent","normalizeWhitespace","disableCombineTextItems","includeMarkedContent","TEXT_CONTENT_CHUNK_SIZE","sendWithStream","combineTextItems","highWaterMark","textContent","items","getTextContent","xfa","XfaText","readableStream","pump","reader","read","done","assign","styles","getReader","getStructTree","_structTreePromise","_destroy","waitOn","values","force","completed","cancel","clear","resetStats","_startRenderPage","_renderPageChunk","operatorListChunk","serializable","streamReader","setTimeout","curCacheKey","curIntentState","LoopbackPort","_listeners","_deferred","postMessage","transfers","cloneValue","object","structuredClone","fallbackCloneValue","cloned","has","byteOffset","val","isArray","desc","getOwnPropertyDescriptor","getPrototypeOf","hasOwnProperty","WeakMap","event","call","addEventListener","removeEventListener","splice","terminate","PDFWorkerUtil","isWorkerDisabled","fallbackWorkerSrc","fakeWorkerId","require","pdfjsFilePath","currentScript","createCDNWrapper","wrapper","_workerPorts","_port","_webWorker","_messageHandler","_initializeFromPort","_initialize","on","Worker","_mainThreadWorkerMessageHandler","workerSrc","terminateEarly","onWorkerError","_setupFakeWorker","sendTest","testObj","_setupFakeWorkerGlobal","WorkerMessageHandler","workerHandler","setup","pdfjsWorker","loader","mainWorkerMessageHandler","eval","getWorkerSrc","docStats","pageCache","pagePromises","metadataPromise","fontLoader","FontLoader","_onUnsupportedFeature","bind","styleElement","_params","cMapPacked","destroyCapability","_passwordCapability","_networkStream","_fullReader","_lastProgress","setupMessageHandler","AnnotationStorage","isOpList","lastModified","page","resetModified","terminated","_getFieldObjectsPromise","_hasJSActionsPromise","cancelAllRequests","sink","getFullReader","onPull","close","enqueue","onCancel","ready","readyReason","headersCapability","fullReader","headersReady","isStreamingSupported","isRangeSupported","contentLength","rangeReader","getRangeReader","_numPages","htmlForXfa","exception","updatePassword","exportedData","exportedError","fontRegistry","FontInspector","registerFont","fontAdded","FontFaceObject","finally","imageData","pageProxy","MAX_IMAGE_SIZE_TO_STORE","freeze","featureId","cachedPromise","results","OptionalContentConfig","metadata","Metadata","cleanupSuccessful","_objs","_ensureObj","objId","resolved","RenderTask","_internalRenderTask","onContinue","canvasInUse","WeakSet","operatorListIdx","running","graphicsReadyCallback","graphicsReady","_useRequestAnimationFrame","cancelled","_cancelBound","_continueBound","_continue","_scheduleNextBound","_scheduleNext","_nextBound","_next","StepperManager","stepper","init","nextBreakPoint","getNextBreakPoint","gfx","CanvasGraphics","beginDrawing","endDrawing","updateOperatorList","requestAnimationFrame","executeOperatorList","version","build","BaseFontLoader","nativeFontFaces","addNativeFontFace","nativeFontFace","fonts","insertRule","rule","getElementsByTagName","styleSheet","sheet","cssRules","attached","missingFile","isFontLoadingAPISupported","createNativeFontFace","family","createFontFaceRule","isSyncFontLoadingSupported","_queueLoadingCallback","_prepareFontLoadEvent","hasFonts","_loadTestFont","rules","fontsToLoad","GenericFontLoader","loadingContext","requests","nextRequestId","loadTestFontId","supported","navigator","userAgent","completeRequest","otherRequest","shift","getLoadTestFont","atob","int32","offset","spliceString","s","insert","chunk1","chunk2","ctx","called","isFontReady","fillText","getImageData","COMMENT_OFFSET","CFF_CHECKSUM_OFFSET","XXXX_VALUE","checksum","btoa","names","loadedName","div","visibility","position","top","left","span","fontFamily","body","translatedData","compiledGlyphs","cssFontInfo","FontFace","css","weight","fontWeight","italicAngle","mimetype","getPathGenerator","character","cmds","jsBuf","current","args","cmd","fs","readFile","Canvas","createCanvas","_storage","_timeStamp","_modified","onSetModified","onResetModified","getValue","defaultValue","setValue","modified","entry","entries","_setModified","getAll","_pattern_helper","MIN_FONT_SIZE","MAX_FONT_SIZE","MAX_GROUP_SIZE","EXECUTION_TIME","EXECUTION_STEPS","COMPILE_TYPE3_GLYPHS","MAX_SIZE_TO_COMPILE","FULL_CHUNK_HEIGHT","LINEWIDTH_SCALE_FACTOR","mirrorContextOperations","destCtx","_removeMirroring","__originalSave","__originalRestore","__originalRotate","__originalScale","__originalTranslate","translate","__originalTransform","__originalSetTransform","setTransform","__originalResetTransform","resetTransform","__originalClip","__originalMoveTo","__originalLineTo","__originalBezierCurveTo","bezierCurveTo","__originalRect","__originalClosePath","__originalBeginPath","beginPath","ctxSave","ctxRestore","ctxTranslate","ctxScale","ctxTransform","f","ctxSetTransform","ctxResetTransform","ctxRotate","angle","cp1x","cp1y","cp2x","cp2y","addContextCurrentTransform","mozCurrentTransform","_originalSave","_originalRestore","_originalRotate","_originalScale","_originalTranslate","_originalTransform","_originalSetTransform","_originalResetTransform","_transformMatrix","_transformStack","_setLineWidth","_getLineWidth","getLineWidth","_","getCurrentTransform","getCurrentTransformInverse","ad_bc","bc_ad","old","prev","pop","cosValue","cos","sinValue","sin","CachedCanvases","cache","getCanvas","trackTransform","canvasEntry","compileType3Glyph","imgData","POINT_TO_PROCESS_LIMIT","POINT_TYPES","width1","j0","points","lineSize","data0","elem","mask","count","sum","steps","Int32Array","outlines","coords","p0","step","pp","drawOutline","k","kk","o","l","ll","CanvasExtraState","alphaIsShape","fontSize","fontSizeScale","textMatrix","textMatrixScale","fontMatrix","leading","lineX","lineY","charSpacing","wordSpacing","textHScale","textRenderingMode","textRise","fillColor","strokeColor","patternFill","fillAlpha","strokeAlpha","lineWidth","activeSMask","transferMaps","startNewPathAndClipBox","clipBox","setCurrentPoint","updatePathMinMax","minX","minY","maxX","maxY","updateCurvePathMinMax","box","getPathBoundingBox","pathType","PathType","xStrokePad","yStrokePad","updateClipFromPath","Infinity","getClippedPathBoundingBox","putBinaryImageData","ImageData","putImageData","partialChunkHeight","fullChunks","totalChunks","chunkImgData","createImageData","srcPos","destPos","dest","thisChunkHeight","elemsInThisChunk","transferMapRed","transferMapGreen","transferMapBlue","transferMapGray","kind","srcLength","dest32","dest32DataLength","fullSrcDiff","white","black","srcDiff","kEnd","kEndUnrolled","srcByte","hasTransferMaps","putBinaryImageMask","copyCtxState","sourceCtx","properties","property","setLineDash","getLineDash","lineDashOffset","resetCtxToDefault","strokeStyle","fillStyle","fillRule","globalAlpha","lineCap","lineJoin","miterLimit","globalCompositeOperation","composeSMaskBackdrop","r0","g0","b0","alpha","alpha_","composeSMaskAlpha","maskData","layerData","transferMap","composeSMaskLuminosity","genericComposeSMask","maskCtx","layerCtx","subtype","backdrop","layerOffsetX","layerOffsetY","maskOffsetX","maskOffsetY","hasBackdrop","composeFn","PIXELS_TO_PROCESS","chunkSize","ceil","row","chunkHeight","composeSMask","layerBox","layerWidth","layerHeight","drawImage","getImageSmoothingEnabled","interpolate","fround","actualScale","devicePixelRatio","LINE_CAP_STYLES","LINE_JOIN_STYLES","NORMAL_CLIP","EO_CLIP","canvasCtx","stateStack","pendingClip","pendingEOFill","res","xobjs","groupStack","processingType3","baseTransform","baseTransformStack","groupLevel","smaskStack","smaskCounter","tempSMask","suspendedCtx","contentVisible","markedContentStack","cachedCanvases","cachedPatterns","viewportScale","outputScaleX","outputScaleY","_cachedGetSinglePixelWidth","fillRect","transparentCanvas","compositeCtx","_combinedScaleFactor","hypot","beginLayout","executionStartIdx","continueCallback","argsArrayLen","chunkOperations","endTime","fnId","breakIt","depObjId","objsPool","endLayout","_scaleImage","img","widthScale","heightScale","paintWidth","paintHeight","tmpCanvasId","tmpCanvas","tmpCtx","newWidth","newHeight","clearRect","_createMaskCanvas","isPatternFill","maskCanvas","objToCanvas","maskToCanvas","cord1","cord2","drawnWidth","drawnHeight","fillCanvas","fillCtx","scaled","mozCurrentTransformInverse","imageSmoothingEnabled","inverse","getPattern","round","limit","dashArray","dashPhase","flatness","states","state","checkSMaskState","inSMaskMode","beginSMaskMode","endSMaskMode","cacheId","scratchCanvas","compose","dirtyBox","floor","ops","startX","startY","xw","yh","consumePath","getSinglePixelWidth","needRestore","paths","pendingTextPaths","path","addToPath","spacing","fontRefName","fontObj","fontDirection","isType3Font","bold","italic","typeface","fallbackName","browserFontSize","mode","rise","paintChar","patternTransform","resetLineWidthToOne","fillStrokeMode","isAddToPathSet","strokeText","isFontSubpixelAAEnabled","glyphs","showType3Text","glyphsLength","vertical","spacingDir","defaultVMetrics","widthAdvanceScale","simpleFillText","pattern","glyph","restoreNeeded","isSpace","fontChar","accent","scaledX","scaledY","vmetric","vx","vy","remeasure","measuredWidth","measureText","characterScaleX","isInFont","scaledAccentX","scaledAccentY","charWidth","isTextInvisible","spacingLength","charProcOperatorList","operatorListId","transformed","xWidth","yWidth","llx","lly","urx","ury","getColorN_Pattern","IR","color","canvasGraphicsFactory","createCanvasGraphics","TilingPattern","_getPattern","matrix","getShadingPattern","SHADING","inv","bl","br","ul","ur","bbox","group","currentCtx","isolated","knockout","currentTransform","canvasBounds","scaleX","scaleY","groupCtx","startTransformInverse","currentMtx","hasOwnCanvas","canvasWidth","canvasHeight","annotationCanvas","savedCtx","compiled","skewX","skewY","positions","trans","images","image","w","h","imgToPaint","HTMLElement","getCanvasPosition","appendImage","tag","visible","isVisible","isContentVisible","absDet","sqNorm1","sqNorm2","pixelHeight","EPSILON","op","applyBoundingBox","Path2D","region","BaseShadingPattern","RadialAxialShadingPattern","_type","_bbox","_colorStops","_p0","_p1","_r0","_r1","_createGradient","grad","createLinearGradient","createRadialGradient","colorStop","addColorStop","owner","ownerBBox","createPattern","domMatrix","DOMMatrix","drawTriangle","c1","c2","c3","colors","rowSize","tmp","c1r","c1g","c1b","c2r","c2g","c2b","c3r","c3g","c3b","xa","car","cag","cab","xb","cbr","cbg","cbb","x1_","x2_","drawFigure","figure","ps","cs","verticesPerRow","rows","cols","q","MeshShadingPattern","_coords","_colors","_figures","_bounds","_background","_createMeshCanvas","combinedScale","backgroundColor","EXPECTED_SCALE","MAX_PATTERN_SIZE","BORDER_SIZE","boundsWidth","boundsHeight","paddedWidth","paddedHeight","matrixScale","temporaryPatternCanvas","DummyShadingPattern","PaintType","COLORED","UNCOLORED","xstep","ystep","paintType","tilingType","createPatternCanvas","curMatrixScale","dimx","getSizeAndScale","dimy","graphics","setFillAndStrokeStyleToContext","adjustedX0","adjustedY0","adjustedX1","adjustedY1","clipBbox","realOutputSize","maxSize","bboxWidth","bboxHeight","cssColor","CallbackKind","DATA","ERROR","StreamKind","CANCEL","CANCEL_COMPLETE","CLOSE","ENQUEUE","PULL","PULL_COMPLETE","START_COMPLETE","wrapReason","sourceName","targetName","comObj","callbackId","streamId","streamSinks","streamControllers","callbackCapabilities","actionHandler","_onComObjOnMessage","stream","_processStreamMessage","action","cbSourceName","cbTargetName","_createStreamSink","actionName","handler","ah","queueingStrategy","ReadableStream","controller","startCapability","startCall","pullCall","cancelCall","isClosed","desiredSize","pull","pullCapability","cancelCapability","self","streamSink","isCancelled","lastDesiredSize","sinkCapability","success","streamController","_deleteStreamController","allSettled","metadataMap","parsedData","rawData","getRaw","OptionalContentGroup","creator","_order","_groups","order","groups","baseState","off","_evaluateVisibilityExpression","array","operator","element","expression","policy","ids","setVisibility","getOrder","from","getGroups","getGroup","_queuedChunks","_progressiveDone","_contentDispositionFilename","_pdfDataRangeTransport","_isStreamingSupported","_isRangeSupported","_contentLength","_fullRequestReader","_rangeReaders","_onReceiveData","_onProgress","_onProgressiveDone","_enqueue","found","some","_begin","_progressiveDataLength","_loaded","firstReader","_removeRangeReader","queuedChunks","PDFDataTransportStreamReader","PDFDataTransportStreamRangeReader","_stream","_done","_filename","_requests","_headersReady","requestCapability","_end","_queuedChunk","requestsCapability","output","walk","node","shouldBuildText","child","_scripting_utils","_xfa_layer","DEFAULT_TAB_INDEX","GetElementsByNameSet","AnnotationElementFactory","parameters","annotationType","LinkAnnotationElement","TextAnnotationElement","fieldType","TextWidgetAnnotationElement","radioButton","RadioButtonWidgetAnnotationElement","checkBox","CheckboxWidgetAnnotationElement","PushButtonWidgetAnnotationElement","ChoiceWidgetAnnotationElement","WidgetAnnotationElement","PopupAnnotationElement","FreeTextAnnotationElement","LineAnnotationElement","SquareAnnotationElement","CircleAnnotationElement","PolylineAnnotationElement","CaretAnnotationElement","InkAnnotationElement","PolygonAnnotationElement","HighlightAnnotationElement","UnderlineAnnotationElement","SquigglyAnnotationElement","StrikeOutAnnotationElement","StampAnnotationElement","FileAttachmentAnnotationElement","AnnotationElement","isRenderable","ignoreBorder","createQuadrilaterals","layer","linkService","downloadManager","imageResourcesPath","renderForms","svgFactory","enableScripting","_fieldObjects","fieldObjects","_mouseState","mouseState","container","_createContainer","quadrilaterals","_createQuadrilaterals","sign","transformOrigin","borderStyle","borderWidth","horizontalRadius","horizontalCornerRadius","verticalRadius","verticalCornerRadius","radius","borderRadius","borderBottomStyle","borderColor","quadPoints","savedRect","quadPoint","_createPopup","trigger","popupElement","PopupElement","modificationDate","richText","hideWrapper","popup","_renderQuadrilaterals","className","quadrilateral","_getElementsByName","skipId","fields","fieldObj","exportValues","exportValue","domElement","getElementById","getElementsByName","platform","isWin","isMac","isTooltipOnly","resetForm","actions","Action","newWindow","_bindNamedAction","_bindLink","hasClickAction","_bindJSAction","_bindResetFormAction","index","linkElement","cloneNode","destination","getDestinationHash","goToDestination","getAnchorUrl","executeNamedAction","jsName","eventBus","dispatch","detail","otherClickAction","resetFormFields","refs","resetFormRefs","include","allFields","fieldIds","fieldName","field","storage","allIds","valueAsString","dispatchEvent","Event","hasPopup","alt","dataset","l10nId","l10nArgs","JSON","stringify","alternativeText","_getKeyModifier","ctrlKey","metaKey","_setEventListener","baseName","eventName","valueGetter","shiftKey","modifier","checked","_setEventListeners","getter","_setBackgroundColor","_dispatchEventFromSandbox","jsEvent","setColor","styleName","ColorConverters","commonActions","display","hidden","print","focus","preventScroll","userName","readonly","removeAttribute","required","bgColor","fgColor","textColor","hasAppearance","fieldValue","setPropertyOnSiblings","keyInStorage","storedData","elementData","userValue","formattedValue","beforeInputSelectionRange","beforeInputValue","multiLine","disabled","readOnly","tabIndex","defaultFieldValue","blurListener","scrollLeft","activeElement","selRange","selStart","selEnd","setSelectionRange","commitKey","willCommit","selectionStart","selectionEnd","_blurListener","isDown","Keystroke","change","maxLen","maxLength","comb","fieldWidth","combWidth","classList","letterSpacing","verticalAlign","_setTextStyle","TEXT_ALIGNMENT","fontColor","defaultAppearanceData","textAlignment","textAlign","checkbox","curChecked","buttonValue","radio","pdfButtonValue","fontSizeStyle","selectElement","combo","multiSelect","multiple","option","selected","optionElement","displayValue","isExport","selectedIndex","filter","getItems","multipleSelection","findIndex","insertBefore","indices","editable","changeEx","keyDown","IGNORE_TYPES","parentType","selector","parentId","parentElements","querySelectorAll","parentRect","popupLeft","popupTop","pinned","BACKGROUND_ENLIGHT","hideElement","dir","dateObject","toLocaleDateString","toLocaleTimeString","XfaLayer","xfaHtml","html","lastChild","contents","_formatContents","_toggle","_show","_hide","lines","split","line","createTextNode","pin","zIndex","unpin","lineCoordinates","append","square","circle","containerClassName","svgElementName","coordinate","vertices","polyline","inkList","inkLists","content","file","_download","openOrDownloadData","AnnotationLayer","sortedAnnotations","popupAnnotations","rendered","renderedElement","prepend","setAnnotationCanvasMap","update","ownMatrix","elements","ownTransform","querySelector","firstChild","nodeName","replaceChild","makeColorComp","CMYK_G","G_CMYK","G_RGB","G_HTML","G","RGB_G","RGB_HTML","R","B","T_HTML","CMYK_RGB","CMYK_HTML","components","RGB_CMYK","setupStorage","xfaOn","xfaOff","getAttribute","setAttributes","isHTMLAnchorElement","HTMLAnchorElement","dataId","rootHtml","stack","rootDiv","textDivs","parent","childHtml","xmlns","el","MAX_TEXT_DIVS_TO_RENDER","DEFAULT_FONT_SIZE","DEFAULT_FONT_ASCENT","ascentCache","AllWhitespaceRegexp","getAscent","cachedAscent","metrics","ascent","fontBoundingBoxAscent","descent","fontBoundingBoxDescent","ratio","pixels","appendText","geom","textDiv","textDivProperties","_enhanceTextSelection","hasText","hasEOL","originalTransform","paddingBottom","paddingLeft","paddingRight","paddingTop","_textDivs","tx","_viewport","atan2","fontName","fontHeight","fontAscent","_fontInspectorEnabled","shouldScaleText","absScaleX","absScaleY","_textDivProperties","_textContentStream","_layoutText","angleCos","angleSin","divWidth","divHeight","right","bottom","_canceled","textDivsLength","_renderingDone","findPositiveMin","ts","expand","expanded","expandBounds","divProperties","Float64Array","jj","boxScale","boxes","x1New","x2New","expandBoundsLTR","fakeBoundary","horizon","boundary","horizonPart","affectedBoundary","maxXNew","xNew","changedHorizon","lastBoundary","useBoundary","unshift","used","concat","TextLayerRenderTask","textContentStream","textContentItemsStr","enhanceTextSelection","_textContent","_container","_textContentItemsStr","_reader","_layoutTextLastFontSize","_layoutTextLastFontFamily","_layoutTextCtx","_renderTimer","_processItems","styleCache","len","parentNode","_render","timeout","mozOpaque","textItems","textStyles","expandTextDivs","expandDivs","transformBuf","paddingBuf","divProps","padding","renderTextLayer","renderParameters","SVGGraphics","SVG_DEFAULTS","fontStyle","XML_NS","XLINK_NS","convertImgDataToPng","PNG_HEADER","CHUNK_WRAPPER_SIZE","crcTable","crc32","crc","writePngChunk","adler32","deflateSync","literals","deflateSyncUncompressed","maxBlockLength","deflateBlocks","idat","pi","adler","encode","isMask","bitDepth","colorType","offsetLiterals","offsetBytes","ihdr","pngLength","SVGExtraState","dependencies","activeClipUrl","clipGroup","maskId","opListToTree","opList","opTree","opListElement","fn","pf","toFixed","pm","acos","clipCount","maskCount","shadingCount","transformMatrix","transformStack","extraStack","embedFonts","embeddedFonts","cssStyle","_operatorIdMapping","tgrp","executeOpTree","loadDependencies","getSVG","svgElement","convertOpList","operatorIdMapping","opTreeElement","lineMatrix","xcoords","ycoords","tspan","setAttributeNS","txtElement","txtgrp","lineWidthScale","_setStrokeAttributes","_ensureTransformGroup","addFontStyle","defs","hasChildNodes","setStrokeAlpha","setFillAlpha","_makeColorN_Pattern","_makeShadingPattern","_makeTilingPattern","tilingId","tx0","ty0","tx1","ty1","xscale","yscale","txstep","tystep","tiling","childNodes","shadingId","colorStops","gradient","point0","point1","focalPoint","circlePoint","focalRadius","circleRadius","stop","getAttributeNS","clipId","clipPath","clipElement","imgSrc","cliprect","imgEl","definitions","rootGroup","_ensureClipGroup","_network_utils","http","https","fileUriRegex","parseUrl","sourceUrl","parsedUrl","parse","host","PDFNodeStream","isHttp","isFsUrl","_rangeRequestReaders","PDFNodeStreamFsFullReader","PDFNodeStreamFullReader","PDFNodeStreamFsRangeReader","PDFNodeStreamRangeReader","BaseFullReader","_url","_storedError","_disableRange","_rangeChunkSize","_readableStream","_readCapability","_headersCapability","_error","_setReadableStream","BaseRangeReader","createRequestOptions","headers","auth","hostname","method","handleResponse","statusCode","getResponseHeader","allowRangeRequests","suggestedLength","validateRangeRequestCapabilities","extractFilenameFromHeader","_request","_httpHeaders","Range","lstat","stat","createReadStream","_content_disposition","returnValues","contentEncoding","contentDisposition","getFilenameFromContentDispositionHeader","createResponseStatusError","validateResponseStatus","needsEncodingFixup","toParamRegExp","rfc2616unquote","rfc5987decode","rfc2047decode","fixupEncoding","rfc2231getparam","attributePattern","flags","textdecode","encoding","decoder","TextDecoder","fatal","decode","err","contentDispositionStr","iter","quot","part","parts","quotindex","extvalue","encodingend","langvalue","charset","hex","OK_RESPONSE","PARTIAL_CONTENT_RESPONSE","getArrayBuffer","xhr","NetworkManager","getXhr","NetworkManager_getXhr","currXhrId","pendingRequests","requestRange","listeners","requestFull","xhrId","pendingRequest","setRequestHeader","expectedStatus","onError","onStateChange","onprogress","onHeadersReceived","onDone","xhrStatus","ok_response_on_range_request","rangeHeader","getRequestXhr","isPendingRequest","abortRequest","PDFNetworkStream","_source","_manager","_onRangeRequestReaderClosed","PDFNetworkStreamFullRequestReader","PDFNetworkStreamRangeRequestReader","onClosed","manager","_onHeadersReceived","_onDone","_onError","_fullRequestId","_headersReceivedCapability","_cachedChunks","fullRequestXhrId","fullRequestXhr","lengthComputable","_requestId","_close","createFetchOptions","abortController","signal","credentials","redirect","createHeaders","Headers","PDFFetchStream","PDFFetchStreamReader","PDFFetchStreamRangeReader","_withCredentials","AbortController","_abortController","_headers","__webpack_module_cache__","moduleId","cachedModule","__webpack_modules__","_api","_annotation_layer","_text_layer","_svg","pdfjsVersion","pdfjsBuild"],"sources":["webpack://pdfjs-dist/build/pdf/webpack/universalModuleDefinition","webpack://pdfjs-dist/build/pdf/src/display/display_utils.js","webpack://pdfjs-dist/build/pdf/src/shared/util.js","webpack://pdfjs-dist/build/pdf/src/shared/compatibility.js","webpack://pdfjs-dist/build/pdf/src/shared/is_node.js","webpack://pdfjs-dist/build/pdf/src/display/base_factory.js","webpack://pdfjs-dist/build/pdf/src/display/api.js","webpack://pdfjs-dist/build/pdf/src/display/font_loader.js","webpack://pdfjs-dist/build/pdf/src/display/node_utils.js","webpack://pdfjs-dist/build/pdf/src/display/annotation_storage.js","webpack://pdfjs-dist/build/pdf/src/display/canvas.js","webpack://pdfjs-dist/build/pdf/src/display/pattern_helper.js","webpack://pdfjs-dist/build/pdf/src/display/worker_options.js","webpack://pdfjs-dist/build/pdf/src/shared/message_handler.js","webpack://pdfjs-dist/build/pdf/src/display/metadata.js","webpack://pdfjs-dist/build/pdf/src/display/optional_content_config.js","webpack://pdfjs-dist/build/pdf/src/display/transport_stream.js","webpack://pdfjs-dist/build/pdf/src/display/xfa_text.js","webpack://pdfjs-dist/build/pdf/src/display/annotation_layer.js","webpack://pdfjs-dist/build/pdf/src/shared/scripting_utils.js","webpack://pdfjs-dist/build/pdf/src/display/xfa_layer.js","webpack://pdfjs-dist/build/pdf/src/display/text_layer.js","webpack://pdfjs-dist/build/pdf/src/display/svg.js","webpack://pdfjs-dist/build/pdf/src/display/node_stream.js","webpack://pdfjs-dist/build/pdf/src/display/network_utils.js","webpack://pdfjs-dist/build/pdf/src/display/content_disposition.js","webpack://pdfjs-dist/build/pdf/src/display/network.js","webpack://pdfjs-dist/build/pdf/src/display/fetch_stream.js","webpack://pdfjs-dist/build/pdf/webpack/bootstrap","webpack://pdfjs-dist/build/pdf/src/pdf.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"pdfjs-dist/build/pdf\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"pdfjs-dist/build/pdf\"] = factory();\n\telse\n\t\troot[\"pdfjs-dist/build/pdf\"] = factory();\n})(this, function() {\nreturn ","/* Copyright 2015 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  assert,\n  BaseException,\n  isString,\n  removeNullCharacters,\n  shadow,\n  stringToBytes,\n  Util,\n  warn,\n} from \"../shared/util.js\";\nimport {\n  BaseCanvasFactory,\n  BaseCMapReaderFactory,\n  BaseStandardFontDataFactory,\n  BaseSVGFactory,\n} from \"./base_factory.js\";\n\nconst DEFAULT_LINK_REL = \"noopener noreferrer nofollow\";\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\nconst PixelsPerInch = {\n  CSS: 96.0,\n  PDF: 72.0,\n\n  /** @type {number} */\n  get PDF_TO_CSS_UNITS() {\n    return shadow(this, \"PDF_TO_CSS_UNITS\", this.CSS / this.PDF);\n  },\n};\n\nclass DOMCanvasFactory extends BaseCanvasFactory {\n  constructor({ ownerDocument = globalThis.document } = {}) {\n    super();\n    this._document = ownerDocument;\n  }\n\n  _createCanvas(width, height) {\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n}\n\nasync function fetchData(url, asTypedArray = false) {\n  if (\n    (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) ||\n    isValidFetchUrl(url, document.baseURI)\n  ) {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n    return asTypedArray\n      ? new Uint8Array(await response.arrayBuffer())\n      : stringToBytes(await response.text());\n  }\n\n  // The Fetch API is not supported.\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.open(\"GET\", url, /* asTypedArray = */ true);\n\n    if (asTypedArray) {\n      request.responseType = \"arraybuffer\";\n    }\n    request.onreadystatechange = () => {\n      if (request.readyState !== XMLHttpRequest.DONE) {\n        return;\n      }\n      if (request.status === 200 || request.status === 0) {\n        let data;\n        if (asTypedArray && request.response) {\n          data = new Uint8Array(request.response);\n        } else if (!asTypedArray && request.responseText) {\n          data = stringToBytes(request.responseText);\n        }\n        if (data) {\n          resolve(data);\n          return;\n        }\n      }\n      reject(new Error(request.statusText));\n    };\n\n    request.send(null);\n  });\n}\n\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    return fetchData(url, /* asTypedArray = */ this.isCompressed).then(data => {\n      return { cMapData: data, compressionType };\n    });\n  }\n}\n\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n  _fetchData(url) {\n    return fetchData(url, /* asTypedArray = */ true);\n  }\n}\n\nclass DOMSVGFactory extends BaseSVGFactory {\n  _createSVG(type) {\n    return document.createElementNS(SVG_NS, type);\n  }\n}\n\n/**\n * @typedef {Object} PageViewportParameters\n * @property {Array<number>} viewBox - The xMin, yMin, xMax and\n *   yMax coordinates.\n * @property {number} scale - The scale of the viewport.\n * @property {number} rotation - The rotation, in degrees, of the viewport.\n * @property {number} [offsetX] - The horizontal, i.e. x-axis, offset. The\n *   default value is `0`.\n * @property {number} [offsetY] - The vertical, i.e. y-axis, offset. The\n *   default value is `0`.\n * @property {boolean} [dontFlip] - If true, the y-axis will not be flipped.\n *   The default value is `false`.\n */\n\n/**\n * @typedef {Object} PageViewportCloneParameters\n * @property {number} [scale] - The scale, overriding the one in the cloned\n *   viewport. The default value is `this.scale`.\n * @property {number} [rotation] - The rotation, in degrees, overriding the one\n *   in the cloned viewport. The default value is `this.rotation`.\n * @property {number} [offsetX] - The horizontal, i.e. x-axis, offset.\n *   The default value is `this.offsetX`.\n * @property {number} [offsetY] - The vertical, i.e. y-axis, offset.\n *   The default value is `this.offsetY`.\n * @property {boolean} [dontFlip] - If true, the x-axis will not be flipped.\n *   The default value is `false`.\n */\n\n/**\n * PDF page viewport created based on scale, rotation and offset.\n */\nclass PageViewport {\n  /**\n   * @param {PageViewportParameters}\n   */\n  constructor({\n    viewBox,\n    scale,\n    rotation,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false,\n  }) {\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n\n    // creating transform to convert pdf coordinate system to the normal\n    // canvas like coordinates taking in account scale and rotation\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\n    let rotateA, rotateB, rotateC, rotateD;\n    // Normalize the rotation, by clamping it to the [0, 360) range.\n    rotation %= 360;\n    if (rotation < 0) {\n      rotation += 360;\n    }\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n      default:\n        throw new Error(\n          \"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\"\n        );\n    }\n\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n\n    let offsetCanvasX, offsetCanvasY;\n    let width, height;\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n    }\n    // creating transform for the following operations:\n    // translate(-centerX, -centerY), rotate and flip vertically,\n    // scale, and translate(offsetCanvasX, offsetCanvasY)\n    this.transform = [\n      rotateA * scale,\n      rotateB * scale,\n      rotateC * scale,\n      rotateD * scale,\n      offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n      offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY,\n    ];\n\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Clones viewport, with optional additional properties.\n   * @param {PageViewportCloneParameters} [params]\n   * @returns {PageViewport} Cloned viewport.\n   */\n  clone({\n    scale = this.scale,\n    rotation = this.rotation,\n    offsetX = this.offsetX,\n    offsetY = this.offsetY,\n    dontFlip = false,\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.viewBox.slice(),\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip,\n    });\n  }\n\n  /**\n   * Converts PDF point to the viewport coordinates. For examples, useful for\n   * converting PDF location into canvas pixel coordinates.\n   * @param {number} x - The x-coordinate.\n   * @param {number} y - The y-coordinate.\n   * @returns {Object} Object containing `x` and `y` properties of the\n   *   point in the viewport coordinate space.\n   * @see {@link convertToPdfPoint}\n   * @see {@link convertToViewportRectangle}\n   */\n  convertToViewportPoint(x, y) {\n    return Util.applyTransform([x, y], this.transform);\n  }\n\n  /**\n   * Converts PDF rectangle to the viewport coordinates.\n   * @param {Array} rect - The xMin, yMin, xMax and yMax coordinates.\n   * @returns {Array} Array containing corresponding coordinates of the\n   *   rectangle in the viewport coordinate space.\n   * @see {@link convertToViewportPoint}\n   */\n  convertToViewportRectangle(rect) {\n    const topLeft = Util.applyTransform([rect[0], rect[1]], this.transform);\n    const bottomRight = Util.applyTransform([rect[2], rect[3]], this.transform);\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n  }\n\n  /**\n   * Converts viewport coordinates to the PDF location. For examples, useful\n   * for converting canvas pixel location into PDF one.\n   * @param {number} x - The x-coordinate.\n   * @param {number} y - The y-coordinate.\n   * @returns {Object} Object containing `x` and `y` properties of the\n   *   point in the PDF coordinate space.\n   * @see {@link convertToViewportPoint}\n   */\n  convertToPdfPoint(x, y) {\n    return Util.applyInverseTransform([x, y], this.transform);\n  }\n}\n\nclass RenderingCancelledException extends BaseException {\n  constructor(msg, type) {\n    super(msg, \"RenderingCancelledException\");\n    this.type = type;\n  }\n}\n\nconst LinkTarget = {\n  NONE: 0, // Default value.\n  SELF: 1,\n  BLANK: 2,\n  PARENT: 3,\n  TOP: 4,\n};\n\n/**\n * @typedef ExternalLinkParameters\n * @typedef {Object} ExternalLinkParameters\n * @property {string} url - An absolute URL.\n * @property {LinkTarget} [target] - The link target. The default value is\n *   `LinkTarget.NONE`.\n * @property {string} [rel] - The link relationship. The default value is\n *   `DEFAULT_LINK_REL`.\n * @property {boolean} [enabled] - Whether the link should be enabled. The\n *   default value is true.\n */\n\n/**\n * Adds various attributes (href, title, target, rel) to hyperlinks.\n * @param {HTMLAnchorElement} link - The link element.\n * @param {ExternalLinkParameters} params\n */\nfunction addLinkAttributes(link, { url, target, rel, enabled = true } = {}) {\n  assert(\n    url && typeof url === \"string\",\n    'addLinkAttributes: A valid \"url\" parameter must provided.'\n  );\n\n  const urlNullRemoved = removeNullCharacters(url);\n  if (enabled) {\n    link.href = link.title = urlNullRemoved;\n  } else {\n    link.href = \"\";\n    link.title = `Disabled: ${urlNullRemoved}`;\n    link.onclick = () => {\n      return false;\n    };\n  }\n\n  let targetStr = \"\"; // LinkTarget.NONE\n  switch (target) {\n    case LinkTarget.NONE:\n      break;\n    case LinkTarget.SELF:\n      targetStr = \"_self\";\n      break;\n    case LinkTarget.BLANK:\n      targetStr = \"_blank\";\n      break;\n    case LinkTarget.PARENT:\n      targetStr = \"_parent\";\n      break;\n    case LinkTarget.TOP:\n      targetStr = \"_top\";\n      break;\n  }\n  link.target = targetStr;\n\n  link.rel = typeof rel === \"string\" ? rel : DEFAULT_LINK_REL;\n}\n\nfunction isDataScheme(url) {\n  const ii = url.length;\n  let i = 0;\n  while (i < ii && url[i].trim() === \"\") {\n    i++;\n  }\n  return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\n\nfunction isPdfFile(filename) {\n  return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\n\n/**\n * Gets the filename from a given URL.\n * @param {string} url\n * @returns {string}\n */\nfunction getFilenameFromUrl(url) {\n  const anchor = url.indexOf(\"#\");\n  const query = url.indexOf(\"?\");\n  const end = Math.min(\n    anchor > 0 ? anchor : url.length,\n    query > 0 ? query : url.length\n  );\n  return url.substring(url.lastIndexOf(\"/\", end) + 1, end);\n}\n\n/**\n * Returns the filename or guessed filename from the url (see issue 3455).\n * @param {string} url - The original PDF location.\n * @param {string} defaultFilename - The value returned if the filename is\n *   unknown, or the protocol is unsupported.\n * @returns {string} Guessed PDF filename.\n */\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n  if (typeof url !== \"string\") {\n    return defaultFilename;\n  }\n  if (isDataScheme(url)) {\n    warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n    return defaultFilename;\n  }\n  const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n  //              SCHEME        HOST        1.PATH  2.QUERY   3.REF\n  // Pattern to get last matching NAME.pdf\n  const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n  const splitURI = reURI.exec(url);\n  let suggestedFilename =\n    reFilename.exec(splitURI[1]) ||\n    reFilename.exec(splitURI[2]) ||\n    reFilename.exec(splitURI[3]);\n  if (suggestedFilename) {\n    suggestedFilename = suggestedFilename[0];\n    if (suggestedFilename.includes(\"%\")) {\n      // URL-encoded %2Fpath%2Fto%2Ffile.pdf should be file.pdf\n      try {\n        suggestedFilename = reFilename.exec(\n          decodeURIComponent(suggestedFilename)\n        )[0];\n      } catch (ex) {\n        // Possible (extremely rare) errors:\n        // URIError \"Malformed URI\", e.g. for \"%AA.pdf\"\n        // TypeError \"null has no properties\", e.g. for \"%2F.pdf\"\n      }\n    }\n  }\n  return suggestedFilename || defaultFilename;\n}\n\nclass StatTimer {\n  constructor() {\n    this.started = Object.create(null);\n    this.times = [];\n  }\n\n  time(name) {\n    if (name in this.started) {\n      warn(`Timer is already running for ${name}`);\n    }\n    this.started[name] = Date.now();\n  }\n\n  timeEnd(name) {\n    if (!(name in this.started)) {\n      warn(`Timer has not been started for ${name}`);\n    }\n    this.times.push({\n      name,\n      start: this.started[name],\n      end: Date.now(),\n    });\n    // Remove timer from started so it can be called again.\n    delete this.started[name];\n  }\n\n  toString() {\n    // Find the longest name for padding purposes.\n    const outBuf = [];\n    let longest = 0;\n    for (const time of this.times) {\n      const name = time.name;\n      if (name.length > longest) {\n        longest = name.length;\n      }\n    }\n    for (const time of this.times) {\n      const duration = time.end - time.start;\n      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\\n`);\n    }\n    return outBuf.join(\"\");\n  }\n}\n\nfunction isValidFetchUrl(url, baseUrl) {\n  try {\n    const { protocol } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    // The Fetch API only supports the http/https protocols, and not file/ftp.\n    return protocol === \"http:\" || protocol === \"https:\";\n  } catch (ex) {\n    return false; // `new URL()` will throw on incorrect data.\n  }\n}\n\n/**\n * @param {string} src\n * @param {boolean} [removeScriptElement]\n * @returns {Promise<void>}\n */\nfunction loadScript(src, removeScriptElement = false) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    script.src = src;\n\n    script.onload = function (evt) {\n      if (removeScriptElement) {\n        script.remove();\n      }\n      resolve(evt);\n    };\n    script.onerror = function () {\n      reject(new Error(`Cannot load script at: ${script.src}`));\n    };\n    (document.head || document.documentElement).appendChild(script);\n  });\n}\n\n// Deprecated API function -- display regardless of the `verbosity` setting.\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\n\nlet pdfDateStringRegex;\n\nclass PDFDateString {\n  /**\n   * Convert a PDF date string to a JavaScript `Date` object.\n   *\n   * The PDF date string format is described in section 7.9.4 of the official\n   * PDF 32000-1:2008 specification. However, in the PDF 1.7 reference (sixth\n   * edition) Adobe describes the same format including a trailing apostrophe.\n   * This syntax in incorrect, but Adobe Acrobat creates PDF files that contain\n   * them. We ignore all apostrophes as they are not necessary for date parsing.\n   *\n   * Moreover, Adobe Acrobat doesn't handle changing the date to universal time\n   * and doesn't use the user's time zone (effectively ignoring the HH' and mm'\n   * parts of the date string).\n   *\n   * @param {string} input\n   * @returns {Date|null}\n   */\n  static toDateObject(input) {\n    if (!input || !isString(input)) {\n      return null;\n    }\n\n    // Lazily initialize the regular expression.\n    if (!pdfDateStringRegex) {\n      pdfDateStringRegex = new RegExp(\n        \"^D:\" + // Prefix (required)\n          \"(\\\\d{4})\" + // Year (required)\n          \"(\\\\d{2})?\" + // Month (optional)\n          \"(\\\\d{2})?\" + // Day (optional)\n          \"(\\\\d{2})?\" + // Hour (optional)\n          \"(\\\\d{2})?\" + // Minute (optional)\n          \"(\\\\d{2})?\" + // Second (optional)\n          \"([Z|+|-])?\" + // Universal time relation (optional)\n          \"(\\\\d{2})?\" + // Offset hour (optional)\n          \"'?\" + // Splitting apostrophe (optional)\n          \"(\\\\d{2})?\" + // Offset minute (optional)\n          \"'?\" // Trailing apostrophe (optional)\n      );\n    }\n\n    // Optional fields that don't satisfy the requirements from the regular\n    // expression (such as incorrect digit counts or numbers that are out of\n    // range) will fall back the defaults from the specification.\n    const matches = pdfDateStringRegex.exec(input);\n    if (!matches) {\n      return null;\n    }\n\n    // JavaScript's `Date` object expects the month to be between 0 and 11\n    // instead of 1 and 12, so we have to correct for that.\n    const year = parseInt(matches[1], 10);\n    let month = parseInt(matches[2], 10);\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\n    let day = parseInt(matches[3], 10);\n    day = day >= 1 && day <= 31 ? day : 1;\n    let hour = parseInt(matches[4], 10);\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\n    let minute = parseInt(matches[5], 10);\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\n    let second = parseInt(matches[6], 10);\n    second = second >= 0 && second <= 59 ? second : 0;\n    const universalTimeRelation = matches[7] || \"Z\";\n    let offsetHour = parseInt(matches[8], 10);\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n    let offsetMinute = parseInt(matches[9], 10) || 0;\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n\n    // Universal time relation 'Z' means that the local time is equal to the\n    // universal time, whereas the relations '+'/'-' indicate that the local\n    // time is later respectively earlier than the universal time. Every date\n    // is normalized to universal time.\n    if (universalTimeRelation === \"-\") {\n      hour += offsetHour;\n      minute += offsetMinute;\n    } else if (universalTimeRelation === \"+\") {\n      hour -= offsetHour;\n      minute -= offsetMinute;\n    }\n\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n  }\n}\n\n/**\n * NOTE: This is (mostly) intended to support printing of XFA forms.\n */\nfunction getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n  const { width, height } = xfaPage.attributes.style;\n  const viewBox = [0, 0, parseInt(width), parseInt(height)];\n\n  return new PageViewport({\n    viewBox,\n    scale,\n    rotation,\n  });\n}\n\nexport {\n  addLinkAttributes,\n  deprecated,\n  DOMCanvasFactory,\n  DOMCMapReaderFactory,\n  DOMStandardFontDataFactory,\n  DOMSVGFactory,\n  getFilenameFromUrl,\n  getPdfFilenameFromUrl,\n  getXfaPageViewport,\n  isDataScheme,\n  isPdfFile,\n  isValidFetchUrl,\n  LinkTarget,\n  loadScript,\n  PageViewport,\n  PDFDateString,\n  PixelsPerInch,\n  RenderingCancelledException,\n  StatTimer,\n};\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport \"./compatibility.js\";\n\nconst IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\n\n/**\n * Refer to the `WorkerTransport.getRenderingIntent`-method in the API, to see\n * how these flags are being used:\n *  - ANY, DISPLAY, and PRINT are the normal rendering intents, note the\n *    `PDFPageProxy.{render, getOperatorList, getAnnotations}`-methods.\n *  - ANNOTATIONS_FORMS, ANNOTATIONS_STORAGE, ANNOTATIONS_DISABLE control which\n *    annotations are rendered onto the canvas (i.e. by being included in the\n *    operatorList), note the `PDFPageProxy.{render, getOperatorList}`-methods\n *    and their `annotationMode`-option.\n *  - OPLIST is used with the `PDFPageProxy.getOperatorList`-method, note the\n *    `OperatorList`-constructor (on the worker-thread).\n */\nconst RenderingIntentFlag = {\n  ANY: 0x01,\n  DISPLAY: 0x02,\n  PRINT: 0x04,\n  ANNOTATIONS_FORMS: 0x10,\n  ANNOTATIONS_STORAGE: 0x20,\n  ANNOTATIONS_DISABLE: 0x40,\n  OPLIST: 0x100,\n};\n\nconst AnnotationMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_FORMS: 2,\n  ENABLE_STORAGE: 3,\n};\n\n// Permission flags from Table 22, Section 7.6.3.2 of the PDF specification.\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800,\n};\n\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4,\n};\n\nconst ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3,\n};\n\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26,\n};\n\nconst AnnotationStateModelType = {\n  MARKED: \"Marked\",\n  REVIEW: \"Review\",\n};\n\nconst AnnotationMarkedState = {\n  MARKED: \"Marked\",\n  UNMARKED: \"Unmarked\",\n};\n\nconst AnnotationReviewState = {\n  ACCEPTED: \"Accepted\",\n  REJECTED: \"Rejected\",\n  CANCELLED: \"Cancelled\",\n  COMPLETED: \"Completed\",\n  NONE: \"None\",\n};\n\nconst AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\",\n};\n\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200,\n};\n\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000,\n};\n\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5,\n};\n\nconst AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\",\n};\n\nconst DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\",\n};\n\nconst PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\",\n};\n\nconst StreamType = {\n  UNKNOWN: \"UNKNOWN\",\n  FLATE: \"FLATE\",\n  LZW: \"LZW\",\n  DCT: \"DCT\",\n  JPX: \"JPX\",\n  JBIG: \"JBIG\",\n  A85: \"A85\",\n  AHX: \"AHX\",\n  CCF: \"CCF\",\n  RLX: \"RLX\", // PDF short name is 'RL', but telemetry requires three chars.\n};\n\nconst FontType = {\n  UNKNOWN: \"UNKNOWN\",\n  TYPE1: \"TYPE1\",\n  TYPE1STANDARD: \"TYPE1STANDARD\",\n  TYPE1C: \"TYPE1C\",\n  CIDFONTTYPE0: \"CIDFONTTYPE0\",\n  CIDFONTTYPE0C: \"CIDFONTTYPE0C\",\n  TRUETYPE: \"TRUETYPE\",\n  CIDFONTTYPE2: \"CIDFONTTYPE2\",\n  TYPE3: \"TYPE3\",\n  OPENTYPE: \"OPENTYPE\",\n  TYPE0: \"TYPE0\",\n  MMTYPE1: \"MMTYPE1\",\n};\n\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5,\n};\n\nconst CMapCompressionType = {\n  NONE: 0,\n  BINARY: 1,\n  STREAM: 2,\n};\n\n// All the possible operations for an operator list.\nconst OPS = {\n  // Intentionally start from 1 so it is easy to spot bad operators that will be\n  // 0's.\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotations: 78,\n  endAnnotations: 79,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  /** @deprecated unused */\n  paintJpegXObject: 82,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91,\n};\n\nconst UNSUPPORTED_FEATURES = {\n  /** @deprecated unused */\n  unknown: \"unknown\",\n  forms: \"forms\",\n  javaScript: \"javaScript\",\n  signatures: \"signatures\",\n  smask: \"smask\",\n  shadingPattern: \"shadingPattern\",\n  /** @deprecated unused */\n  font: \"font\",\n  errorTilingPattern: \"errorTilingPattern\",\n  errorExtGState: \"errorExtGState\",\n  errorXObject: \"errorXObject\",\n  errorFontLoadType3: \"errorFontLoadType3\",\n  errorFontState: \"errorFontState\",\n  errorFontMissing: \"errorFontMissing\",\n  errorFontTranslate: \"errorFontTranslate\",\n  errorColorSpace: \"errorColorSpace\",\n  errorOperatorList: \"errorOperatorList\",\n  errorFontToUnicode: \"errorFontToUnicode\",\n  errorFontLoadNative: \"errorFontLoadNative\",\n  errorFontBuildPath: \"errorFontBuildPath\",\n  errorFontGetPath: \"errorFontGetPath\",\n  errorMarkedContent: \"errorMarkedContent\",\n  errorContentSubStream: \"errorContentSubStream\",\n};\n\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2,\n};\n\nlet verbosity = VerbosityLevel.WARNINGS;\n\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\n\nfunction getVerbosityLevel() {\n  return verbosity;\n}\n\n// A notice for devs. These are good for things that are helpful to devs, such\n// as warning that Workers were disabled, which is important to devs but not\n// end users.\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(`Info: ${msg}`);\n  }\n}\n\n// Non-fatal warnings.\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(`Warning: ${msg}`);\n  }\n}\n\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\n\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\n\n// Checks if URLs have the same origin. For non-HTTP based URLs, returns false.\nfunction isSameOrigin(baseUrl, otherUrl) {\n  let base;\n  try {\n    base = new URL(baseUrl);\n    if (!base.origin || base.origin === \"null\") {\n      return false; // non-HTTP url\n    }\n  } catch (e) {\n    return false;\n  }\n\n  const other = new URL(otherUrl, base);\n  return base.origin === other.origin;\n}\n\n// Checks if URLs use one of the allowed protocols, e.g. to avoid XSS.\nfunction _isValidProtocol(url) {\n  if (!url) {\n    return false;\n  }\n  switch (url.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Attempts to create a valid absolute URL.\n *\n * @param {URL|string} url - An absolute, or relative, URL.\n * @param {URL|string} [baseUrl] - An absolute URL.\n * @param {Object} [options]\n * @returns Either a valid {URL}, or `null` otherwise.\n */\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n  if (!url) {\n    return null;\n  }\n  try {\n    if (options && typeof url === \"string\") {\n      // Let URLs beginning with \"www.\" default to using the \"http://\" protocol.\n      if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n        const dots = url.match(/\\./g);\n        // Avoid accidentally matching a *relative* URL pointing to a file named\n        // e.g. \"www.pdf\" or similar.\n        if (dots && dots.length >= 2) {\n          url = `http://${url}`;\n        }\n      }\n\n      // According to ISO 32000-1:2008, section 12.6.4.7, URIs should be encoded\n      // in 7-bit ASCII. Some bad PDFs use UTF-8 encoding; see bug 1122280.\n      if (options.tryConvertEncoding) {\n        try {\n          url = stringToUTF8String(url);\n        } catch (ex) {}\n      }\n    }\n\n    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch (ex) {\n    /* `new URL()` will throw on incorrect data. */\n  }\n  return null;\n}\n\nfunction shadow(obj, prop, value) {\n  if (\n    typeof PDFJSDev === \"undefined\" ||\n    PDFJSDev.test(\"!PRODUCTION || TESTING\")\n  ) {\n    assert(\n      prop in obj,\n      `shadow: Property \"${prop && prop.toString()}\" not found in object.`\n    );\n  }\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: true,\n    configurable: true,\n    writable: false,\n  });\n  return value;\n}\n\n/**\n * @type {any}\n */\nconst BaseException = (function BaseExceptionClosure() {\n  // eslint-disable-next-line no-shadow\n  function BaseException(message, name) {\n    if (this.constructor === BaseException) {\n      unreachable(\"Cannot initialize BaseException.\");\n    }\n    this.message = message;\n    this.name = name;\n  }\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n\n  return BaseException;\n})();\n\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg, \"PasswordException\");\n    this.code = code;\n  }\n}\n\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg, \"UnknownErrorException\");\n    this.details = details;\n  }\n}\n\nclass InvalidPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"InvalidPDFException\");\n  }\n}\n\nclass MissingPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"MissingPDFException\");\n  }\n}\n\nclass UnexpectedResponseException extends BaseException {\n  constructor(msg, status) {\n    super(msg, \"UnexpectedResponseException\");\n    this.status = status;\n  }\n}\n\n/**\n * Error caused during parsing PDF data.\n */\nclass FormatError extends BaseException {\n  constructor(msg) {\n    super(msg, \"FormatError\");\n  }\n}\n\n/**\n * Error used to indicate task cancellation.\n */\nclass AbortException extends BaseException {\n  constructor(msg) {\n    super(msg, \"AbortException\");\n  }\n}\n\nconst NullCharactersRegExp = /\\x00+/g;\nconst InvisibleCharactersRegExp = /[\\x01-\\x1F]/g;\n\n/**\n * @param {string} str\n */\nfunction removeNullCharacters(str, replaceInvisible = false) {\n  if (typeof str !== \"string\") {\n    warn(\"The argument for removeNullCharacters must be a string.\");\n    return str;\n  }\n  if (replaceInvisible) {\n    str = str.replace(InvisibleCharactersRegExp, \" \");\n  }\n  return str.replace(NullCharactersRegExp, \"\");\n}\n\nfunction bytesToString(bytes) {\n  assert(\n    bytes !== null && typeof bytes === \"object\" && bytes.length !== undefined,\n    \"Invalid argument for bytesToString\"\n  );\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n  const strBuf = [];\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n  return strBuf.join(\"\");\n}\n\nfunction stringToBytes(str) {\n  assert(typeof str === \"string\", \"Invalid argument for stringToBytes\");\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n  return bytes;\n}\n\n/**\n * Gets length of the array (Array, Uint8Array, or string) in bytes.\n * @param {Array<any>|Uint8Array|string} arr\n * @returns {number}\n */\nfunction arrayByteLength(arr) {\n  if (arr.length !== undefined) {\n    return arr.length;\n  }\n  assert(arr.byteLength !== undefined, \"arrayByteLength - invalid argument.\");\n  return arr.byteLength;\n}\n\n/**\n * Combines array items (arrays) into single Uint8Array object.\n * @param {Array<Array<any>|Uint8Array|string>} arr - the array of the arrays\n *   (Array, Uint8Array, or string).\n * @returns {Uint8Array}\n */\nfunction arraysToBytes(arr) {\n  const length = arr.length;\n  // Shortcut: if first and only item is Uint8Array, return it.\n  if (length === 1 && arr[0] instanceof Uint8Array) {\n    return arr[0];\n  }\n  let resultLength = 0;\n  for (let i = 0; i < length; i++) {\n    resultLength += arrayByteLength(arr[i]);\n  }\n  let pos = 0;\n  const data = new Uint8Array(resultLength);\n  for (let i = 0; i < length; i++) {\n    let item = arr[i];\n    if (!(item instanceof Uint8Array)) {\n      if (typeof item === \"string\") {\n        item = stringToBytes(item);\n      } else {\n        item = new Uint8Array(item);\n      }\n    }\n    const itemLength = item.byteLength;\n    data.set(item, pos);\n    pos += itemLength;\n  }\n  return data;\n}\n\nfunction string32(value) {\n  if (\n    typeof PDFJSDev === \"undefined\" ||\n    PDFJSDev.test(\"!PRODUCTION || TESTING\")\n  ) {\n    assert(\n      typeof value === \"number\" && Math.abs(value) < 2 ** 32,\n      `string32: Unexpected input \"${value}\".`\n    );\n  }\n  return String.fromCharCode(\n    (value >> 24) & 0xff,\n    (value >> 16) & 0xff,\n    (value >> 8) & 0xff,\n    value & 0xff\n  );\n}\n\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\n\n// Ensure that the returned Object has a `null` prototype; hence why\n// `Object.fromEntries(...)` is not used.\nfunction objectFromMap(map) {\n  const obj = Object.create(null);\n  for (const [key, value] of map) {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Checks the endianness of the platform.\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\nconst IsLittleEndianCached = {\n  get value() {\n    return shadow(this, \"value\", isLittleEndian());\n  },\n};\n\n// Checks if it's possible to eval JS expressions.\nfunction isEvalSupported() {\n  try {\n    new Function(\"\"); // eslint-disable-line no-new, no-new-func\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nconst IsEvalSupportedCached = {\n  get value() {\n    return shadow(this, \"value\", isEvalSupported());\n  },\n};\n\nconst hexNumbers = [...Array(256).keys()].map(n =>\n  n.toString(16).padStart(2, \"0\")\n);\n\nclass Util {\n  static makeHexColor(r, g, b) {\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n  }\n\n  // Concatenates two transformation matrices together and returns the result.\n  static transform(m1, m2) {\n    return [\n      m1[0] * m2[0] + m1[2] * m2[1],\n      m1[1] * m2[0] + m1[3] * m2[1],\n      m1[0] * m2[2] + m1[2] * m2[3],\n      m1[1] * m2[2] + m1[3] * m2[3],\n      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n      m1[1] * m2[4] + m1[3] * m2[5] + m1[5],\n    ];\n  }\n\n  // For 2d affine transforms\n  static applyTransform(p, m) {\n    const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  }\n\n  static applyInverseTransform(p, m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  }\n\n  // Applies the transform to the rectangle and finds the minimum axially\n  // aligned bounding box.\n  static getAxialAlignedBoundingBox(r, m) {\n    const p1 = Util.applyTransform(r, m);\n    const p2 = Util.applyTransform(r.slice(2, 4), m);\n    const p3 = Util.applyTransform([r[0], r[3]], m);\n    const p4 = Util.applyTransform([r[2], r[1]], m);\n    return [\n      Math.min(p1[0], p2[0], p3[0], p4[0]),\n      Math.min(p1[1], p2[1], p3[1], p4[1]),\n      Math.max(p1[0], p2[0], p3[0], p4[0]),\n      Math.max(p1[1], p2[1], p3[1], p4[1]),\n    ];\n  }\n\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [\n      m[3] / d,\n      -m[1] / d,\n      -m[2] / d,\n      m[0] / d,\n      (m[2] * m[5] - m[4] * m[3]) / d,\n      (m[4] * m[1] - m[5] * m[0]) / d,\n    ];\n  }\n\n  // Apply a generic 3d matrix M on a 3-vector v:\n  //   | a b c |   | X |\n  //   | d e f | x | Y |\n  //   | g h i |   | Z |\n  // M is assumed to be serialized as [a,b,c,d,e,f,g,h,i],\n  // with v as [X,Y,Z]\n  static apply3dTransform(m, v) {\n    return [\n      m[0] * v[0] + m[1] * v[1] + m[2] * v[2],\n      m[3] * v[0] + m[4] * v[1] + m[5] * v[2],\n      m[6] * v[0] + m[7] * v[1] + m[8] * v[2],\n    ];\n  }\n\n  // This calculation uses Singular Value Decomposition.\n  // The SVD can be represented with formula A = USV. We are interested in the\n  // matrix S here because it represents the scale values.\n  static singularValueDecompose2dScale(m) {\n    const transpose = [m[0], m[2], m[1], m[3]];\n\n    // Multiply matrix m with its transpose.\n    const a = m[0] * transpose[0] + m[1] * transpose[2];\n    const b = m[0] * transpose[1] + m[1] * transpose[3];\n    const c = m[2] * transpose[0] + m[3] * transpose[2];\n    const d = m[2] * transpose[1] + m[3] * transpose[3];\n\n    // Solve the second degree polynomial to get roots.\n    const first = (a + d) / 2;\n    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n    const sx = first + second || 1;\n    const sy = first - second || 1;\n\n    // Scale values are the square roots of the eigenvalues.\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  }\n\n  // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) < (x2,y2)\n  // For coordinate systems whose origin lies in the bottom-left, this\n  // means normalization to (BL,TR) ordering. For systems with origin in the\n  // top-left, this means (TL,BR) ordering.\n  static normalizeRect(rect) {\n    const r = rect.slice(0); // clone rect\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n    return r;\n  }\n\n  // Returns a rectangle [x1, y1, x2, y2] corresponding to the\n  // intersection of rect1 and rect2. If no intersection, returns 'false'\n  // The rectangle coordinates of rect1, rect2 should be [x1, y1, x2, y2]\n  static intersect(rect1, rect2) {\n    function compare(a, b) {\n      return a - b;\n    }\n\n    // Order points along the axes\n    const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);\n    const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);\n    const result = [];\n\n    rect1 = Util.normalizeRect(rect1);\n    rect2 = Util.normalizeRect(rect2);\n\n    // X: first and second points belong to different rectangles?\n    if (\n      (orderedX[0] === rect1[0] && orderedX[1] === rect2[0]) ||\n      (orderedX[0] === rect2[0] && orderedX[1] === rect1[0])\n    ) {\n      // Intersection must be between second and third points\n      result[0] = orderedX[1];\n      result[2] = orderedX[2];\n    } else {\n      return null;\n    }\n\n    // Y: first and second points belong to different rectangles?\n    if (\n      (orderedY[0] === rect1[1] && orderedY[1] === rect2[1]) ||\n      (orderedY[0] === rect2[1] && orderedY[1] === rect1[1])\n    ) {\n      // Intersection must be between second and third points\n      result[1] = orderedY[1];\n      result[3] = orderedY[2];\n    } else {\n      return null;\n    }\n\n    return result;\n  }\n\n  // From https://github.com/adobe-webplatform/Snap.svg/blob/b365287722a72526000ac4bfcf0ce4cac2faa015/src/path.js#L852\n  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const tvalues = [],\n      bounds = [[], []];\n    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n    for (let i = 0; i < 2; ++i) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue;\n        }\n        t = -c / b;\n        if (0 < t && t < 1) {\n          tvalues.push(t);\n        }\n        continue;\n      }\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = Math.sqrt(b2ac);\n      if (b2ac < 0) {\n        continue;\n      }\n      t1 = (-b + sqrtb2ac) / (2 * a);\n      if (0 < t1 && t1 < 1) {\n        tvalues.push(t1);\n      }\n      t2 = (-b - sqrtb2ac) / (2 * a);\n      if (0 < t2 && t2 < 1) {\n        tvalues.push(t2);\n      }\n    }\n\n    let j = tvalues.length,\n      mt;\n    const jlen = j;\n    while (j--) {\n      t = tvalues[j];\n      mt = 1 - t;\n      bounds[0][j] =\n        mt * mt * mt * x0 +\n        3 * mt * mt * t * x1 +\n        3 * mt * t * t * x2 +\n        t * t * t * x3;\n      bounds[1][j] =\n        mt * mt * mt * y0 +\n        3 * mt * mt * t * y1 +\n        3 * mt * t * t * y2 +\n        t * t * t * y3;\n    }\n\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    bounds[0].length = bounds[1].length = jlen + 2;\n\n    return [\n      Math.min(...bounds[0]),\n      Math.min(...bounds[1]),\n      Math.max(...bounds[0]),\n      Math.max(...bounds[1]),\n    ];\n  }\n}\n\nconst PDFStringTranslateTable = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8,\n  0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192,\n  0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018,\n  0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d,\n  0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac,\n];\n\nfunction stringToPDFString(str) {\n  const length = str.length,\n    strBuf = [];\n  if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n    // UTF16BE BOM\n    for (let i = 2; i < length; i += 2) {\n      strBuf.push(\n        String.fromCharCode((str.charCodeAt(i) << 8) | str.charCodeAt(i + 1))\n      );\n    }\n  } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n    // UTF16LE BOM\n    for (let i = 2; i < length; i += 2) {\n      strBuf.push(\n        String.fromCharCode((str.charCodeAt(i + 1) << 8) | str.charCodeAt(i))\n      );\n    }\n  } else {\n    for (let i = 0; i < length; ++i) {\n      const code = PDFStringTranslateTable[str.charCodeAt(i)];\n      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n  }\n  return strBuf.join(\"\");\n}\n\nfunction escapeString(str) {\n  // replace \"(\", \")\", \"\\n\", \"\\r\" and \"\\\"\n  // by \"\\(\", \"\\)\", \"\\\\n\", \"\\\\r\" and \"\\\\\"\n  // in order to write it in a PDF file.\n  return str.replace(/([()\\\\\\n\\r])/g, match => {\n    if (match === \"\\n\") {\n      return \"\\\\n\";\n    } else if (match === \"\\r\") {\n      return \"\\\\r\";\n    }\n    return `\\\\${match}`;\n  });\n}\n\nfunction isAscii(str) {\n  return /^[\\x00-\\x7F]*$/.test(str);\n}\n\nfunction stringToUTF16BEString(str) {\n  const buf = [\"\\xFE\\xFF\"];\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const char = str.charCodeAt(i);\n    buf.push(\n      String.fromCharCode((char >> 8) & 0xff),\n      String.fromCharCode(char & 0xff)\n    );\n  }\n  return buf.join(\"\");\n}\n\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\n\nfunction isBool(v) {\n  return typeof v === \"boolean\";\n}\n\nfunction isNum(v) {\n  return typeof v === \"number\";\n}\n\nfunction isString(v) {\n  return typeof v === \"string\";\n}\n\nfunction isArrayBuffer(v) {\n  return typeof v === \"object\" && v !== null && v.byteLength !== undefined;\n}\n\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0, ii = arr1.length; i < ii; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getModificationDate(date = new Date()) {\n  const buffer = [\n    date.getUTCFullYear().toString(),\n    (date.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n    date.getUTCDate().toString().padStart(2, \"0\"),\n    date.getUTCHours().toString().padStart(2, \"0\"),\n    date.getUTCMinutes().toString().padStart(2, \"0\"),\n    date.getUTCSeconds().toString().padStart(2, \"0\"),\n  ];\n\n  return buffer.join(\"\");\n}\n\n/**\n * Promise Capability object.\n *\n * @typedef {Object} PromiseCapability\n * @property {Promise<any>} promise - A Promise object.\n * @property {boolean} settled - If the Promise has been fulfilled/rejected.\n * @property {function} resolve - Fulfills the Promise.\n * @property {function} reject - Rejects the Promise.\n */\n\n/**\n * Creates a promise capability object.\n * @alias createPromiseCapability\n *\n * @returns {PromiseCapability}\n */\nfunction createPromiseCapability() {\n  const capability = Object.create(null);\n  let isSettled = false;\n\n  Object.defineProperty(capability, \"settled\", {\n    get() {\n      return isSettled;\n    },\n  });\n  capability.promise = new Promise(function (resolve, reject) {\n    capability.resolve = function (data) {\n      isSettled = true;\n      resolve(data);\n    };\n    capability.reject = function (reason) {\n      isSettled = true;\n      reject(reason);\n    };\n  });\n  return capability;\n}\n\nfunction createObjectURL(data, contentType = \"\", forceDataSchema = false) {\n  if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) {\n    return URL.createObjectURL(new Blob([data], { type: contentType }));\n  }\n  // Blob/createObjectURL is not available, falling back to data schema.\n  const digits =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n  let buffer = `data:${contentType};base64,`;\n  for (let i = 0, ii = data.length; i < ii; i += 3) {\n    const b1 = data[i] & 0xff;\n    const b2 = data[i + 1] & 0xff;\n    const b3 = data[i + 2] & 0xff;\n    const d1 = b1 >> 2,\n      d2 = ((b1 & 3) << 4) | (b2 >> 4);\n    const d3 = i + 1 < ii ? ((b2 & 0xf) << 2) | (b3 >> 6) : 64;\n    const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n  }\n  return buffer;\n}\n\nexport {\n  AbortException,\n  AnnotationActionEventType,\n  AnnotationBorderStyleType,\n  AnnotationFieldFlag,\n  AnnotationFlag,\n  AnnotationMarkedState,\n  AnnotationMode,\n  AnnotationReplyType,\n  AnnotationReviewState,\n  AnnotationStateModelType,\n  AnnotationType,\n  arrayByteLength,\n  arraysToBytes,\n  assert,\n  BaseException,\n  bytesToString,\n  CMapCompressionType,\n  createObjectURL,\n  createPromiseCapability,\n  createValidAbsoluteUrl,\n  DocumentActionEventType,\n  escapeString,\n  FONT_IDENTITY_MATRIX,\n  FontType,\n  FormatError,\n  getModificationDate,\n  getVerbosityLevel,\n  IDENTITY_MATRIX,\n  ImageKind,\n  info,\n  InvalidPDFException,\n  isArrayBuffer,\n  isArrayEqual,\n  isAscii,\n  isBool,\n  IsEvalSupportedCached,\n  IsLittleEndianCached,\n  isNum,\n  isSameOrigin,\n  isString,\n  MissingPDFException,\n  objectFromMap,\n  objectSize,\n  OPS,\n  PageActionEventType,\n  PasswordException,\n  PasswordResponses,\n  PermissionFlag,\n  removeNullCharacters,\n  RenderingIntentFlag,\n  setVerbosityLevel,\n  shadow,\n  StreamType,\n  string32,\n  stringToBytes,\n  stringToPDFString,\n  stringToUTF16BEString,\n  stringToUTF8String,\n  TextRenderingMode,\n  UnexpectedResponseException,\n  UnknownErrorException,\n  unreachable,\n  UNSUPPORTED_FEATURES,\n  utf8StringToString,\n  Util,\n  VerbosityLevel,\n  warn,\n};\n","/* Copyright 2017 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isNodeJS } from \"./is_node.js\";\n\n// Skip compatibility checks for modern builds and if we already ran the module.\nif (\n  (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"SKIP_BABEL\")) &&\n  (typeof globalThis === \"undefined\" || !globalThis._pdfjsCompatibilityChecked)\n) {\n  // Provides support for `globalThis` in legacy browsers.\n  // Support: Firefox<65, Chrome<71, Safari<12.1, Node.js<12.0.0\n  if (typeof globalThis === \"undefined\" || globalThis.Math !== Math) {\n    // eslint-disable-next-line no-global-assign\n    globalThis = require(\"core-js/es/global-this\");\n  }\n  globalThis._pdfjsCompatibilityChecked = true;\n\n  // Support: Node.js\n  (function checkNodeBtoa() {\n    if (globalThis.btoa || !isNodeJS) {\n      return;\n    }\n    globalThis.btoa = function (chars) {\n      // eslint-disable-next-line no-undef\n      return Buffer.from(chars, \"binary\").toString(\"base64\");\n    };\n  })();\n\n  // Support: Node.js\n  (function checkNodeAtob() {\n    if (globalThis.atob || !isNodeJS) {\n      return;\n    }\n    globalThis.atob = function (input) {\n      // eslint-disable-next-line no-undef\n      return Buffer.from(input, \"base64\").toString(\"binary\");\n    };\n  })();\n\n  // Support: Node.js\n  (function checkDOMMatrix() {\n    if (globalThis.DOMMatrix || !isNodeJS) {\n      return;\n    }\n    globalThis.DOMMatrix = require(\"dommatrix/dist/dommatrix.js\");\n  })();\n\n  // Provides support for Object.fromEntries in legacy browsers.\n  // Support: Firefox<63, Chrome<73, Safari<12.1, Node.js<12.0.0\n  (function checkObjectFromEntries() {\n    if (Object.fromEntries) {\n      return;\n    }\n    require(\"core-js/es/object/from-entries.js\");\n  })();\n\n  // Provides support for *recent* additions to the Promise specification,\n  // however basic Promise support is assumed to be available natively.\n  // Support: Firefox<71, Chrome<76, Safari<13, Node.js<12.9.0\n  (function checkPromise() {\n    if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"IMAGE_DECODERS\")) {\n      // The current image decoders are synchronous, hence `Promise` shouldn't\n      // need to be polyfilled for the IMAGE_DECODERS build target.\n      return;\n    }\n    if (globalThis.Promise.allSettled) {\n      return;\n    }\n    globalThis.Promise = require(\"core-js/es/promise/index.js\");\n  })();\n\n  // Support: Node.js\n  (function checkReadableStream() {\n    if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"IMAGE_DECODERS\")) {\n      // The current image decoders are synchronous, hence `ReadableStream`\n      // shouldn't need to be polyfilled for the IMAGE_DECODERS build target.\n      return;\n    }\n    if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"CHROME\")) {\n      // Slightly reduce the size of the Chromium-extension, given\n      // that `ReadableStream` has been supported since Chrome 43.\n      return;\n    }\n    if (globalThis.ReadableStream || !isNodeJS) {\n      return;\n    }\n    globalThis.ReadableStream =\n      require(\"web-streams-polyfill/dist/ponyfill.js\").ReadableStream;\n  })();\n}\n","/* Copyright 2018 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* globals process */\n\n// NW.js / Electron is a browser context, but copies some Node.js objects; see\n// http://docs.nwjs.io/en/latest/For%20Users/Advanced/JavaScript%20Contexts%20in%20NW.js/#access-nodejs-and-nwjs-api-in-browser-context\n// https://www.electronjs.org/docs/api/process#processversionselectron-readonly\n// https://www.electronjs.org/docs/api/process#processtype-readonly\nconst isNodeJS =\n  typeof process === \"object\" &&\n  process + \"\" === \"[object process]\" &&\n  !process.versions.nw &&\n  !(process.versions.electron && process.type && process.type !== \"browser\");\n\nexport { isNodeJS };\n","/* Copyright 2015 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CMapCompressionType, unreachable } from \"../shared/util.js\";\n\nclass BaseCanvasFactory {\n  constructor() {\n    if (this.constructor === BaseCanvasFactory) {\n      unreachable(\"Cannot initialize BaseCanvasFactory.\");\n    }\n  }\n\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    const canvas = this._createCanvas(width, height);\n    return {\n      canvas,\n      context: canvas.getContext(\"2d\"),\n    };\n  }\n\n  reset(canvasAndContext, width, height) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n\n  destroy(canvasAndContext) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    // Zeroing the width and height cause Firefox to release graphics\n    // resources immediately, which can greatly reduce memory consumption.\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n\n  /**\n   * @private\n   */\n  _createCanvas(width, height) {\n    unreachable(\"Abstract method `_createCanvas` called.\");\n  }\n}\n\nclass BaseCMapReaderFactory {\n  constructor({ baseUrl = null, isCompressed = false }) {\n    if (this.constructor === BaseCMapReaderFactory) {\n      unreachable(\"Cannot initialize BaseCMapReaderFactory.\");\n    }\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n\n  async fetch({ name }) {\n    if (!this.baseUrl) {\n      throw new Error(\n        'The CMap \"baseUrl\" parameter must be specified, ensure that ' +\n          'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.'\n      );\n    }\n    if (!name) {\n      throw new Error(\"CMap name must be specified.\");\n    }\n    const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n    const compressionType = this.isCompressed\n      ? CMapCompressionType.BINARY\n      : CMapCompressionType.NONE;\n\n    return this._fetchData(url, compressionType).catch(reason => {\n      throw new Error(\n        `Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`\n      );\n    });\n  }\n\n  /**\n   * @private\n   */\n  _fetchData(url, compressionType) {\n    unreachable(\"Abstract method `_fetchData` called.\");\n  }\n}\n\nclass BaseStandardFontDataFactory {\n  constructor({ baseUrl = null }) {\n    if (this.constructor === BaseStandardFontDataFactory) {\n      unreachable(\"Cannot initialize BaseStandardFontDataFactory.\");\n    }\n    this.baseUrl = baseUrl;\n  }\n\n  async fetch({ filename }) {\n    if (!this.baseUrl) {\n      throw new Error(\n        'The standard font \"baseUrl\" parameter must be specified, ensure that ' +\n          'the \"standardFontDataUrl\" API parameter is provided.'\n      );\n    }\n    if (!filename) {\n      throw new Error(\"Font filename must be specified.\");\n    }\n    const url = `${this.baseUrl}${filename}`;\n\n    return this._fetchData(url).catch(reason => {\n      throw new Error(`Unable to load font data at: ${url}`);\n    });\n  }\n\n  /**\n   * @private\n   */\n  _fetchData(url) {\n    unreachable(\"Abstract method `_fetchData` called.\");\n  }\n}\n\nclass BaseSVGFactory {\n  constructor() {\n    if (this.constructor === BaseSVGFactory) {\n      unreachable(\"Cannot initialize BaseSVGFactory.\");\n    }\n  }\n\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid SVG dimensions\");\n    }\n    const svg = this._createSVG(\"svg:svg\");\n    svg.setAttribute(\"version\", \"1.1\");\n    svg.setAttribute(\"width\", `${width}px`);\n    svg.setAttribute(\"height\", `${height}px`);\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n\n    return svg;\n  }\n\n  createElement(type) {\n    if (typeof type !== \"string\") {\n      throw new Error(\"Invalid SVG element type\");\n    }\n    return this._createSVG(type);\n  }\n\n  /**\n   * @private\n   */\n  _createSVG(type) {\n    unreachable(\"Abstract method `_createSVG` called.\");\n  }\n}\n\nexport {\n  BaseCanvasFactory,\n  BaseCMapReaderFactory,\n  BaseStandardFontDataFactory,\n  BaseSVGFactory,\n};\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @module pdfjsLib\n */\n\nimport {\n  AbortException,\n  AnnotationMode,\n  assert,\n  createPromiseCapability,\n  getVerbosityLevel,\n  info,\n  InvalidPDFException,\n  isArrayBuffer,\n  isSameOrigin,\n  MissingPDFException,\n  PasswordException,\n  RenderingIntentFlag,\n  setVerbosityLevel,\n  shadow,\n  stringToBytes,\n  UnexpectedResponseException,\n  UnknownErrorException,\n  unreachable,\n  warn,\n} from \"../shared/util.js\";\nimport {\n  deprecated,\n  DOMCanvasFactory,\n  DOMCMapReaderFactory,\n  DOMStandardFontDataFactory,\n  isDataScheme,\n  loadScript,\n  PageViewport,\n  RenderingCancelledException,\n  StatTimer,\n} from \"./display_utils.js\";\nimport { FontFaceObject, FontLoader } from \"./font_loader.js\";\nimport {\n  NodeCanvasFactory,\n  NodeCMapReaderFactory,\n  NodeStandardFontDataFactory,\n} from \"./node_utils.js\";\nimport { AnnotationStorage } from \"./annotation_storage.js\";\nimport { CanvasGraphics } from \"./canvas.js\";\nimport { GlobalWorkerOptions } from \"./worker_options.js\";\nimport { isNodeJS } from \"../shared/is_node.js\";\nimport { MessageHandler } from \"../shared/message_handler.js\";\nimport { Metadata } from \"./metadata.js\";\nimport { OptionalContentConfig } from \"./optional_content_config.js\";\nimport { PDFDataTransportStream } from \"./transport_stream.js\";\nimport { XfaText } from \"./xfa_text.js\";\n\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536; // 2^16 = 65536\nconst RENDERING_CANCELLED_TIMEOUT = 100; // ms\n\nconst DefaultCanvasFactory =\n  (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) && isNodeJS\n    ? NodeCanvasFactory\n    : DOMCanvasFactory;\nconst DefaultCMapReaderFactory =\n  (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) && isNodeJS\n    ? NodeCMapReaderFactory\n    : DOMCMapReaderFactory;\nconst DefaultStandardFontDataFactory =\n  (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) && isNodeJS\n    ? NodeStandardFontDataFactory\n    : DOMStandardFontDataFactory;\n\n/**\n * @typedef {function} IPDFStreamFactory\n * @param {DocumentInitParameters} params - The document initialization\n *   parameters. The \"url\" key is always present.\n * @returns {Promise} A promise, which is resolved with an instance of\n *   {IPDFStream}.\n * @ignore\n */\n\n/**\n * @type IPDFStreamFactory\n * @private\n */\nlet createPDFNetworkStream;\n\n/**\n * Sets the function that instantiates an {IPDFStream} as an alternative PDF\n * data transport.\n *\n * @param {IPDFStreamFactory} pdfNetworkStreamFactory - The factory function\n *   that takes document initialization parameters (including a \"url\") and\n *   returns a promise which is resolved with an instance of {IPDFStream}.\n * @ignore\n */\nfunction setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\n  createPDFNetworkStream = pdfNetworkStreamFactory;\n}\n\n/**\n * @typedef { Int8Array | Uint8Array | Uint8ClampedArray |\n *            Int16Array | Uint16Array |\n *            Int32Array | Uint32Array | Float32Array |\n *            Float64Array\n * } TypedArray\n */\n\n/**\n * @typedef {Object} RefProxy\n * @property {number} num\n * @property {number} gen\n */\n\n/**\n * Document initialization / loading parameters object.\n *\n * @typedef {Object} DocumentInitParameters\n * @property {string|URL} [url] - The URL of the PDF.\n * @property {TypedArray|Array<number>|string} [data] - Binary PDF data. Use\n *    typed arrays (Uint8Array) to improve the memory usage. If PDF data is\n *    BASE64-encoded, use `atob()` to convert it to a binary string first.\n * @property {Object} [httpHeaders] - Basic authentication headers.\n * @property {boolean} [withCredentials] - Indicates whether or not\n *   cross-site Access-Control requests should be made using credentials such\n *   as cookies or authorization headers. The default is `false`.\n * @property {string} [password] - For decrypting password-protected PDFs.\n * @property {TypedArray} [initialData] - A typed array with the first portion\n *   or all of the pdf data. Used by the extension since some data is already\n *   loaded before the switch to range requests.\n * @property {number} [length] - The PDF file length. It's used for progress\n *   reports and range requests operations.\n * @property {PDFDataRangeTransport} [range] - Allows for using a custom range\n *   transport implementation.\n * @property {number} [rangeChunkSize] - Specify maximum number of bytes fetched\n *   per range request. The default value is {@link DEFAULT_RANGE_CHUNK_SIZE}.\n * @property {PDFWorker} [worker] - The worker that will be used for loading and\n *   parsing the PDF data.\n * @property {number} [verbosity] - Controls the logging level; the constants\n *   from {@link VerbosityLevel} should be used.\n * @property {string} [docBaseUrl] - The base URL of the document, used when\n *   attempting to recover valid absolute URLs for annotations, and outline\n *   items, that (incorrectly) only specify relative URLs.\n * @property {string} [cMapUrl] - The URL where the predefined Adobe CMaps are\n *   located. Include the trailing slash.\n * @property {boolean} [cMapPacked] - Specifies if the Adobe CMaps are binary\n *   packed or not.\n * @property {Object} [CMapReaderFactory] - The factory that will be used when\n *   reading built-in CMap files. Providing a custom factory is useful for\n *   environments without Fetch API or `XMLHttpRequest` support, such as\n *   Node.js. The default value is {DOMCMapReaderFactory}.\n * @property {boolean} [useSystemFonts] - When `true`, fonts that aren't\n *   embedded in the PDF document will fallback to a system font.\n *   The default value is `true` in web environments and `false` in Node.js;\n *   unless `disableFontFace === true` in which case this defaults to `false`\n *   regardless of the environment (to prevent completely broken fonts).\n * @property {string} [standardFontDataUrl] - The URL where the standard font\n *   files are located. Include the trailing slash.\n * @property {Object} [StandardFontDataFactory] - The factory that will be used\n *   when reading the standard font files. Providing a custom factory is useful\n *   for environments without Fetch API or `XMLHttpRequest` support, such as\n *   Node.js. The default value is {DOMStandardFontDataFactory}.\n * @property {boolean} [useWorkerFetch] - Enable using the Fetch API in the\n *   worker-thread when reading CMap and standard font files. When `true`,\n *   the `CMapReaderFactory` and `StandardFontDataFactory` options are ignored.\n *   The default value is `true` in web environments and `false` in Node.js.\n * @property {boolean} [stopAtErrors] - Reject certain promises, e.g.\n *   `getOperatorList`, `getTextContent`, and `RenderTask`, when the associated\n *   PDF data cannot be successfully parsed, instead of attempting to recover\n *   whatever possible of the data. The default value is `false`.\n * @property {number} [maxImageSize] - The maximum allowed image size in total\n *   pixels, i.e. width * height. Images above this value will not be rendered.\n *   Use -1 for no limit, which is also the default value.\n * @property {boolean} [isEvalSupported] - Determines if we can evaluate strings\n *   as JavaScript. Primarily used to improve performance of font rendering, and\n *   when parsing PDF functions. The default value is `true`.\n * @property {boolean} [disableFontFace] - By default fonts are converted to\n *   OpenType fonts and loaded via the Font Loading API or `@font-face` rules.\n *   If disabled, fonts will be rendered using a built-in font renderer that\n *   constructs the glyphs with primitive path commands.\n *   The default value is `false` in web environments and `true` in Node.js.\n * @property {boolean} [fontExtraProperties] - Include additional properties,\n *   which are unused during rendering of PDF documents, when exporting the\n *   parsed font data from the worker-thread. This may be useful for debugging\n *   purposes (and backwards compatibility), but note that it will lead to\n *   increased memory usage. The default value is `false`.\n * @property {boolean} [enableXfa] - Render Xfa forms if any.\n *   The default value is `false`.\n * @property {HTMLDocument} [ownerDocument] - Specify an explicit document\n *   context to create elements with and to load resources, such as fonts,\n *   into. Defaults to the current document.\n * @property {boolean} [disableRange] - Disable range request loading of PDF\n *   files. When enabled, and if the server supports partial content requests,\n *   then the PDF will be fetched in chunks. The default value is `false`.\n * @property {boolean} [disableStream] - Disable streaming of PDF file data.\n *   By default PDF.js attempts to load PDF files in chunks. The default value\n *   is `false`.\n * @property {boolean} [disableAutoFetch] - Disable pre-fetching of PDF file\n *   data. When range requests are enabled PDF.js will automatically keep\n *   fetching more data even if it isn't needed to display the current page.\n *   The default value is `false`.\n *\n *   NOTE: It is also necessary to disable streaming, see above, in order for\n *   disabling of pre-fetching to work correctly.\n * @property {boolean} [pdfBug] - Enables special hooks for debugging PDF.js\n *   (see `web/debugger.js`). The default value is `false`.\n */\n\n/**\n * This is the main entry point for loading a PDF and interacting with it.\n *\n * NOTE: If a URL is used to fetch the PDF data a standard Fetch API call (or\n * XHR as fallback) is used, which means it must follow same origin rules,\n * e.g. no cross-domain requests without CORS.\n *\n * @param {string|URL|TypedArray|PDFDataRangeTransport|DocumentInitParameters}\n *   src - Can be a URL where a PDF file is located, a typed array (Uint8Array)\n *         already populated with data, or a parameter object.\n * @returns {PDFDocumentLoadingTask}\n */\nfunction getDocument(src) {\n  const task = new PDFDocumentLoadingTask();\n\n  let source;\n  if (typeof src === \"string\" || src instanceof URL) {\n    source = { url: src };\n  } else if (isArrayBuffer(src)) {\n    source = { data: src };\n  } else if (src instanceof PDFDataRangeTransport) {\n    source = { range: src };\n  } else {\n    if (typeof src !== \"object\") {\n      throw new Error(\n        \"Invalid parameter in getDocument, \" +\n          \"need either string, URL, Uint8Array, or parameter object.\"\n      );\n    }\n    if (!src.url && !src.data && !src.range) {\n      throw new Error(\n        \"Invalid parameter object: need either .data, .range or .url\"\n      );\n    }\n    source = src;\n  }\n  const params = Object.create(null);\n  let rangeTransport = null,\n    worker = null;\n\n  for (const key in source) {\n    const value = source[key];\n\n    switch (key) {\n      case \"url\":\n        if (typeof window !== \"undefined\") {\n          try {\n            // The full path is required in the 'url' field.\n            params[key] = new URL(value, window.location).href;\n            continue;\n          } catch (ex) {\n            warn(`Cannot create valid URL: \"${ex}\".`);\n          }\n        } else if (typeof value === \"string\" || value instanceof URL) {\n          params[key] = value.toString(); // Support Node.js environments.\n          continue;\n        }\n        throw new Error(\n          \"Invalid PDF url data: \" +\n            \"either string or URL-object is expected in the url property.\"\n        );\n      case \"range\":\n        rangeTransport = value;\n        continue;\n      case \"worker\":\n        worker = value;\n        continue;\n      case \"data\":\n        // Converting string or array-like data to Uint8Array.\n        if (\n          typeof PDFJSDev !== \"undefined\" &&\n          PDFJSDev.test(\"GENERIC\") &&\n          isNodeJS &&\n          typeof Buffer !== \"undefined\" && // eslint-disable-line no-undef\n          value instanceof Buffer // eslint-disable-line no-undef\n        ) {\n          params[key] = new Uint8Array(value);\n        } else if (value instanceof Uint8Array) {\n          break; // Use the data as-is when it's already a Uint8Array.\n        } else if (typeof value === \"string\") {\n          params[key] = stringToBytes(value);\n        } else if (\n          typeof value === \"object\" &&\n          value !== null &&\n          !isNaN(value.length)\n        ) {\n          params[key] = new Uint8Array(value);\n        } else if (isArrayBuffer(value)) {\n          params[key] = new Uint8Array(value);\n        } else {\n          throw new Error(\n            \"Invalid PDF binary data: either typed array, \" +\n              \"string, or array-like object is expected in the data property.\"\n          );\n        }\n        continue;\n    }\n    params[key] = value;\n  }\n\n  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;\n  params.CMapReaderFactory =\n    params.CMapReaderFactory || DefaultCMapReaderFactory;\n  params.StandardFontDataFactory =\n    params.StandardFontDataFactory || DefaultStandardFontDataFactory;\n  params.ignoreErrors = params.stopAtErrors !== true;\n  params.fontExtraProperties = params.fontExtraProperties === true;\n  params.pdfBug = params.pdfBug === true;\n  params.enableXfa = params.enableXfa === true;\n\n  if (\n    typeof params.docBaseUrl !== \"string\" ||\n    isDataScheme(params.docBaseUrl)\n  ) {\n    // Ignore \"data:\"-URLs, since they can't be used to recover valid absolute\n    // URLs anyway. We want to avoid sending them to the worker-thread, since\n    // they contain the *entire* PDF document and can thus be arbitrarily long.\n    params.docBaseUrl = null;\n  }\n  if (!Number.isInteger(params.maxImageSize)) {\n    params.maxImageSize = -1;\n  }\n  if (typeof params.useWorkerFetch !== \"boolean\") {\n    params.useWorkerFetch =\n      params.CMapReaderFactory === DOMCMapReaderFactory &&\n      params.StandardFontDataFactory === DOMStandardFontDataFactory;\n  }\n  if (typeof params.isEvalSupported !== \"boolean\") {\n    params.isEvalSupported = true;\n  }\n  if (typeof params.disableFontFace !== \"boolean\") {\n    params.disableFontFace =\n      (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) && isNodeJS;\n  }\n  if (typeof params.useSystemFonts !== \"boolean\") {\n    params.useSystemFonts =\n      !(\n        (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) &&\n        isNodeJS\n      ) && !params.disableFontFace;\n  }\n  if (typeof params.ownerDocument === \"undefined\") {\n    params.ownerDocument = globalThis.document;\n  }\n\n  if (typeof params.disableRange !== \"boolean\") {\n    params.disableRange = false;\n  }\n  if (typeof params.disableStream !== \"boolean\") {\n    params.disableStream = false;\n  }\n  if (typeof params.disableAutoFetch !== \"boolean\") {\n    params.disableAutoFetch = false;\n  }\n\n  // Set the main-thread verbosity level.\n  setVerbosityLevel(params.verbosity);\n\n  if (!worker) {\n    const workerParams = {\n      verbosity: params.verbosity,\n      port: GlobalWorkerOptions.workerPort,\n    };\n    // Worker was not provided -- creating and owning our own. If message port\n    // is specified in global worker options, using it.\n    worker = workerParams.port\n      ? PDFWorker.fromPort(workerParams)\n      : new PDFWorker(workerParams);\n    task._worker = worker;\n  }\n  const docId = task.docId;\n  worker.promise\n    .then(function () {\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n\n      const workerIdPromise = _fetchDocument(\n        worker,\n        params,\n        rangeTransport,\n        docId\n      );\n      const networkStreamPromise = new Promise(function (resolve) {\n        let networkStream;\n        if (rangeTransport) {\n          networkStream = new PDFDataTransportStream(\n            {\n              length: params.length,\n              initialData: params.initialData,\n              progressiveDone: params.progressiveDone,\n              contentDispositionFilename: params.contentDispositionFilename,\n              disableRange: params.disableRange,\n              disableStream: params.disableStream,\n            },\n            rangeTransport\n          );\n        } else if (!params.data) {\n          networkStream = createPDFNetworkStream({\n            url: params.url,\n            length: params.length,\n            httpHeaders: params.httpHeaders,\n            withCredentials: params.withCredentials,\n            rangeChunkSize: params.rangeChunkSize,\n            disableRange: params.disableRange,\n            disableStream: params.disableStream,\n          });\n        }\n        resolve(networkStream);\n      });\n\n      return Promise.all([workerIdPromise, networkStreamPromise]).then(\n        function ([workerId, networkStream]) {\n          if (task.destroyed) {\n            throw new Error(\"Loading aborted\");\n          }\n\n          const messageHandler = new MessageHandler(\n            docId,\n            workerId,\n            worker.port\n          );\n          const transport = new WorkerTransport(\n            messageHandler,\n            task,\n            networkStream,\n            params\n          );\n          task._transport = transport;\n          messageHandler.send(\"Ready\", null);\n        }\n      );\n    })\n    .catch(task._capability.reject);\n\n  return task;\n}\n\n/**\n * Starts fetching of specified PDF document/data.\n *\n * @param {PDFWorker} worker\n * @param {Object} source\n * @param {PDFDataRangeTransport} pdfDataRangeTransport\n * @param {string} docId - Unique document ID, used in `MessageHandler`.\n * @returns {Promise<string>} A promise that is resolved when the worker ID of\n *   the `MessageHandler` is known.\n * @private\n */\nasync function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n\n  if (pdfDataRangeTransport) {\n    source.length = pdfDataRangeTransport.length;\n    source.initialData = pdfDataRangeTransport.initialData;\n    source.progressiveDone = pdfDataRangeTransport.progressiveDone;\n    source.contentDispositionFilename =\n      pdfDataRangeTransport.contentDispositionFilename;\n  }\n  const workerId = await worker.messageHandler.sendWithPromise(\n    \"GetDocRequest\",\n    {\n      docId,\n      apiVersion:\n        typeof PDFJSDev !== \"undefined\" && !PDFJSDev.test(\"TESTING\")\n          ? PDFJSDev.eval(\"BUNDLE_VERSION\")\n          : null,\n      // Only send the required properties, and *not* the entire object.\n      source: {\n        data: source.data,\n        url: source.url,\n        password: source.password,\n        disableAutoFetch: source.disableAutoFetch,\n        rangeChunkSize: source.rangeChunkSize,\n        length: source.length,\n      },\n      maxImageSize: source.maxImageSize,\n      disableFontFace: source.disableFontFace,\n      docBaseUrl: source.docBaseUrl,\n      ignoreErrors: source.ignoreErrors,\n      isEvalSupported: source.isEvalSupported,\n      fontExtraProperties: source.fontExtraProperties,\n      enableXfa: source.enableXfa,\n      useSystemFonts: source.useSystemFonts,\n      cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,\n      standardFontDataUrl: source.useWorkerFetch\n        ? source.standardFontDataUrl\n        : null,\n    }\n  );\n\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n  return workerId;\n}\n\n/**\n * @typedef {Object} OnProgressParameters\n * @property {number} loaded - Currently loaded number of bytes.\n * @property {number} total - Total number of bytes in the PDF file.\n */\n\n/**\n * The loading task controls the operations required to load a PDF document\n * (such as network requests) and provides a way to listen for completion,\n * after which individual pages can be rendered.\n */\nclass PDFDocumentLoadingTask {\n  static get idCounters() {\n    return shadow(this, \"idCounters\", { doc: 0 });\n  }\n\n  constructor() {\n    this._capability = createPromiseCapability();\n    this._transport = null;\n    this._worker = null;\n\n    /**\n     * Unique identifier for the document loading task.\n     * @type {string}\n     */\n    this.docId = `d${PDFDocumentLoadingTask.idCounters.doc++}`;\n\n    /**\n     * Whether the loading task is destroyed or not.\n     * @type {boolean}\n     */\n    this.destroyed = false;\n\n    /**\n     * Callback to request a password if a wrong or no password was provided.\n     * The callback receives two parameters: a function that should be called\n     * with the new password, and a reason (see {@link PasswordResponses}).\n     * @type {function}\n     */\n    this.onPassword = null;\n\n    /**\n     * Callback to be able to monitor the loading progress of the PDF file\n     * (necessary to implement e.g. a loading bar).\n     * The callback receives an {@link OnProgressParameters} argument.\n     * @type {function}\n     */\n    this.onProgress = null;\n\n    /**\n     * Callback for when an unsupported feature is used in the PDF document.\n     * The callback receives an {@link UNSUPPORTED_FEATURES} argument.\n     * @type {function}\n     */\n    this.onUnsupportedFeature = null;\n  }\n\n  /**\n   * Promise for document loading task completion.\n   * @type {Promise<PDFDocumentProxy>}\n   */\n  get promise() {\n    return this._capability.promise;\n  }\n\n  /**\n   * Abort all network requests and destroy the worker.\n   * @returns {Promise<void>} A promise that is resolved when destruction is\n   *   completed.\n   */\n  async destroy() {\n    this.destroyed = true;\n    await this._transport?.destroy();\n\n    this._transport = null;\n    if (this._worker) {\n      this._worker.destroy();\n      this._worker = null;\n    }\n  }\n}\n\n/**\n * Abstract class to support range requests file loading.\n */\nclass PDFDataRangeTransport {\n  /**\n   * @param {number} length\n   * @param {Uint8Array} initialData\n   * @param {boolean} [progressiveDone]\n   * @param {string} [contentDispositionFilename]\n   */\n  constructor(\n    length,\n    initialData,\n    progressiveDone = false,\n    contentDispositionFilename = null\n  ) {\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this.contentDispositionFilename = contentDispositionFilename;\n\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._progressiveDoneListeners = [];\n    this._readyCapability = createPromiseCapability();\n  }\n\n  addRangeListener(listener) {\n    this._rangeListeners.push(listener);\n  }\n\n  addProgressListener(listener) {\n    this._progressListeners.push(listener);\n  }\n\n  addProgressiveReadListener(listener) {\n    this._progressiveReadListeners.push(listener);\n  }\n\n  addProgressiveDoneListener(listener) {\n    this._progressiveDoneListeners.push(listener);\n  }\n\n  onDataRange(begin, chunk) {\n    for (const listener of this._rangeListeners) {\n      listener(begin, chunk);\n    }\n  }\n\n  onDataProgress(loaded, total) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressListeners) {\n        listener(loaded, total);\n      }\n    });\n  }\n\n  onDataProgressiveRead(chunk) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveReadListeners) {\n        listener(chunk);\n      }\n    });\n  }\n\n  onDataProgressiveDone() {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveDoneListeners) {\n        listener();\n      }\n    });\n  }\n\n  transportReady() {\n    this._readyCapability.resolve();\n  }\n\n  requestDataRange(begin, end) {\n    unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n  }\n\n  abort() {}\n}\n\n/**\n * Proxy to a `PDFDocument` in the worker thread.\n */\nclass PDFDocumentProxy {\n  constructor(pdfInfo, transport) {\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n\n    if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n      Object.defineProperty(this, \"fingerprint\", {\n        get() {\n          deprecated(\n            \"`PDFDocumentProxy.fingerprint`, \" +\n              \"please use `PDFDocumentProxy.fingerprints` instead.\"\n          );\n          return this.fingerprints[0];\n        },\n      });\n\n      Object.defineProperty(this, \"getStats\", {\n        value: async () => {\n          deprecated(\n            \"`PDFDocumentProxy.getStats`, \" +\n              \"please use the `PDFDocumentProxy.stats`-getter instead.\"\n          );\n          return this.stats || { streamTypes: {}, fontTypes: {} };\n        },\n      });\n    }\n  }\n\n  /**\n   * @type {AnnotationStorage} Storage for annotation data in forms.\n   */\n  get annotationStorage() {\n    return this._transport.annotationStorage;\n  }\n\n  /**\n   * @type {number} Total number of pages in the PDF file.\n   */\n  get numPages() {\n    return this._pdfInfo.numPages;\n  }\n\n  /**\n   * @type {Array<string, string|null>} A (not guaranteed to be) unique ID to\n   *   identify the PDF document.\n   *   NOTE: The first element will always be defined for all PDF documents,\n   *   whereas the second element is only defined for *modified* PDF documents.\n   */\n  get fingerprints() {\n    return this._pdfInfo.fingerprints;\n  }\n\n  /**\n   * @typedef {Object} PDFDocumentStats\n   * @property {Object<string, boolean>} streamTypes - Used stream types in the\n   *   document (an item is set to true if specific stream ID was used in the\n   *   document).\n   * @property {Object<string, boolean>} fontTypes - Used font types in the\n   *   document (an item is set to true if specific font ID was used in the\n   *   document).\n   */\n\n  /**\n   * @type {PDFDocumentStats | null} The current statistics about document\n   *   structures, or `null` when no statistics exists.\n   */\n  get stats() {\n    return this._transport.stats;\n  }\n\n  /**\n   * @type {boolean} True if only XFA form.\n   */\n  get isPureXfa() {\n    return !!this._transport._htmlForXfa;\n  }\n\n  /**\n   * NOTE: This is (mostly) intended to support printing of XFA forms.\n   *\n   * @type {Object | null} An object representing a HTML tree structure\n   *   to render the XFA, or `null` when no XFA form exists.\n   */\n  get allXfaHtml() {\n    return this._transport._htmlForXfa;\n  }\n\n  /**\n   * @param {number} pageNumber - The page number to get. The first page is 1.\n   * @returns {Promise<PDFPageProxy>} A promise that is resolved with\n   *   a {@link PDFPageProxy} object.\n   */\n  getPage(pageNumber) {\n    return this._transport.getPage(pageNumber);\n  }\n\n  /**\n   * @param {RefProxy} ref - The page reference.\n   * @returns {Promise<number>} A promise that is resolved with the page index,\n   *   starting from zero, that is associated with the reference.\n   */\n  getPageIndex(ref) {\n    return this._transport.getPageIndex(ref);\n  }\n\n  /**\n   * @returns {Promise<Object<string, Array<any>>>} A promise that is resolved\n   *   with a mapping from named destinations to references.\n   *\n   * This can be slow for large documents. Use `getDestination` instead.\n   */\n  getDestinations() {\n    return this._transport.getDestinations();\n  }\n\n  /**\n   * @param {string} id - The named destination to get.\n   * @returns {Promise<Array<any> | null>} A promise that is resolved with all\n   *   information of the given named destination, or `null` when the named\n   *   destination is not present in the PDF file.\n   */\n  getDestination(id) {\n    return this._transport.getDestination(id);\n  }\n\n  /**\n   * @returns {Promise<Array<string> | null>} A promise that is resolved with\n   *   an {Array} containing the page labels that correspond to the page\n   *   indexes, or `null` when no page labels are present in the PDF file.\n   */\n  getPageLabels() {\n    return this._transport.getPageLabels();\n  }\n\n  /**\n   * @returns {Promise<string>} A promise that is resolved with a {string}\n   *   containing the page layout name.\n   */\n  getPageLayout() {\n    return this._transport.getPageLayout();\n  }\n\n  /**\n   * @returns {Promise<string>} A promise that is resolved with a {string}\n   *   containing the page mode name.\n   */\n  getPageMode() {\n    return this._transport.getPageMode();\n  }\n\n  /**\n   * @returns {Promise<Object | null>} A promise that is resolved with an\n   *   {Object} containing the viewer preferences, or `null` when no viewer\n   *   preferences are present in the PDF file.\n   */\n  getViewerPreferences() {\n    return this._transport.getViewerPreferences();\n  }\n\n  /**\n   * @returns {Promise<any | null>} A promise that is resolved with an {Array}\n   *   containing the destination, or `null` when no open action is present\n   *   in the PDF.\n   */\n  getOpenAction() {\n    return this._transport.getOpenAction();\n  }\n\n  /**\n   * @returns {Promise<any>} A promise that is resolved with a lookup table\n   *   for mapping named attachments to their content.\n   */\n  getAttachments() {\n    return this._transport.getAttachments();\n  }\n\n  /**\n   * @returns {Promise<Array<string> | null>} A promise that is resolved with\n   *   an {Array} of all the JavaScript strings in the name tree, or `null`\n   *   if no JavaScript exists.\n   */\n  getJavaScript() {\n    return this._transport.getJavaScript();\n  }\n\n  /**\n   * @returns {Promise<Object | null>} A promise that is resolved with\n   *   an {Object} with the JavaScript actions:\n   *     - from the name tree (like getJavaScript);\n   *     - from A or AA entries in the catalog dictionary.\n   *   , or `null` if no JavaScript exists.\n   */\n  getJSActions() {\n    return this._transport.getDocJSActions();\n  }\n\n  /**\n   * @typedef {Object} OutlineNode\n   * @property {string} title\n   * @property {boolean} bold\n   * @property {boolean} italic\n   * @property {Uint8ClampedArray} color - The color in RGB format to use for\n   *   display purposes.\n   * @property {string | Array<any> | null} dest\n   * @property {string | null} url\n   * @property {string | undefined} unsafeUrl\n   * @property {boolean | undefined} newWindow\n   * @property {number | undefined} count\n   * @property {Array<OutlineNode>} items\n   */\n\n  /**\n   * @returns {Promise<Array<OutlineNode>>} A promise that is resolved with an\n   *   {Array} that is a tree outline (if it has one) of the PDF file.\n   */\n  getOutline() {\n    return this._transport.getOutline();\n  }\n\n  /**\n   * @returns {Promise<OptionalContentConfig>} A promise that is resolved with\n   *   an {@link OptionalContentConfig} that contains all the optional content\n   *   groups (assuming that the document has any).\n   */\n  getOptionalContentConfig() {\n    return this._transport.getOptionalContentConfig();\n  }\n\n  /**\n   * @returns {Promise<Array<number> | null>} A promise that is resolved with\n   *   an {Array} that contains the permission flags for the PDF document, or\n   *   `null` when no permissions are present in the PDF file.\n   */\n  getPermissions() {\n    return this._transport.getPermissions();\n  }\n\n  /**\n   * @returns {Promise<{ info: Object, metadata: Metadata }>} A promise that is\n   *   resolved with an {Object} that has `info` and `metadata` properties.\n   *   `info` is an {Object} filled with anything available in the information\n   *   dictionary and similarly `metadata` is a {Metadata} object with\n   *   information from the metadata section of the PDF.\n   */\n  getMetadata() {\n    return this._transport.getMetadata();\n  }\n\n  /**\n   * @typedef {Object} MarkInfo\n   * Properties correspond to Table 321 of the PDF 32000-1:2008 spec.\n   * @property {boolean} Marked\n   * @property {boolean} UserProperties\n   * @property {boolean} Suspects\n   */\n\n  /**\n   * @returns {Promise<MarkInfo | null>} A promise that is resolved with\n   *   a {MarkInfo} object that contains the MarkInfo flags for the PDF\n   *   document, or `null` when no MarkInfo values are present in the PDF file.\n   */\n  getMarkInfo() {\n    return this._transport.getMarkInfo();\n  }\n\n  /**\n   * @returns {Promise<TypedArray>} A promise that is resolved with a\n   *   {TypedArray} that has the raw data from the PDF.\n   */\n  getData() {\n    return this._transport.getData();\n  }\n\n  /**\n   * @returns {Promise<{ length: number }>} A promise that is resolved when the\n   *   document's data is loaded. It is resolved with an {Object} that contains\n   *   the `length` property that indicates size of the PDF data in bytes.\n   */\n  getDownloadInfo() {\n    return this._transport.downloadInfoCapability.promise;\n  }\n\n  /**\n   * Cleans up resources allocated by the document on both the main and worker\n   * threads.\n   *\n   * NOTE: Do not, under any circumstances, call this method when rendering is\n   * currently ongoing since that may lead to rendering errors.\n   *\n   * @param {boolean} [keepLoadedFonts] - Let fonts remain attached to the DOM.\n   *   NOTE: This will increase persistent memory usage, hence don't use this\n   *   option unless absolutely necessary. The default value is `false`.\n   * @returns {Promise} A promise that is resolved when clean-up has finished.\n   */\n  cleanup(keepLoadedFonts = false) {\n    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n  }\n\n  /**\n   * Destroys the current document instance and terminates the worker.\n   */\n  destroy() {\n    return this.loadingTask.destroy();\n  }\n\n  /**\n   * @type {DocumentInitParameters} A subset of the current\n   *   {DocumentInitParameters}, which are needed in the viewer.\n   */\n  get loadingParams() {\n    return this._transport.loadingParams;\n  }\n\n  /**\n   * @type {PDFDocumentLoadingTask} The loadingTask for the current document.\n   */\n  get loadingTask() {\n    return this._transport.loadingTask;\n  }\n\n  /**\n   * @returns {Promise<Uint8Array>} A promise that is resolved with a\n   *   {Uint8Array} containing the full data of the saved document.\n   */\n  saveDocument() {\n    if (\n      (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) &&\n      this._transport.annotationStorage.size <= 0\n    ) {\n      deprecated(\n        \"saveDocument called while `annotationStorage` is empty, \" +\n          \"please use the getData-method instead.\"\n      );\n    }\n    return this._transport.saveDocument();\n  }\n\n  /**\n   * @returns {Promise<Object<string, Array<Object>> | null>} A promise that is\n   *   resolved with an {Object} containing /AcroForm field data for the JS\n   *   sandbox, or `null` when no field data is present in the PDF file.\n   */\n  getFieldObjects() {\n    return this._transport.getFieldObjects();\n  }\n\n  /**\n   * @returns {Promise<boolean>} A promise that is resolved with `true`\n   *   if some /AcroForm fields have JavaScript actions.\n   */\n  hasJSActions() {\n    return this._transport.hasJSActions();\n  }\n\n  /**\n   * @returns {Promise<Array<string> | null>} A promise that is resolved with an\n   *   {Array<string>} containing IDs of annotations that have a calculation\n   *   action, or `null` when no such annotations are present in the PDF file.\n   */\n  getCalculationOrderIds() {\n    return this._transport.getCalculationOrderIds();\n  }\n}\n\n/**\n * Page getViewport parameters.\n *\n * @typedef {Object} GetViewportParameters\n * @property {number} scale - The desired scale of the viewport.\n * @property {number} [rotation] - The desired rotation, in degrees, of\n *   the viewport. If omitted it defaults to the page rotation.\n * @property {number} [offsetX] - The horizontal, i.e. x-axis, offset.\n *   The default value is `0`.\n * @property {number} [offsetY] - The vertical, i.e. y-axis, offset.\n *   The default value is `0`.\n * @property {boolean} [dontFlip] - If true, the y-axis will not be\n *   flipped. The default value is `false`.\n */\n\n/**\n * Page getTextContent parameters.\n *\n * @typedef {Object} getTextContentParameters\n * @property {boolean} normalizeWhitespace - Replaces all occurrences of\n *   whitespace with standard spaces (0x20). The default value is `false`.\n * @property {boolean} disableCombineTextItems - Do not attempt to combine\n *   same line {@link TextItem}'s. The default value is `false`.\n * @property {boolean} [includeMarkedContent] - When true include marked\n *   content items in the items array of TextContent. The default is `false`.\n */\n\n/**\n * Page text content.\n *\n * @typedef {Object} TextContent\n * @property {Array<TextItem | TextMarkedContent>} items - Array of\n *   {@link TextItem} and {@link TextMarkedContent} objects. TextMarkedContent\n *   items are included when includeMarkedContent is true.\n * @property {Object<string, TextStyle>} styles - {@link TextStyle} objects,\n *   indexed by font name.\n */\n\n/**\n * Page text content part.\n *\n * @typedef {Object} TextItem\n * @property {string} str - Text content.\n * @property {string} dir - Text direction: 'ttb', 'ltr' or 'rtl'.\n * @property {Array<any>} transform - Transformation matrix.\n * @property {number} width - Width in device space.\n * @property {number} height - Height in device space.\n * @property {string} fontName - Font name used by PDF.js for converted font.\n * @property {boolean} hasEOL - Indicating if the text content is followed by a\n *   line-break.\n */\n\n/**\n * Page text marked content part.\n *\n * @typedef {Object} TextMarkedContent\n * @property {string} type - Either 'beginMarkedContent',\n *   'beginMarkedContentProps', or 'endMarkedContent'.\n * @property {string} id - The marked content identifier. Only used for type\n *   'beginMarkedContentProps'.\n */\n\n/**\n * Text style.\n *\n * @typedef {Object} TextStyle\n * @property {number} ascent - Font ascent.\n * @property {number} descent - Font descent.\n * @property {boolean} vertical - Whether or not the text is in vertical mode.\n * @property {string} fontFamily - The possible font family.\n */\n\n/**\n * Page annotation parameters.\n *\n * @typedef {Object} GetAnnotationsParameters\n * @property {string} [intent] - Determines the annotations that are fetched,\n *   can be 'display' (viewable annotations), 'print' (printable annotations),\n *   or 'any' (all annotations). The default value is 'display'.\n */\n\n/**\n * Page render parameters.\n *\n * @typedef {Object} RenderParameters\n * @property {Object} canvasContext - A 2D context of a DOM Canvas object.\n * @property {PageViewport} viewport - Rendering viewport obtained by calling\n *   the `PDFPageProxy.getViewport` method.\n * @property {string} [intent] - Rendering intent, can be 'display', 'print',\n *   or 'any'. The default value is 'display'.\n * @property {number} [annotationMode] Controls which annotations are rendered\n *   onto the canvas, for annotations with appearance-data; the values from\n *   {@link AnnotationMode} should be used. The following values are supported:\n *    - `AnnotationMode.DISABLE`, which disables all annotations.\n *    - `AnnotationMode.ENABLE`, which includes all possible annotations (thus\n *      it also depends on the `intent`-option, see above).\n *    - `AnnotationMode.ENABLE_FORMS`, which excludes annotations that contain\n *      interactive form elements (those will be rendered in the display layer).\n *    - `AnnotationMode.ENABLE_STORAGE`, which includes all possible annotations\n *      (as above) but where interactive form elements are updated with data\n *      from the {@link AnnotationStorage}-instance; useful e.g. for printing.\n *   The default value is `AnnotationMode.ENABLE`.\n * @property {Array<any>} [transform] - Additional transform, applied just\n *   before viewport transform.\n * @property {Object} [imageLayer] - An object that has `beginLayout`,\n *   `endLayout` and `appendImage` functions.\n * @property {Object} [canvasFactory] - The factory instance that will be used\n *   when creating canvases. The default value is {new DOMCanvasFactory()}.\n * @property {Object | string} [background] - Background to use for the canvas.\n *   Any valid `canvas.fillStyle` can be used: a `DOMString` parsed as CSS\n *   <color> value, a `CanvasGradient` object (a linear or radial gradient) or\n *   a `CanvasPattern` object (a repetitive image). The default value is\n *   'rgb(255,255,255)'.\n * @property {Promise<OptionalContentConfig>} [optionalContentConfigPromise] -\n *   A promise that should resolve with an {@link OptionalContentConfig}\n *   created from `PDFDocumentProxy.getOptionalContentConfig`. If `null`,\n *   the configuration will be fetched automatically with the default visibility\n *   states set.\n * @property {Map<string, HTMLCanvasElement>} [annotationCanvasMap] - Map some\n *   annotation ids with canvases used to render them.\n */\n\n/**\n * Page getOperatorList parameters.\n *\n * @typedef {Object} GetOperatorListParameters\n * @property {string} [intent] - Rendering intent, can be 'display', 'print',\n *   or 'any'. The default value is 'display'.\n * @property {number} [annotationMode] Controls which annotations are included\n *   in the operatorList, for annotations with appearance-data; the values from\n *   {@link AnnotationMode} should be used. The following values are supported:\n *    - `AnnotationMode.DISABLE`, which disables all annotations.\n *    - `AnnotationMode.ENABLE`, which includes all possible annotations (thus\n *      it also depends on the `intent`-option, see above).\n *    - `AnnotationMode.ENABLE_FORMS`, which excludes annotations that contain\n *      interactive form elements (those will be rendered in the display layer).\n *    - `AnnotationMode.ENABLE_STORAGE`, which includes all possible annotations\n *      (as above) but where interactive form elements are updated with data\n *      from the {@link AnnotationStorage}-instance; useful e.g. for printing.\n *   The default value is `AnnotationMode.ENABLE`.\n */\n\n/**\n * Structure tree node. The root node will have a role \"Root\".\n *\n * @typedef {Object} StructTreeNode\n * @property {Array<StructTreeNode | StructTreeContent>} children - Array of\n *   {@link StructTreeNode} and {@link StructTreeContent} objects.\n * @property {string} role - element's role, already mapped if a role map exists\n * in the PDF.\n */\n\n/**\n * Structure tree content.\n *\n * @typedef {Object} StructTreeContent\n * @property {string} type - either \"content\" for page and stream structure\n *   elements or \"object\" for object references.\n * @property {string} id - unique id that will map to the text layer.\n */\n\n/**\n * PDF page operator list.\n *\n * @typedef {Object} PDFOperatorList\n * @property {Array<number>} fnArray - Array containing the operator functions.\n * @property {Array<any>} argsArray - Array containing the arguments of the\n *   functions.\n */\n\n/**\n * Proxy to a `PDFPage` in the worker thread.\n */\nclass PDFPageProxy {\n  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._ownerDocument = ownerDocument;\n    this._transport = transport;\n    this._stats = pdfBug ? new StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n\n    this.cleanupAfterRender = false;\n    this.pendingCleanup = false;\n    this._intentStates = new Map();\n    this._annotationPromises = new Map();\n    this.destroyed = false;\n  }\n\n  /**\n   * @type {number} Page number of the page. First page is 1.\n   */\n  get pageNumber() {\n    return this._pageIndex + 1;\n  }\n\n  /**\n   * @type {number} The number of degrees the page is rotated clockwise.\n   */\n  get rotate() {\n    return this._pageInfo.rotate;\n  }\n\n  /**\n   * @type {RefProxy | null} The reference that points to this page.\n   */\n  get ref() {\n    return this._pageInfo.ref;\n  }\n\n  /**\n   * @type {number} The default size of units in 1/72nds of an inch.\n   */\n  get userUnit() {\n    return this._pageInfo.userUnit;\n  }\n\n  /**\n   * @type {Array<number>} An array of the visible portion of the PDF page in\n   *   user space units [x1, y1, x2, y2].\n   */\n  get view() {\n    return this._pageInfo.view;\n  }\n\n  /**\n   * @param {GetViewportParameters} params - Viewport parameters.\n   * @returns {PageViewport} Contains 'width' and 'height' properties\n   *   along with transforms required for rendering.\n   */\n  getViewport({\n    scale,\n    rotation = this.rotate,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false,\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.view,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip,\n    });\n  }\n\n  /**\n   * @param {GetAnnotationsParameters} params - Annotation parameters.\n   * @returns {Promise<Array<any>>} A promise that is resolved with an\n   *   {Array} of the annotation objects.\n   */\n  getAnnotations({ intent = \"display\" } = {}) {\n    const intentArgs = this._transport.getRenderingIntent(intent);\n\n    let promise = this._annotationPromises.get(intentArgs.cacheKey);\n    if (!promise) {\n      promise = this._transport.getAnnotations(\n        this._pageIndex,\n        intentArgs.renderingIntent\n      );\n      this._annotationPromises.set(intentArgs.cacheKey, promise);\n\n      if (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) {\n        promise = promise.then(annotations => {\n          for (const annotation of annotations) {\n            if (annotation.titleObj !== undefined) {\n              Object.defineProperty(annotation, \"title\", {\n                get() {\n                  deprecated(\n                    \"`title`-property on annotation, please use `titleObj` instead.\"\n                  );\n                  return annotation.titleObj.str;\n                },\n              });\n            }\n            if (annotation.contentsObj !== undefined) {\n              Object.defineProperty(annotation, \"contents\", {\n                get() {\n                  deprecated(\n                    \"`contents`-property on annotation, please use `contentsObj` instead.\"\n                  );\n                  return annotation.contentsObj.str;\n                },\n              });\n            }\n          }\n          return annotations;\n        });\n      }\n    }\n    return promise;\n  }\n\n  /**\n   * @returns {Promise<Object>} A promise that is resolved with an\n   *   {Object} with JS actions.\n   */\n  getJSActions() {\n    return (this._jsActionsPromise ||= this._transport.getPageJSActions(\n      this._pageIndex\n    ));\n  }\n\n  /**\n   * @returns {Promise<Object | null>} A promise that is resolved with\n   *   an {Object} with a fake DOM object (a tree structure where elements\n   *   are {Object} with a name, attributes (class, style, ...), value and\n   *   children, very similar to a HTML DOM tree), or `null` if no XFA exists.\n   */\n  async getXfa() {\n    return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n  }\n\n  /**\n   * Begins the process of rendering a page to the desired context.\n   *\n   * @param {RenderParameters} params - Page render parameters.\n   * @returns {RenderTask} An object that contains a promise that is\n   *   resolved when the page finishes rendering.\n   */\n  render({\n    canvasContext,\n    viewport,\n    intent = \"display\",\n    annotationMode = AnnotationMode.ENABLE,\n    transform = null,\n    imageLayer = null,\n    canvasFactory = null,\n    background = null,\n    optionalContentConfigPromise = null,\n    annotationCanvasMap = null,\n  }) {\n    if (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"GENERIC\")) {\n      if (arguments[0]?.renderInteractiveForms !== undefined) {\n        deprecated(\n          \"render no longer accepts the `renderInteractiveForms`-option, \" +\n            \"please use the `annotationMode`-option instead.\"\n        );\n        if (\n          arguments[0].renderInteractiveForms === true &&\n          annotationMode === AnnotationMode.ENABLE\n        ) {\n          annotationMode = AnnotationMode.ENABLE_FORMS;\n        }\n      }\n      if (arguments[0]?.includeAnnotationStorage !== undefined) {\n        deprecated(\n          \"render no longer accepts the `includeAnnotationStorage`-option, \" +\n            \"please use the `annotationMode`-option instead.\"\n        );\n        if (\n          arguments[0].includeAnnotationStorage === true &&\n          annotationMode === AnnotationMode.ENABLE\n        ) {\n          annotationMode = AnnotationMode.ENABLE_STORAGE;\n        }\n      }\n    }\n\n    if (this._stats) {\n      this._stats.time(\"Overall\");\n    }\n\n    const intentArgs = this._transport.getRenderingIntent(\n      intent,\n      annotationMode\n    );\n    // If there was a pending destroy, cancel it so no cleanup happens during\n    // this call to render.\n    this.pendingCleanup = false;\n\n    if (!optionalContentConfigPromise) {\n      optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n    }\n\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n\n    // Ensure that a pending `streamReader` cancel timeout is always aborted.\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n\n    const canvasFactoryInstance =\n      canvasFactory ||\n      new DefaultCanvasFactory({ ownerDocument: this._ownerDocument });\n    const intentPrint = !!(\n      intentArgs.renderingIntent & RenderingIntentFlag.PRINT\n    );\n\n    // If there's no displayReadyCapability yet, then the operatorList\n    // was never requested before. Make the request and create the promise.\n    if (!intentState.displayReadyCapability) {\n      intentState.displayReadyCapability = createPromiseCapability();\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n      };\n\n      if (this._stats) {\n        this._stats.time(\"Page Request\");\n      }\n      this._pumpOperatorList(intentArgs);\n    }\n\n    const complete = error => {\n      intentState.renderTasks.delete(internalRenderTask);\n\n      // Attempt to reduce memory usage during *printing*, by always running\n      // cleanup once rendering has finished (regardless of cleanupAfterRender).\n      if (this.cleanupAfterRender || intentPrint) {\n        this.pendingCleanup = true;\n      }\n      this._tryCleanup();\n\n      if (error) {\n        internalRenderTask.capability.reject(error);\n\n        this._abortOperatorList({\n          intentState,\n          reason: error instanceof Error ? error : new Error(error),\n        });\n      } else {\n        internalRenderTask.capability.resolve();\n      }\n      if (this._stats) {\n        this._stats.timeEnd(\"Rendering\");\n        this._stats.timeEnd(\"Overall\");\n      }\n    };\n\n    const internalRenderTask = new InternalRenderTask({\n      callback: complete,\n      // Only include the required properties, and *not* the entire object.\n      params: {\n        canvasContext,\n        viewport,\n        transform,\n        imageLayer,\n        background,\n      },\n      objs: this.objs,\n      commonObjs: this.commonObjs,\n      annotationCanvasMap,\n      operatorList: intentState.operatorList,\n      pageIndex: this._pageIndex,\n      canvasFactory: canvasFactoryInstance,\n      useRequestAnimationFrame: !intentPrint,\n      pdfBug: this._pdfBug,\n    });\n\n    (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n    const renderTask = internalRenderTask.task;\n\n    Promise.all([\n      intentState.displayReadyCapability.promise,\n      optionalContentConfigPromise,\n    ])\n      .then(([transparency, optionalContentConfig]) => {\n        if (this.pendingCleanup) {\n          complete();\n          return;\n        }\n        if (this._stats) {\n          this._stats.time(\"Rendering\");\n        }\n        internalRenderTask.initializeGraphics({\n          transparency,\n          optionalContentConfig,\n        });\n        internalRenderTask.operatorListChanged();\n      })\n      .catch(complete);\n\n    return renderTask;\n  }\n\n  /**\n   * @param {GetOperatorListParameters} params - Page getOperatorList\n   *   parameters.\n   * @returns {Promise<PDFOperatorList>} A promise resolved with an\n   *   {@link PDFOperatorList} object that represents the page's operator list.\n   */\n  getOperatorList({\n    intent = \"display\",\n    annotationMode = AnnotationMode.ENABLE,\n  } = {}) {\n    function operatorListChanged() {\n      if (intentState.operatorList.lastChunk) {\n        intentState.opListReadCapability.resolve(intentState.operatorList);\n\n        intentState.renderTasks.delete(opListTask);\n      }\n    }\n\n    const intentArgs = this._transport.getRenderingIntent(\n      intent,\n      annotationMode,\n      /* isOpList = */ true\n    );\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n    let opListTask;\n\n    if (!intentState.opListReadCapability) {\n      opListTask = Object.create(null);\n      opListTask.operatorListChanged = operatorListChanged;\n      intentState.opListReadCapability = createPromiseCapability();\n      (intentState.renderTasks ||= new Set()).add(opListTask);\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n      };\n\n      if (this._stats) {\n        this._stats.time(\"Page Request\");\n      }\n      this._pumpOperatorList(intentArgs);\n    }\n    return intentState.opListReadCapability.promise;\n  }\n\n  /**\n   * @param {getTextContentParameters} params - getTextContent parameters.\n   * @returns {ReadableStream} Stream for reading text content chunks.\n   */\n  streamTextContent({\n    normalizeWhitespace = false,\n    disableCombineTextItems = false,\n    includeMarkedContent = false,\n  } = {}) {\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\n\n    return this._transport.messageHandler.sendWithStream(\n      \"GetTextContent\",\n      {\n        pageIndex: this._pageIndex,\n        normalizeWhitespace: normalizeWhitespace === true,\n        combineTextItems: disableCombineTextItems !== true,\n        includeMarkedContent: includeMarkedContent === true,\n      },\n      {\n        highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n        size(textContent) {\n          return textContent.items.length;\n        },\n      }\n    );\n  }\n\n  /**\n   * @param {getTextContentParameters} params - getTextContent parameters.\n   * @returns {Promise<TextContent>} A promise that is resolved with a\n   *   {@link TextContent} object that represents the page's text content.\n   */\n  getTextContent(params = {}) {\n    if (this._transport._htmlForXfa) {\n      // TODO: We need to revisit this once the XFA foreground patch lands and\n      // only do this for non-foreground XFA.\n      return this.getXfa().then(xfa => {\n        return XfaText.textContent(xfa);\n      });\n    }\n    const readableStream = this.streamTextContent(params);\n\n    return new Promise(function (resolve, reject) {\n      function pump() {\n        reader.read().then(function ({ value, done }) {\n          if (done) {\n            resolve(textContent);\n            return;\n          }\n          Object.assign(textContent.styles, value.styles);\n          textContent.items.push(...value.items);\n          pump();\n        }, reject);\n      }\n\n      const reader = readableStream.getReader();\n      const textContent = {\n        items: [],\n        styles: Object.create(null),\n      };\n      pump();\n    });\n  }\n\n  /**\n   * @returns {Promise<StructTreeNode>} A promise that is resolved with a\n   *   {@link StructTreeNode} object that represents the page's structure tree,\n   *   or `null` when no structure tree is present for the current page.\n   */\n  getStructTree() {\n    return (this._structTreePromise ||= this._transport.getStructTree(\n      this._pageIndex\n    ));\n  }\n\n  /**\n   * Destroys the page object.\n   * @private\n   */\n  _destroy() {\n    this.destroyed = true;\n\n    const waitOn = [];\n    for (const intentState of this._intentStates.values()) {\n      this._abortOperatorList({\n        intentState,\n        reason: new Error(\"Page was destroyed.\"),\n        force: true,\n      });\n\n      if (intentState.opListReadCapability) {\n        // Avoid errors below, since the renderTasks are just stubs.\n        continue;\n      }\n      for (const internalRenderTask of intentState.renderTasks) {\n        waitOn.push(internalRenderTask.completed);\n        internalRenderTask.cancel();\n      }\n    }\n    this.objs.clear();\n    this._annotationPromises.clear();\n    this._jsActionsPromise = null;\n    this._structTreePromise = null;\n    this.pendingCleanup = false;\n    return Promise.all(waitOn);\n  }\n\n  /**\n   * Cleans up resources allocated by the page.\n   *\n   * @param {boolean} [resetStats] - Reset page stats, if enabled.\n   *   The default value is `false`.\n   * @returns {boolean} Indicates if clean-up was successfully run.\n   */\n  cleanup(resetStats = false) {\n    this.pendingCleanup = true;\n    return this._tryCleanup(resetStats);\n  }\n\n  /**\n   * Attempts to clean up if rendering is in a state where that's possible.\n   * @private\n   */\n  _tryCleanup(resetStats = false) {\n    if (!this.pendingCleanup) {\n      return false;\n    }\n    for (const { renderTasks, operatorList } of this._intentStates.values()) {\n      if (renderTasks.size > 0 || !operatorList.lastChunk) {\n        return false;\n      }\n    }\n\n    this._intentStates.clear();\n    this.objs.clear();\n    this._annotationPromises.clear();\n    this._jsActionsPromise = null;\n    this._structTreePromise = null;\n    if (resetStats && this._stats) {\n      this._stats = new StatTimer();\n    }\n    this.pendingCleanup = false;\n    return true;\n  }\n\n  /**\n   * @private\n   */\n  _startRenderPage(transparency, cacheKey) {\n    const intentState = this._intentStates.get(cacheKey);\n    if (!intentState) {\n      return; // Rendering was cancelled.\n    }\n    if (this._stats) {\n      this._stats.timeEnd(\"Page Request\");\n    }\n    // TODO Refactor RenderPageRequest to separate rendering\n    // and operator list logic\n    if (intentState.displayReadyCapability) {\n      intentState.displayReadyCapability.resolve(transparency);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _renderPageChunk(operatorListChunk, intentState) {\n    // Add the new chunk to the current operator list.\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n    }\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n\n    // Notify all the rendering tasks there are more operators to be consumed.\n    for (const internalRenderTask of intentState.renderTasks) {\n      internalRenderTask.operatorListChanged();\n    }\n\n    if (operatorListChunk.lastChunk) {\n      this._tryCleanup();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _pumpOperatorList({ renderingIntent, cacheKey }) {\n    if (\n      typeof PDFJSDev === \"undefined\" ||\n      PDFJSDev.test(\"!PRODUCTION || TESTING\")\n    ) {\n      assert(\n        Number.isInteger(renderingIntent) && renderingIntent > 0,\n        '_pumpOperatorList: Expected valid \"renderingIntent\" argument.'\n      );\n    }\n\n    const readableStream = this._transport.messageHandler.sendWithStream(\n      \"GetOperatorList\",\n      {\n        pageIndex: this._pageIndex,\n        intent: renderingIntent,\n        cacheKey,\n        annotationStorage:\n          renderingIntent & RenderingIntentFlag.ANNOTATIONS_STORAGE\n            ? this._transport.annotationStorage.serializable\n            : null,\n      }\n    );\n    const reader = readableStream.getReader();\n\n    const intentState = this._intentStates.get(cacheKey);\n    intentState.streamReader = reader;\n\n    const pump = () => {\n      reader.read().then(\n        ({ value, done }) => {\n          if (done) {\n            intentState.streamReader = null;\n            return;\n          }\n          if (this._transport.destroyed) {\n            return; // Ignore any pending requests if the worker was terminated.\n          }\n          this._renderPageChunk(value, intentState);\n          pump();\n        },\n        reason => {\n          intentState.streamReader = null;\n\n          if (this._transport.destroyed) {\n            return; // Ignore any pending requests if the worker was terminated.\n          }\n          if (intentState.operatorList) {\n            // Mark operator list as complete.\n            intentState.operatorList.lastChunk = true;\n\n            for (const internalRenderTask of intentState.renderTasks) {\n              internalRenderTask.operatorListChanged();\n            }\n            this._tryCleanup();\n          }\n\n          if (intentState.displayReadyCapability) {\n            intentState.displayReadyCapability.reject(reason);\n          } else if (intentState.opListReadCapability) {\n            intentState.opListReadCapability.reject(reason);\n          } else {\n            throw reason;\n          }\n        }\n      );\n    };\n    pump();\n  }\n\n  /**\n   * @private\n   */\n  _abortOperatorList({ intentState, reason, force = false }) {\n    if (\n      typeof PDFJSDev === \"undefined\" ||\n      PDFJSDev.test(\"!PRODUCTION || TESTING\")\n    ) {\n      assert(\n        reason instanceof Error,\n        '_abortOperatorList: Expected valid \"reason\" argument.'\n      );\n    }\n\n    if (!intentState.streamReader) {\n      return;\n    }\n    if (!force) {\n      // Ensure that an Error occurring in *only* one `InternalRenderTask`, e.g.\n      // multiple render() calls on the same canvas, won't break all rendering.\n      if (intentState.renderTasks.size > 0) {\n        return;\n      }\n      // Don't immediately abort parsing on the worker-thread when rendering is\n      // cancelled, since that will unnecessarily delay re-rendering when (for\n      // partially parsed pages) e.g. zooming/rotation occurs in the viewer.\n      if (reason instanceof RenderingCancelledException) {\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\n          this._abortOperatorList({ intentState, reason, force: true });\n          intentState.streamReaderCancelTimeout = null;\n        }, RENDERING_CANCELLED_TIMEOUT);\n        return;\n      }\n    }\n    intentState.streamReader\n      .cancel(new AbortException(reason.message))\n      .catch(() => {\n        // Avoid \"Uncaught promise\" messages in the console.\n      });\n    intentState.streamReader = null;\n\n    if (this._transport.destroyed) {\n      return; // Ignore any pending requests if the worker was terminated.\n    }\n    // Remove the current `intentState`, since a cancelled `getOperatorList`\n    // call on the worker-thread cannot be re-started...\n    for (const [curCacheKey, curIntentState] of this._intentStates) {\n      if (curIntentState === intentState) {\n        this._intentStates.delete(curCacheKey);\n        break;\n      }\n    }\n    // ... and force clean-up to ensure that any old state is always removed.\n    this.cleanup();\n  }\n\n  /**\n   * @type {Object} Returns page stats, if enabled; returns `null` otherwise.\n   */\n  get stats() {\n    return this._stats;\n  }\n}\n\nclass LoopbackPort {\n  constructor() {\n    this._listeners = [];\n    this._deferred = Promise.resolve();\n  }\n\n  postMessage(obj, transfers) {\n    function cloneValue(object) {\n      if (\n        (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) ||\n        globalThis.structuredClone\n      ) {\n        return globalThis.structuredClone(object, transfers);\n      }\n\n      // Trying to perform a structured clone close to the spec, including\n      // transfers.\n      function fallbackCloneValue(value) {\n        if (\n          typeof value === \"function\" ||\n          typeof value === \"symbol\" ||\n          value instanceof URL\n        ) {\n          throw new Error(\n            `LoopbackPort.postMessage - cannot clone: ${value?.toString()}`\n          );\n        }\n\n        if (typeof value !== \"object\" || value === null) {\n          return value;\n        }\n        if (cloned.has(value)) {\n          // already cloned the object\n          return cloned.get(value);\n        }\n        let buffer, result;\n        if ((buffer = value.buffer) && isArrayBuffer(buffer)) {\n          // We found object with ArrayBuffer (typed array).\n          if (transfers?.includes(buffer)) {\n            result = new value.constructor(\n              buffer,\n              value.byteOffset,\n              value.byteLength\n            );\n          } else {\n            result = new value.constructor(value);\n          }\n          cloned.set(value, result);\n          return result;\n        }\n        if (value instanceof Map) {\n          result = new Map();\n          cloned.set(value, result); // Adding to cache now for cyclic references.\n          for (const [key, val] of value) {\n            result.set(key, fallbackCloneValue(val));\n          }\n          return result;\n        }\n        if (value instanceof Set) {\n          result = new Set();\n          cloned.set(value, result); // Adding to cache now for cyclic references.\n          for (const val of value) {\n            result.add(fallbackCloneValue(val));\n          }\n          return result;\n        }\n        result = Array.isArray(value) ? [] : Object.create(null);\n        cloned.set(value, result); // Adding to cache now for cyclic references.\n        // Cloning all value and object properties, however ignoring properties\n        // defined via getter.\n        for (const i in value) {\n          let desc,\n            p = value;\n          while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {\n            p = Object.getPrototypeOf(p);\n          }\n          if (typeof desc.value === \"undefined\") {\n            continue;\n          }\n          if (typeof desc.value === \"function\" && !value.hasOwnProperty?.(i)) {\n            continue;\n          }\n          result[i] = fallbackCloneValue(desc.value);\n        }\n        return result;\n      }\n\n      const cloned = new WeakMap();\n      return fallbackCloneValue(object);\n    }\n\n    const event = { data: cloneValue(obj) };\n\n    this._deferred.then(() => {\n      for (const listener of this._listeners) {\n        listener.call(this, event);\n      }\n    });\n  }\n\n  addEventListener(name, listener) {\n    this._listeners.push(listener);\n  }\n\n  removeEventListener(name, listener) {\n    const i = this._listeners.indexOf(listener);\n    this._listeners.splice(i, 1);\n  }\n\n  terminate() {\n    this._listeners.length = 0;\n  }\n}\n\n/**\n * @typedef {Object} PDFWorkerParameters\n * @property {string} [name] - The name of the worker.\n * @property {Object} [port] - The `workerPort` object.\n * @property {number} [verbosity] - Controls the logging level;\n *   the constants from {@link VerbosityLevel} should be used.\n */\n\nconst PDFWorkerUtil = {\n  isWorkerDisabled: false,\n  fallbackWorkerSrc: null,\n  fakeWorkerId: 0,\n};\nif (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"GENERIC\")) {\n  // eslint-disable-next-line no-undef\n  if (isNodeJS && typeof __non_webpack_require__ === \"function\") {\n    // Workers aren't supported in Node.js, force-disabling them there.\n    PDFWorkerUtil.isWorkerDisabled = true;\n\n    PDFWorkerUtil.fallbackWorkerSrc = PDFJSDev.test(\"LIB\")\n      ? \"../pdf.worker.js\"\n      : \"./pdf.worker.js\";\n  } else if (typeof document === \"object\") {\n    const pdfjsFilePath = document?.currentScript?.src;\n    if (pdfjsFilePath) {\n      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(\n        /(\\.(?:min\\.)?js)(\\?.*)?$/i,\n        \".worker$1$2\"\n      );\n    }\n  }\n\n  PDFWorkerUtil.createCDNWrapper = function (url) {\n    // We will rely on blob URL's property to specify origin.\n    // We want this function to fail in case if createObjectURL or Blob do not\n    // exist or fail for some reason -- our Worker creation will fail anyway.\n    const wrapper = `importScripts(\"${url}\");`;\n    return URL.createObjectURL(new Blob([wrapper]));\n  };\n}\n\n/**\n * PDF.js web worker abstraction that controls the instantiation of PDF\n * documents. Message handlers are used to pass information from the main\n * thread to the worker thread and vice versa. If the creation of a web\n * worker is not possible, a \"fake\" worker will be used instead.\n *\n * @param {PDFWorkerParameters} params - The worker initialization parameters.\n */\nclass PDFWorker {\n  static get _workerPorts() {\n    return shadow(this, \"_workerPorts\", new WeakMap());\n  }\n\n  constructor({\n    name = null,\n    port = null,\n    verbosity = getVerbosityLevel(),\n  } = {}) {\n    if (port && PDFWorker._workerPorts.has(port)) {\n      throw new Error(\"Cannot use more than one PDFWorker per port.\");\n    }\n\n    this.name = name;\n    this.destroyed = false;\n    this.verbosity = verbosity;\n\n    this._readyCapability = createPromiseCapability();\n    this._port = null;\n    this._webWorker = null;\n    this._messageHandler = null;\n\n    if (port) {\n      PDFWorker._workerPorts.set(port, this);\n      this._initializeFromPort(port);\n      return;\n    }\n    this._initialize();\n  }\n\n  /**\n   * Promise for worker initialization completion.\n   * @type {Promise<void>}\n   */\n  get promise() {\n    return this._readyCapability.promise;\n  }\n\n  /**\n   * The current `workerPort`, when it exists.\n   * @type {Worker}\n   */\n  get port() {\n    return this._port;\n  }\n\n  /**\n   * The current MessageHandler-instance.\n   * @type {MessageHandler}\n   */\n  get messageHandler() {\n    return this._messageHandler;\n  }\n\n  _initializeFromPort(port) {\n    this._port = port;\n    this._messageHandler = new MessageHandler(\"main\", \"worker\", port);\n    this._messageHandler.on(\"ready\", function () {\n      // Ignoring \"ready\" event -- MessageHandler should already be initialized\n      // and ready to accept messages.\n    });\n    this._readyCapability.resolve();\n  }\n\n  _initialize() {\n    // If worker support isn't disabled explicit and the browser has worker\n    // support, create a new web worker and test if it/the browser fulfills\n    // all requirements to run parts of pdf.js in a web worker.\n    // Right now, the requirement is, that an Uint8Array is still an\n    // Uint8Array as it arrives on the worker. (Chrome added this with v.15.)\n    if (\n      typeof Worker !== \"undefined\" &&\n      !PDFWorkerUtil.isWorkerDisabled &&\n      !PDFWorker._mainThreadWorkerMessageHandler\n    ) {\n      let workerSrc = PDFWorker.workerSrc;\n\n      try {\n        // Wraps workerSrc path into blob URL, if the former does not belong\n        // to the same origin.\n        if (\n          typeof PDFJSDev !== \"undefined\" &&\n          PDFJSDev.test(\"GENERIC\") &&\n          !isSameOrigin(window.location.href, workerSrc)\n        ) {\n          workerSrc = PDFWorkerUtil.createCDNWrapper(\n            new URL(workerSrc, window.location).href\n          );\n        }\n\n        // Some versions of FF can't create a worker on localhost, see:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=683280\n        const worker = new Worker(workerSrc);\n        const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n        const terminateEarly = () => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          messageHandler.destroy();\n          worker.terminate();\n          if (this.destroyed) {\n            this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n          } else {\n            // Fall back to fake worker if the termination is caused by an\n            // error (e.g. NetworkError / SecurityError).\n            this._setupFakeWorker();\n          }\n        };\n\n        const onWorkerError = () => {\n          if (!this._webWorker) {\n            // Worker failed to initialize due to an error. Clean up and fall\n            // back to the fake worker.\n            terminateEarly();\n          }\n        };\n        worker.addEventListener(\"error\", onWorkerError);\n\n        messageHandler.on(\"test\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          if (this.destroyed) {\n            terminateEarly();\n            return; // worker was destroyed\n          }\n          if (data) {\n            this._messageHandler = messageHandler;\n            this._port = worker;\n            this._webWorker = worker;\n\n            this._readyCapability.resolve();\n            // Send global setting, e.g. verbosity level.\n            messageHandler.send(\"configure\", {\n              verbosity: this.verbosity,\n            });\n          } else {\n            this._setupFakeWorker();\n            messageHandler.destroy();\n            worker.terminate();\n          }\n        });\n\n        messageHandler.on(\"ready\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          if (this.destroyed) {\n            terminateEarly();\n            return; // worker was destroyed\n          }\n          try {\n            sendTest();\n          } catch (e) {\n            // We need fallback to a faked worker.\n            this._setupFakeWorker();\n          }\n        });\n\n        const sendTest = () => {\n          const testObj = new Uint8Array([255]);\n          // Some versions of Opera throw a DATA_CLONE_ERR on serializing the\n          // typed array. Also, checking if we can use transfers.\n          try {\n            messageHandler.send(\"test\", testObj, [testObj.buffer]);\n          } catch (ex) {\n            warn(\"Cannot use postMessage transfers.\");\n            testObj[0] = 0;\n            messageHandler.send(\"test\", testObj);\n          }\n        };\n\n        // It might take time for the worker to initialize. We will try to send\n        // the \"test\" message immediately, and once the \"ready\" message arrives.\n        // The worker shall process only the first received \"test\" message.\n        sendTest();\n        return;\n      } catch (e) {\n        info(\"The worker has been disabled.\");\n      }\n    }\n    // Either workers are disabled, not supported or have thrown an exception.\n    // Thus, we fallback to a faked worker.\n    this._setupFakeWorker();\n  }\n\n  _setupFakeWorker() {\n    if (!PDFWorkerUtil.isWorkerDisabled) {\n      warn(\"Setting up fake worker.\");\n      PDFWorkerUtil.isWorkerDisabled = true;\n    }\n\n    PDFWorker._setupFakeWorkerGlobal\n      .then(WorkerMessageHandler => {\n        if (this.destroyed) {\n          this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n          return;\n        }\n        const port = new LoopbackPort();\n        this._port = port;\n\n        // All fake workers use the same port, making id unique.\n        const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n\n        // If the main thread is our worker, setup the handling for the\n        // messages -- the main thread sends to it self.\n        const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n        WorkerMessageHandler.setup(workerHandler, port);\n\n        const messageHandler = new MessageHandler(id, id + \"_worker\", port);\n        this._messageHandler = messageHandler;\n        this._readyCapability.resolve();\n        // Send global setting, e.g. verbosity level.\n        messageHandler.send(\"configure\", {\n          verbosity: this.verbosity,\n        });\n      })\n      .catch(reason => {\n        this._readyCapability.reject(\n          new Error(`Setting up fake worker failed: \"${reason.message}\".`)\n        );\n      });\n  }\n\n  /**\n   * Destroys the worker instance.\n   */\n  destroy() {\n    this.destroyed = true;\n    if (this._webWorker) {\n      // We need to terminate only web worker created resource.\n      this._webWorker.terminate();\n      this._webWorker = null;\n    }\n    PDFWorker._workerPorts.delete(this._port);\n    this._port = null;\n    if (this._messageHandler) {\n      this._messageHandler.destroy();\n      this._messageHandler = null;\n    }\n  }\n\n  /**\n   * @param {PDFWorkerParameters} params - The worker initialization parameters.\n   */\n  static fromPort(params) {\n    if (!params?.port) {\n      throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n    }\n    if (this._workerPorts.has(params.port)) {\n      return this._workerPorts.get(params.port);\n    }\n    return new PDFWorker(params);\n  }\n\n  /**\n   * The current `workerSrc`, when it exists.\n   * @type {string}\n   */\n  static get workerSrc() {\n    if (GlobalWorkerOptions.workerSrc) {\n      return GlobalWorkerOptions.workerSrc;\n    }\n    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n      if (!isNodeJS) {\n        deprecated('No \"GlobalWorkerOptions.workerSrc\" specified.');\n      }\n      return PDFWorkerUtil.fallbackWorkerSrc;\n    }\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n\n  static get _mainThreadWorkerMessageHandler() {\n    try {\n      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n    } catch (ex) {\n      return null;\n    }\n  }\n\n  // Loads worker code into the main-thread.\n  static get _setupFakeWorkerGlobal() {\n    const loader = async () => {\n      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;\n\n      if (mainWorkerMessageHandler) {\n        // The worker was already loaded using e.g. a `<script>` tag.\n        return mainWorkerMessageHandler;\n      }\n      if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"PRODUCTION\")) {\n        const worker = await import(\"pdfjs/core/worker.js\");\n        return worker.WorkerMessageHandler;\n      }\n      if (\n        PDFJSDev.test(\"GENERIC\") &&\n        isNodeJS &&\n        // eslint-disable-next-line no-undef\n        typeof __non_webpack_require__ === \"function\"\n      ) {\n        // Since bundlers, such as Webpack, cannot be told to leave `require`\n        // statements alone we are thus forced to jump through hoops in order\n        // to prevent `Critical dependency: ...` warnings in third-party\n        // deployments of the built `pdf.js`/`pdf.worker.js` files; see\n        // https://github.com/webpack/webpack/issues/8826\n        //\n        // The following hack is based on the assumption that code running in\n        // Node.js won't ever be affected by e.g. Content Security Policies that\n        // prevent the use of `eval`. If that ever occurs, we should revert this\n        // to a normal `__non_webpack_require__` statement and simply document\n        // the Webpack warnings instead (telling users to ignore them).\n        //\n        // eslint-disable-next-line no-eval\n        const worker = eval(\"require\")(this.workerSrc);\n        return worker.WorkerMessageHandler;\n      }\n      await loadScript(this.workerSrc);\n      return window.pdfjsWorker.WorkerMessageHandler;\n    };\n\n    return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n  }\n}\nif (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"GENERIC\")) {\n  PDFWorker.getWorkerSrc = function () {\n    deprecated(\n      \"`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.\"\n    );\n    return this.workerSrc;\n  };\n}\n\n/**\n * For internal use only.\n * @ignore\n */\nclass WorkerTransport {\n  #docStats = null;\n\n  #pageCache = new Map();\n\n  #pagePromises = new Map();\n\n  #metadataPromise = null;\n\n  constructor(messageHandler, loadingTask, networkStream, params) {\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new FontLoader({\n      docId: loadingTask.docId,\n      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n      ownerDocument: params.ownerDocument,\n      styleElement: params.styleElement,\n    });\n    this._params = params;\n\n    if (!params.useWorkerFetch) {\n      this.CMapReaderFactory = new params.CMapReaderFactory({\n        baseUrl: params.cMapUrl,\n        isCompressed: params.cMapPacked,\n      });\n      this.StandardFontDataFactory = new params.StandardFontDataFactory({\n        baseUrl: params.standardFontDataUrl,\n      });\n    }\n\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._passwordCapability = null;\n\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.downloadInfoCapability = createPromiseCapability();\n\n    this.setupMessageHandler();\n  }\n\n  get annotationStorage() {\n    return shadow(this, \"annotationStorage\", new AnnotationStorage());\n  }\n\n  get stats() {\n    return this.#docStats;\n  }\n\n  getRenderingIntent(\n    intent,\n    annotationMode = AnnotationMode.ENABLE,\n    isOpList = false\n  ) {\n    let renderingIntent = RenderingIntentFlag.DISPLAY; // Default value.\n    let lastModified = \"\";\n\n    switch (intent) {\n      case \"any\":\n        renderingIntent = RenderingIntentFlag.ANY;\n        break;\n      case \"display\":\n        break;\n      case \"print\":\n        renderingIntent = RenderingIntentFlag.PRINT;\n        break;\n      default:\n        warn(`getRenderingIntent - invalid intent: ${intent}`);\n    }\n\n    switch (annotationMode) {\n      case AnnotationMode.DISABLE:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n        break;\n      case AnnotationMode.ENABLE:\n        break;\n      case AnnotationMode.ENABLE_FORMS:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n        break;\n      case AnnotationMode.ENABLE_STORAGE:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n\n        lastModified = this.annotationStorage.lastModified;\n        break;\n      default:\n        warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n    }\n\n    if (isOpList) {\n      renderingIntent += RenderingIntentFlag.OPLIST;\n    }\n\n    return {\n      renderingIntent,\n      cacheKey: `${renderingIntent}_${lastModified}`,\n    };\n  }\n\n  destroy() {\n    if (this.destroyCapability) {\n      return this.destroyCapability.promise;\n    }\n\n    this.destroyed = true;\n    this.destroyCapability = createPromiseCapability();\n\n    if (this._passwordCapability) {\n      this._passwordCapability.reject(\n        new Error(\"Worker was destroyed during onPassword callback\")\n      );\n    }\n\n    const waitOn = [];\n    // We need to wait for all renderings to be completed, e.g.\n    // timeout/rAF can take a long time.\n    for (const page of this.#pageCache.values()) {\n      waitOn.push(page._destroy());\n    }\n    this.#pageCache.clear();\n    this.#pagePromises.clear();\n    // Allow `AnnotationStorage`-related clean-up when destroying the document.\n    if (this.hasOwnProperty(\"annotationStorage\")) {\n      this.annotationStorage.resetModified();\n    }\n    // We also need to wait for the worker to finish its long running tasks.\n    const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n    waitOn.push(terminated);\n\n    Promise.all(waitOn).then(() => {\n      this.commonObjs.clear();\n      this.fontLoader.clear();\n      this.#metadataPromise = null;\n      this._getFieldObjectsPromise = null;\n      this._hasJSActionsPromise = null;\n\n      if (this._networkStream) {\n        this._networkStream.cancelAllRequests(\n          new AbortException(\"Worker was terminated.\")\n        );\n      }\n\n      if (this.messageHandler) {\n        this.messageHandler.destroy();\n        this.messageHandler = null;\n      }\n      this.destroyCapability.resolve();\n    }, this.destroyCapability.reject);\n    return this.destroyCapability.promise;\n  }\n\n  setupMessageHandler() {\n    const { messageHandler, loadingTask } = this;\n\n    messageHandler.on(\"GetReader\", (data, sink) => {\n      assert(\n        this._networkStream,\n        \"GetReader - no `IPDFStream` instance available.\"\n      );\n      this._fullReader = this._networkStream.getFullReader();\n      this._fullReader.onProgress = evt => {\n        this._lastProgress = {\n          loaded: evt.loaded,\n          total: evt.total,\n        };\n      };\n      sink.onPull = () => {\n        this._fullReader\n          .read()\n          .then(function ({ value, done }) {\n            if (done) {\n              sink.close();\n              return;\n            }\n            assert(\n              isArrayBuffer(value),\n              \"GetReader - expected an ArrayBuffer.\"\n            );\n            // Enqueue data chunk into sink, and transfer it\n            // to other side as `Transferable` object.\n            sink.enqueue(new Uint8Array(value), 1, [value]);\n          })\n          .catch(reason => {\n            sink.error(reason);\n          });\n      };\n\n      sink.onCancel = reason => {\n        this._fullReader.cancel(reason);\n\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return; // Ignore any pending requests if the worker was terminated.\n          }\n          throw readyReason;\n        });\n      };\n    });\n\n    messageHandler.on(\"ReaderHeadersReady\", data => {\n      const headersCapability = createPromiseCapability();\n      const fullReader = this._fullReader;\n      fullReader.headersReady.then(() => {\n        // If stream or range are disabled, it's our only way to report\n        // loading progress.\n        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n          if (this._lastProgress) {\n            loadingTask.onProgress?.(this._lastProgress);\n          }\n          fullReader.onProgress = evt => {\n            loadingTask.onProgress?.({\n              loaded: evt.loaded,\n              total: evt.total,\n            });\n          };\n        }\n\n        headersCapability.resolve({\n          isStreamingSupported: fullReader.isStreamingSupported,\n          isRangeSupported: fullReader.isRangeSupported,\n          contentLength: fullReader.contentLength,\n        });\n      }, headersCapability.reject);\n\n      return headersCapability.promise;\n    });\n\n    messageHandler.on(\"GetRangeReader\", (data, sink) => {\n      assert(\n        this._networkStream,\n        \"GetRangeReader - no `IPDFStream` instance available.\"\n      );\n      const rangeReader = this._networkStream.getRangeReader(\n        data.begin,\n        data.end\n      );\n\n      // When streaming is enabled, it's possible that the data requested here\n      // has already been fetched via the `_fullRequestReader` implementation.\n      // However, given that the PDF data is loaded asynchronously on the\n      // main-thread and then sent via `postMessage` to the worker-thread,\n      // it may not have been available during parsing (hence the attempt to\n      // use range requests here).\n      //\n      // To avoid wasting time and resources here, we'll thus *not* dispatch\n      // range requests if the data was already loaded but has not been sent to\n      // the worker-thread yet (which will happen via the `_fullRequestReader`).\n      if (!rangeReader) {\n        sink.close();\n        return;\n      }\n\n      sink.onPull = () => {\n        rangeReader\n          .read()\n          .then(function ({ value, done }) {\n            if (done) {\n              sink.close();\n              return;\n            }\n            assert(\n              isArrayBuffer(value),\n              \"GetRangeReader - expected an ArrayBuffer.\"\n            );\n            sink.enqueue(new Uint8Array(value), 1, [value]);\n          })\n          .catch(reason => {\n            sink.error(reason);\n          });\n      };\n\n      sink.onCancel = reason => {\n        rangeReader.cancel(reason);\n\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return; // Ignore any pending requests if the worker was terminated.\n          }\n          throw readyReason;\n        });\n      };\n    });\n\n    messageHandler.on(\"GetDoc\", ({ pdfInfo }) => {\n      this._numPages = pdfInfo.numPages;\n      this._htmlForXfa = pdfInfo.htmlForXfa;\n      delete pdfInfo.htmlForXfa;\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n    });\n\n    messageHandler.on(\"DocException\", function (ex) {\n      let reason;\n      switch (ex.name) {\n        case \"PasswordException\":\n          reason = new PasswordException(ex.message, ex.code);\n          break;\n        case \"InvalidPDFException\":\n          reason = new InvalidPDFException(ex.message);\n          break;\n        case \"MissingPDFException\":\n          reason = new MissingPDFException(ex.message);\n          break;\n        case \"UnexpectedResponseException\":\n          reason = new UnexpectedResponseException(ex.message, ex.status);\n          break;\n        case \"UnknownErrorException\":\n          reason = new UnknownErrorException(ex.message, ex.details);\n          break;\n        default:\n          unreachable(\"DocException - expected a valid Error.\");\n      }\n      loadingTask._capability.reject(reason);\n    });\n\n    messageHandler.on(\"PasswordRequest\", exception => {\n      this._passwordCapability = createPromiseCapability();\n\n      if (loadingTask.onPassword) {\n        const updatePassword = password => {\n          this._passwordCapability.resolve({\n            password,\n          });\n        };\n        try {\n          loadingTask.onPassword(updatePassword, exception.code);\n        } catch (ex) {\n          this._passwordCapability.reject(ex);\n        }\n      } else {\n        this._passwordCapability.reject(\n          new PasswordException(exception.message, exception.code)\n        );\n      }\n      return this._passwordCapability.promise;\n    });\n\n    messageHandler.on(\"DataLoaded\", data => {\n      // For consistency: Ensure that progress is always reported when the\n      // entire PDF file has been loaded, regardless of how it was fetched.\n      loadingTask.onProgress?.({\n        loaded: data.length,\n        total: data.length,\n      });\n\n      this.downloadInfoCapability.resolve(data);\n    });\n\n    messageHandler.on(\"StartRenderPage\", data => {\n      if (this.destroyed) {\n        return; // Ignore any pending requests if the worker was terminated.\n      }\n\n      const page = this.#pageCache.get(data.pageIndex);\n      page._startRenderPage(data.transparency, data.cacheKey);\n    });\n\n    messageHandler.on(\"commonobj\", ([id, type, exportedData]) => {\n      if (this.destroyed) {\n        return; // Ignore any pending requests if the worker was terminated.\n      }\n\n      if (this.commonObjs.has(id)) {\n        return;\n      }\n\n      switch (type) {\n        case \"Font\":\n          const params = this._params;\n\n          if (\"error\" in exportedData) {\n            const exportedError = exportedData.error;\n            warn(`Error during font loading: ${exportedError}`);\n            this.commonObjs.resolve(id, exportedError);\n            break;\n          }\n\n          let fontRegistry = null;\n          if (params.pdfBug && globalThis.FontInspector?.enabled) {\n            fontRegistry = {\n              registerFont(font, url) {\n                globalThis.FontInspector.fontAdded(font, url);\n              },\n            };\n          }\n          const font = new FontFaceObject(exportedData, {\n            isEvalSupported: params.isEvalSupported,\n            disableFontFace: params.disableFontFace,\n            ignoreErrors: params.ignoreErrors,\n            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n            fontRegistry,\n          });\n\n          this.fontLoader\n            .bind(font)\n            .catch(reason => {\n              return messageHandler.sendWithPromise(\"FontFallback\", { id });\n            })\n            .finally(() => {\n              if (!params.fontExtraProperties && font.data) {\n                // Immediately release the `font.data` property once the font\n                // has been attached to the DOM, since it's no longer needed,\n                // rather than waiting for a `PDFDocumentProxy.cleanup` call.\n                // Since `font.data` could be very large, e.g. in some cases\n                // multiple megabytes, this will help reduce memory usage.\n                font.data = null;\n              }\n              this.commonObjs.resolve(id, font);\n            });\n          break;\n        case \"FontPath\":\n        case \"Image\":\n          this.commonObjs.resolve(id, exportedData);\n          break;\n        default:\n          throw new Error(`Got unknown common object type ${type}`);\n      }\n    });\n\n    messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n      if (this.destroyed) {\n        // Ignore any pending requests if the worker was terminated.\n        return;\n      }\n\n      const pageProxy = this.#pageCache.get(pageIndex);\n      if (pageProxy.objs.has(id)) {\n        return;\n      }\n\n      switch (type) {\n        case \"Image\":\n          pageProxy.objs.resolve(id, imageData);\n\n          // Heuristic that will allow us not to store large data.\n          const MAX_IMAGE_SIZE_TO_STORE = 8000000;\n          if (imageData?.data?.length > MAX_IMAGE_SIZE_TO_STORE) {\n            pageProxy.cleanupAfterRender = true;\n          }\n          break;\n        case \"Pattern\":\n          pageProxy.objs.resolve(id, imageData);\n          break;\n        default:\n          throw new Error(`Got unknown object type ${type}`);\n      }\n    });\n\n    messageHandler.on(\"DocProgress\", data => {\n      if (this.destroyed) {\n        return; // Ignore any pending requests if the worker was terminated.\n      }\n      loadingTask.onProgress?.({\n        loaded: data.loaded,\n        total: data.total,\n      });\n    });\n\n    messageHandler.on(\"DocStats\", data => {\n      if (this.destroyed) {\n        return; // Ignore any pending requests if the worker was terminated.\n      }\n      // Ensure that a `PDFDocumentProxy.stats` call-site cannot accidentally\n      // modify this internal data.\n      this.#docStats = Object.freeze({\n        streamTypes: Object.freeze(data.streamTypes),\n        fontTypes: Object.freeze(data.fontTypes),\n      });\n    });\n\n    messageHandler.on(\n      \"UnsupportedFeature\",\n      this._onUnsupportedFeature.bind(this)\n    );\n\n    messageHandler.on(\"FetchBuiltInCMap\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n      if (!this.CMapReaderFactory) {\n        return Promise.reject(\n          new Error(\n            \"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"\n          )\n        );\n      }\n      return this.CMapReaderFactory.fetch(data);\n    });\n\n    messageHandler.on(\"FetchStandardFontData\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n      if (!this.StandardFontDataFactory) {\n        return Promise.reject(\n          new Error(\n            \"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"\n          )\n        );\n      }\n      return this.StandardFontDataFactory.fetch(data);\n    });\n  }\n\n  _onUnsupportedFeature({ featureId }) {\n    if (this.destroyed) {\n      return; // Ignore any pending requests if the worker was terminated.\n    }\n    this.loadingTask.onUnsupportedFeature?.(featureId);\n  }\n\n  getData() {\n    return this.messageHandler.sendWithPromise(\"GetData\", null);\n  }\n\n  getPage(pageNumber) {\n    if (\n      !Number.isInteger(pageNumber) ||\n      pageNumber <= 0 ||\n      pageNumber > this._numPages\n    ) {\n      return Promise.reject(new Error(\"Invalid page request\"));\n    }\n\n    const pageIndex = pageNumber - 1,\n      cachedPromise = this.#pagePromises.get(pageIndex);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler\n      .sendWithPromise(\"GetPage\", {\n        pageIndex,\n      })\n      .then(pageInfo => {\n        if (this.destroyed) {\n          throw new Error(\"Transport destroyed\");\n        }\n        const page = new PDFPageProxy(\n          pageIndex,\n          pageInfo,\n          this,\n          this._params.ownerDocument,\n          this._params.pdfBug\n        );\n        this.#pageCache.set(pageIndex, page);\n        return page;\n      });\n    this.#pagePromises.set(pageIndex, promise);\n    return promise;\n  }\n\n  getPageIndex(ref) {\n    return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n      ref,\n    });\n  }\n\n  getAnnotations(pageIndex, intent) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n      pageIndex,\n      intent,\n    });\n  }\n\n  saveDocument() {\n    return this.messageHandler\n      .sendWithPromise(\"SaveDocument\", {\n        isPureXfa: !!this._htmlForXfa,\n        numPages: this._numPages,\n        annotationStorage: this.annotationStorage.serializable,\n        filename: this._fullReader?.filename ?? null,\n      })\n      .finally(() => {\n        this.annotationStorage.resetModified();\n      });\n  }\n\n  getFieldObjects() {\n    return (this._getFieldObjectsPromise ||=\n      this.messageHandler.sendWithPromise(\"GetFieldObjects\", null));\n  }\n\n  hasJSActions() {\n    return (this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise(\n      \"HasJSActions\",\n      null\n    ));\n  }\n\n  getCalculationOrderIds() {\n    return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n  }\n\n  getDestinations() {\n    return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n  }\n\n  getDestination(id) {\n    if (typeof id !== \"string\") {\n      return Promise.reject(new Error(\"Invalid destination request.\"));\n    }\n    return this.messageHandler.sendWithPromise(\"GetDestination\", {\n      id,\n    });\n  }\n\n  getPageLabels() {\n    return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n  }\n\n  getPageLayout() {\n    return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n  }\n\n  getPageMode() {\n    return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n  }\n\n  getViewerPreferences() {\n    return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n  }\n\n  getOpenAction() {\n    return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n  }\n\n  getAttachments() {\n    return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n  }\n\n  getJavaScript() {\n    return this.messageHandler.sendWithPromise(\"GetJavaScript\", null);\n  }\n\n  getDocJSActions() {\n    return this.messageHandler.sendWithPromise(\"GetDocJSActions\", null);\n  }\n\n  getPageJSActions(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n      pageIndex,\n    });\n  }\n\n  getStructTree(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n      pageIndex,\n    });\n  }\n\n  getOutline() {\n    return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n  }\n\n  getOptionalContentConfig() {\n    return this.messageHandler\n      .sendWithPromise(\"GetOptionalContentConfig\", null)\n      .then(results => {\n        return new OptionalContentConfig(results);\n      });\n  }\n\n  getPermissions() {\n    return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n  }\n\n  getMetadata() {\n    return (this.#metadataPromise ||= this.messageHandler\n      .sendWithPromise(\"GetMetadata\", null)\n      .then(results => {\n        return {\n          info: results[0],\n          metadata: results[1] ? new Metadata(results[1]) : null,\n          contentDispositionFilename: this._fullReader?.filename ?? null,\n          contentLength: this._fullReader?.contentLength ?? null,\n        };\n      }));\n  }\n\n  getMarkInfo() {\n    return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n  }\n\n  async startCleanup(keepLoadedFonts = false) {\n    await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n\n    if (this.destroyed) {\n      return; // No need to manually clean-up when destruction has started.\n    }\n    for (const page of this.#pageCache.values()) {\n      const cleanupSuccessful = page.cleanup();\n\n      if (!cleanupSuccessful) {\n        throw new Error(\n          `startCleanup: Page ${page.pageNumber} is currently rendering.`\n        );\n      }\n    }\n    this.commonObjs.clear();\n    if (!keepLoadedFonts) {\n      this.fontLoader.clear();\n    }\n    this.#metadataPromise = null;\n    this._getFieldObjectsPromise = null;\n    this._hasJSActionsPromise = null;\n  }\n\n  get loadingParams() {\n    const params = this._params;\n    return shadow(this, \"loadingParams\", {\n      disableAutoFetch: params.disableAutoFetch,\n      enableXfa: params.enableXfa,\n    });\n  }\n}\n\n/**\n * A PDF document and page is built of many objects. E.g. there are objects for\n * fonts, images, rendering code, etc. These objects may get processed inside of\n * a worker. This class implements some basic methods to manage these objects.\n * @ignore\n */\nclass PDFObjects {\n  constructor() {\n    this._objs = Object.create(null);\n  }\n\n  /**\n   * Ensures there is an object defined for `objId`.\n   * @private\n   */\n  _ensureObj(objId) {\n    if (this._objs[objId]) {\n      return this._objs[objId];\n    }\n    return (this._objs[objId] = {\n      capability: createPromiseCapability(),\n      data: null,\n      resolved: false,\n    });\n  }\n\n  /**\n   * If called *without* callback, this returns the data of `objId` but the\n   * object needs to be resolved. If it isn't, this method throws.\n   *\n   * If called *with* a callback, the callback is called with the data of the\n   * object once the object is resolved. That means, if you call this method\n   * and the object is already resolved, the callback gets called right away.\n   */\n  get(objId, callback = null) {\n    // If there is a callback, then the get can be async and the object is\n    // not required to be resolved right now.\n    if (callback) {\n      this._ensureObj(objId).capability.promise.then(callback);\n      return null;\n    }\n    // If there isn't a callback, the user expects to get the resolved data\n    // directly.\n    const obj = this._objs[objId];\n    // If there isn't an object yet or the object isn't resolved, then the\n    // data isn't ready yet!\n    if (!obj || !obj.resolved) {\n      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n    }\n    return obj.data;\n  }\n\n  has(objId) {\n    const obj = this._objs[objId];\n    return obj?.resolved || false;\n  }\n\n  /**\n   * Resolves the object `objId` with optional `data`.\n   */\n  resolve(objId, data) {\n    const obj = this._ensureObj(objId);\n\n    obj.resolved = true;\n    obj.data = data;\n    obj.capability.resolve(data);\n  }\n\n  clear() {\n    this._objs = Object.create(null);\n  }\n}\n\n/**\n * Allows controlling of the rendering tasks.\n */\nclass RenderTask {\n  constructor(internalRenderTask) {\n    this._internalRenderTask = internalRenderTask;\n\n    /**\n     * Callback for incremental rendering -- a function that will be called\n     * each time the rendering is paused.  To continue rendering call the\n     * function that is the first argument to the callback.\n     * @type {function}\n     */\n    this.onContinue = null;\n  }\n\n  /**\n   * Promise for rendering task completion.\n   * @type {Promise<void>}\n   */\n  get promise() {\n    return this._internalRenderTask.capability.promise;\n  }\n\n  /**\n   * Cancels the rendering task. If the task is currently rendering it will\n   * not be cancelled until graphics pauses with a timeout. The promise that\n   * this object extends will be rejected when cancelled.\n   */\n  cancel() {\n    this._internalRenderTask.cancel();\n  }\n}\n\n/**\n * For internal use only.\n * @ignore\n */\nclass InternalRenderTask {\n  static get canvasInUse() {\n    return shadow(this, \"canvasInUse\", new WeakSet());\n  }\n\n  constructor({\n    callback,\n    params,\n    objs,\n    commonObjs,\n    annotationCanvasMap,\n    operatorList,\n    pageIndex,\n    canvasFactory,\n    useRequestAnimationFrame = false,\n    pdfBug = false,\n  }) {\n    this.callback = callback;\n    this.params = params;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.operatorListIdx = null;\n    this.operatorList = operatorList;\n    this._pageIndex = pageIndex;\n    this.canvasFactory = canvasFactory;\n    this._pdfBug = pdfBug;\n\n    this.running = false;\n    this.graphicsReadyCallback = null;\n    this.graphicsReady = false;\n    this._useRequestAnimationFrame =\n      useRequestAnimationFrame === true && typeof window !== \"undefined\";\n    this.cancelled = false;\n    this.capability = createPromiseCapability();\n    this.task = new RenderTask(this);\n    // caching this-bound methods\n    this._cancelBound = this.cancel.bind(this);\n    this._continueBound = this._continue.bind(this);\n    this._scheduleNextBound = this._scheduleNext.bind(this);\n    this._nextBound = this._next.bind(this);\n    this._canvas = params.canvasContext.canvas;\n  }\n\n  get completed() {\n    return this.capability.promise.catch(function () {\n      // Ignoring errors, since we only want to know when rendering is\n      // no longer pending.\n    });\n  }\n\n  initializeGraphics({ transparency = false, optionalContentConfig }) {\n    if (this.cancelled) {\n      return;\n    }\n    if (this._canvas) {\n      if (InternalRenderTask.canvasInUse.has(this._canvas)) {\n        throw new Error(\n          \"Cannot use the same canvas during multiple render() operations. \" +\n            \"Use different canvas or ensure previous operations were \" +\n            \"cancelled or completed.\"\n        );\n      }\n      InternalRenderTask.canvasInUse.add(this._canvas);\n    }\n\n    if (this._pdfBug && globalThis.StepperManager?.enabled) {\n      this.stepper = globalThis.StepperManager.create(this._pageIndex);\n      this.stepper.init(this.operatorList);\n      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n    }\n    const { canvasContext, viewport, transform, imageLayer, background } =\n      this.params;\n\n    this.gfx = new CanvasGraphics(\n      canvasContext,\n      this.commonObjs,\n      this.objs,\n      this.canvasFactory,\n      imageLayer,\n      optionalContentConfig,\n      this.annotationCanvasMap\n    );\n    this.gfx.beginDrawing({\n      transform,\n      viewport,\n      transparency,\n      background,\n    });\n    this.operatorListIdx = 0;\n    this.graphicsReady = true;\n    if (this.graphicsReadyCallback) {\n      this.graphicsReadyCallback();\n    }\n  }\n\n  cancel(error = null) {\n    this.running = false;\n    this.cancelled = true;\n    if (this.gfx) {\n      this.gfx.endDrawing();\n    }\n    if (this._canvas) {\n      InternalRenderTask.canvasInUse.delete(this._canvas);\n    }\n    this.callback(\n      error ||\n        new RenderingCancelledException(\n          `Rendering cancelled, page ${this._pageIndex + 1}`,\n          \"canvas\"\n        )\n    );\n  }\n\n  operatorListChanged() {\n    if (!this.graphicsReady) {\n      if (!this.graphicsReadyCallback) {\n        this.graphicsReadyCallback = this._continueBound;\n      }\n      return;\n    }\n\n    if (this.stepper) {\n      this.stepper.updateOperatorList(this.operatorList);\n    }\n\n    if (this.running) {\n      return;\n    }\n    this._continue();\n  }\n\n  _continue() {\n    this.running = true;\n    if (this.cancelled) {\n      return;\n    }\n    if (this.task.onContinue) {\n      this.task.onContinue(this._scheduleNextBound);\n    } else {\n      this._scheduleNext();\n    }\n  }\n\n  _scheduleNext() {\n    if (this._useRequestAnimationFrame) {\n      window.requestAnimationFrame(() => {\n        this._nextBound().catch(this._cancelBound);\n      });\n    } else {\n      Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n    }\n  }\n\n  async _next() {\n    if (this.cancelled) {\n      return;\n    }\n    this.operatorListIdx = this.gfx.executeOperatorList(\n      this.operatorList,\n      this.operatorListIdx,\n      this._continueBound,\n      this.stepper\n    );\n    if (this.operatorListIdx === this.operatorList.argsArray.length) {\n      this.running = false;\n      if (this.operatorList.lastChunk) {\n        this.gfx.endDrawing();\n        if (this._canvas) {\n          InternalRenderTask.canvasInUse.delete(this._canvas);\n        }\n        this.callback();\n      }\n    }\n  }\n}\n\n/** @type {string} */\nconst version =\n  typeof PDFJSDev !== \"undefined\" ? PDFJSDev.eval(\"BUNDLE_VERSION\") : null;\n/** @type {string} */\nconst build =\n  typeof PDFJSDev !== \"undefined\" ? PDFJSDev.eval(\"BUNDLE_BUILD\") : null;\n\nexport {\n  build,\n  DefaultCanvasFactory,\n  DefaultCMapReaderFactory,\n  DefaultStandardFontDataFactory,\n  getDocument,\n  LoopbackPort,\n  PDFDataRangeTransport,\n  PDFDocumentLoadingTask,\n  PDFDocumentProxy,\n  PDFPageProxy,\n  PDFWorker,\n  RenderTask,\n  setPDFNetworkStreamFactory,\n  version,\n};\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  assert,\n  bytesToString,\n  IsEvalSupportedCached,\n  shadow,\n  string32,\n  unreachable,\n  UNSUPPORTED_FEATURES,\n  warn,\n} from \"../shared/util.js\";\n\nclass BaseFontLoader {\n  constructor({\n    docId,\n    onUnsupportedFeature,\n    ownerDocument = globalThis.document,\n    // For testing only.\n    styleElement = null,\n  }) {\n    if (this.constructor === BaseFontLoader) {\n      unreachable(\"Cannot initialize BaseFontLoader.\");\n    }\n    this.docId = docId;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this._document = ownerDocument;\n\n    this.nativeFontFaces = [];\n    this.styleElement =\n      typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"!PRODUCTION || TESTING\")\n        ? styleElement\n        : null;\n  }\n\n  addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.push(nativeFontFace);\n    this._document.fonts.add(nativeFontFace);\n  }\n\n  insertRule(rule) {\n    let styleElement = this.styleElement;\n    if (!styleElement) {\n      styleElement = this.styleElement = this._document.createElement(\"style\");\n      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;\n      this._document.documentElement\n        .getElementsByTagName(\"head\")[0]\n        .appendChild(styleElement);\n    }\n    const styleSheet = styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  }\n\n  clear() {\n    for (const nativeFontFace of this.nativeFontFaces) {\n      this._document.fonts.delete(nativeFontFace);\n    }\n    this.nativeFontFaces.length = 0;\n\n    if (this.styleElement) {\n      // Note: ChildNode.remove doesn't throw if the parentNode is undefined.\n      this.styleElement.remove();\n      this.styleElement = null;\n    }\n  }\n\n  async bind(font) {\n    // Add the font to the DOM only once; skip if the font is already loaded.\n    if (font.attached || font.missingFile) {\n      return;\n    }\n    font.attached = true;\n\n    if (this.isFontLoadingAPISupported) {\n      const nativeFontFace = font.createNativeFontFace();\n      if (nativeFontFace) {\n        this.addNativeFontFace(nativeFontFace);\n        try {\n          await nativeFontFace.loaded;\n        } catch (ex) {\n          this._onUnsupportedFeature({\n            featureId: UNSUPPORTED_FEATURES.errorFontLoadNative,\n          });\n          warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n\n          // When font loading failed, fall back to the built-in font renderer.\n          font.disableFontFace = true;\n          throw ex;\n        }\n      }\n      return; // The font was, asynchronously, loaded.\n    }\n\n    // !this.isFontLoadingAPISupported\n    const rule = font.createFontFaceRule();\n    if (rule) {\n      this.insertRule(rule);\n\n      if (this.isSyncFontLoadingSupported) {\n        return; // The font was, synchronously, loaded.\n      }\n      await new Promise(resolve => {\n        const request = this._queueLoadingCallback(resolve);\n        this._prepareFontLoadEvent([rule], [font], request);\n      });\n      // The font was, asynchronously, loaded.\n    }\n  }\n\n  _queueLoadingCallback(callback) {\n    unreachable(\"Abstract method `_queueLoadingCallback`.\");\n  }\n\n  get isFontLoadingAPISupported() {\n    const hasFonts = !!this._document?.fonts;\n    if (\n      typeof PDFJSDev === \"undefined\" ||\n      PDFJSDev.test(\"!PRODUCTION || TESTING\")\n    ) {\n      return shadow(\n        this,\n        \"isFontLoadingAPISupported\",\n        hasFonts && !this.styleElement\n      );\n    }\n    return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n  }\n\n  // eslint-disable-next-line getter-return\n  get isSyncFontLoadingSupported() {\n    unreachable(\"Abstract method `isSyncFontLoadingSupported`.\");\n  }\n\n  // eslint-disable-next-line getter-return\n  get _loadTestFont() {\n    unreachable(\"Abstract method `_loadTestFont`.\");\n  }\n\n  _prepareFontLoadEvent(rules, fontsToLoad, request) {\n    unreachable(\"Abstract method `_prepareFontLoadEvent`.\");\n  }\n}\n\nlet FontLoader;\nif (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\n  FontLoader = class MozcentralFontLoader extends BaseFontLoader {\n    get isSyncFontLoadingSupported() {\n      return shadow(this, \"isSyncFontLoadingSupported\", true);\n    }\n  };\n} else {\n  // PDFJSDev.test('CHROME || GENERIC')\n\n  FontLoader = class GenericFontLoader extends BaseFontLoader {\n    constructor(params) {\n      super(params);\n      this.loadingContext = {\n        requests: [],\n        nextRequestId: 0,\n      };\n      this.loadTestFontId = 0;\n    }\n\n    get isSyncFontLoadingSupported() {\n      let supported = false;\n      if (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"CHROME\")) {\n        if (typeof navigator === \"undefined\") {\n          // Node.js - we can pretend that sync font loading is supported.\n          supported = true;\n        } else {\n          // User agent string sniffing is bad, but there is no reliable way to\n          // tell if the font is fully loaded and ready to be used with canvas.\n          const m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(\n            navigator.userAgent\n          );\n          if (m?.[1] >= 14) {\n            supported = true;\n          }\n          // TODO - other browsers...\n        }\n      }\n      return shadow(this, \"isSyncFontLoadingSupported\", supported);\n    }\n\n    _queueLoadingCallback(callback) {\n      function completeRequest() {\n        assert(!request.done, \"completeRequest() cannot be called twice.\");\n        request.done = true;\n\n        // Sending all completed requests in order of how they were queued.\n        while (context.requests.length > 0 && context.requests[0].done) {\n          const otherRequest = context.requests.shift();\n          setTimeout(otherRequest.callback, 0);\n        }\n      }\n\n      const context = this.loadingContext;\n      const request = {\n        id: `pdfjs-font-loading-${context.nextRequestId++}`,\n        done: false,\n        complete: completeRequest,\n        callback,\n      };\n      context.requests.push(request);\n      return request;\n    }\n\n    get _loadTestFont() {\n      const getLoadTestFont = function () {\n        // This is a CFF font with 1 glyph for '.' that fills its entire width\n        // and height.\n        return atob(\n          \"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" +\n            \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" +\n            \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" +\n            \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" +\n            \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" +\n            \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" +\n            \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" +\n            \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" +\n            \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" +\n            \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" +\n            \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" +\n            \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" +\n            \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" +\n            \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" +\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" +\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" +\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" +\n            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" +\n            \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" +\n            \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" +\n            \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" +\n            \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\"\n        );\n      };\n      return shadow(this, \"_loadTestFont\", getLoadTestFont());\n    }\n\n    _prepareFontLoadEvent(rules, fonts, request) {\n      /** Hack begin */\n      // There's currently no event when a font has finished downloading so the\n      // following code is a dirty hack to 'guess' when a font is ready.\n      // It's assumed fonts are loaded in order, so add a known test font after\n      // the desired fonts and then test for the loading of that test font.\n\n      function int32(data, offset) {\n        return (\n          (data.charCodeAt(offset) << 24) |\n          (data.charCodeAt(offset + 1) << 16) |\n          (data.charCodeAt(offset + 2) << 8) |\n          (data.charCodeAt(offset + 3) & 0xff)\n        );\n      }\n      function spliceString(s, offset, remove, insert) {\n        const chunk1 = s.substring(0, offset);\n        const chunk2 = s.substring(offset + remove);\n        return chunk1 + insert + chunk2;\n      }\n      let i, ii;\n\n      // The temporary canvas is used to determine if fonts are loaded.\n      const canvas = this._document.createElement(\"canvas\");\n      canvas.width = 1;\n      canvas.height = 1;\n      const ctx = canvas.getContext(\"2d\");\n\n      let called = 0;\n      function isFontReady(name, callback) {\n        called++;\n        // With setTimeout clamping this gives the font ~100ms to load.\n        if (called > 30) {\n          warn(\"Load test font never loaded.\");\n          callback();\n          return;\n        }\n        ctx.font = \"30px \" + name;\n        ctx.fillText(\".\", 0, 20);\n        const imageData = ctx.getImageData(0, 0, 1, 1);\n        if (imageData.data[3] > 0) {\n          callback();\n          return;\n        }\n        setTimeout(isFontReady.bind(null, name, callback));\n      }\n\n      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n      // Chromium seems to cache fonts based on a hash of the actual font data,\n      // so the font must be modified for each load test else it will appear to\n      // be loaded already.\n      // TODO: This could maybe be made faster by avoiding the btoa of the full\n      // font by splitting it in chunks before hand and padding the font id.\n      let data = this._loadTestFont;\n      const COMMENT_OFFSET = 976; // has to be on 4 byte boundary (for checksum)\n      data = spliceString(\n        data,\n        COMMENT_OFFSET,\n        loadTestFontId.length,\n        loadTestFontId\n      );\n      // CFF checksum is important for IE, adjusting it\n      const CFF_CHECKSUM_OFFSET = 16;\n      const XXXX_VALUE = 0x58585858; // the \"comment\" filled with 'X'\n      let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n        checksum = (checksum - XXXX_VALUE + int32(loadTestFontId, i)) | 0;\n      }\n      if (i < loadTestFontId.length) {\n        // align to 4 bytes boundary\n        checksum =\n          (checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i)) | 0;\n      }\n      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n\n      const url = `url(data:font/opentype;base64,${btoa(data)});`;\n      const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n      this.insertRule(rule);\n\n      const names = [];\n      for (const font of fonts) {\n        names.push(font.loadedName);\n      }\n      names.push(loadTestFontId);\n\n      const div = this._document.createElement(\"div\");\n      div.style.visibility = \"hidden\";\n      div.style.width = div.style.height = \"10px\";\n      div.style.position = \"absolute\";\n      div.style.top = div.style.left = \"0px\";\n\n      for (const name of names) {\n        const span = this._document.createElement(\"span\");\n        span.textContent = \"Hi\";\n        span.style.fontFamily = name;\n        div.appendChild(span);\n      }\n      this._document.body.appendChild(div);\n\n      isFontReady(loadTestFontId, () => {\n        div.remove();\n        request.complete();\n      });\n      /** Hack end */\n    }\n  };\n} // End of PDFJSDev.test('CHROME || GENERIC')\n\nclass FontFaceObject {\n  constructor(\n    translatedData,\n    {\n      isEvalSupported = true,\n      disableFontFace = false,\n      ignoreErrors = false,\n      onUnsupportedFeature,\n      fontRegistry = null,\n    }\n  ) {\n    this.compiledGlyphs = Object.create(null);\n    // importing translated data\n    for (const i in translatedData) {\n      this[i] = translatedData[i];\n    }\n    this.isEvalSupported = isEvalSupported !== false;\n    this.disableFontFace = disableFontFace === true;\n    this.ignoreErrors = ignoreErrors === true;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this.fontRegistry = fontRegistry;\n  }\n\n  createNativeFontFace() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    let nativeFontFace;\n    if (!this.cssFontInfo) {\n      nativeFontFace = new FontFace(this.loadedName, this.data, {});\n    } else {\n      const css = {\n        weight: this.cssFontInfo.fontWeight,\n      };\n      if (this.cssFontInfo.italicAngle) {\n        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n      }\n      nativeFontFace = new FontFace(\n        this.cssFontInfo.fontFamily,\n        this.data,\n        css\n      );\n    }\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this);\n    }\n    return nativeFontFace;\n  }\n\n  createFontFaceRule() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    const data = bytesToString(this.data);\n    // Add the @font-face rule to the document.\n    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n    let rule;\n    if (!this.cssFontInfo) {\n      rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n    } else {\n      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n      if (this.cssFontInfo.italicAngle) {\n        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n      }\n      rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n    }\n\n    if (this.fontRegistry) {\n      this.fontRegistry.registerFont(this, url);\n    }\n    return rule;\n  }\n\n  getPathGenerator(objs, character) {\n    if (this.compiledGlyphs[character] !== undefined) {\n      return this.compiledGlyphs[character];\n    }\n\n    let cmds;\n    try {\n      cmds = objs.get(this.loadedName + \"_path_\" + character);\n    } catch (ex) {\n      if (!this.ignoreErrors) {\n        throw ex;\n      }\n      this._onUnsupportedFeature({\n        featureId: UNSUPPORTED_FEATURES.errorFontGetPath,\n      });\n      warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n\n      return (this.compiledGlyphs[character] = function (c, size) {\n        // No-op function, to allow rendering to continue.\n      });\n    }\n\n    // If we can, compile cmds into JS for MAXIMUM SPEED...\n    if (this.isEvalSupported && IsEvalSupportedCached.value) {\n      const jsBuf = [];\n      for (const current of cmds) {\n        const args = current.args !== undefined ? current.args.join(\",\") : \"\";\n        jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n      }\n      // eslint-disable-next-line no-new-func\n      return (this.compiledGlyphs[character] = new Function(\n        \"c\",\n        \"size\",\n        jsBuf.join(\"\")\n      ));\n    }\n    // ... but fall back on using Function.prototype.apply() if we're\n    // blocked from using eval() for whatever reason (like CSP policies).\n    return (this.compiledGlyphs[character] = function (c, size) {\n      for (const current of cmds) {\n        if (current.cmd === \"scale\") {\n          current.args = [size, -size];\n        }\n        c[current.cmd].apply(c, current.args);\n      }\n    });\n  }\n}\n\nexport { FontFaceObject, FontLoader };\n","/* Copyright 2020 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* globals __non_webpack_require__ */\n\nimport {\n  BaseCanvasFactory,\n  BaseCMapReaderFactory,\n  BaseStandardFontDataFactory,\n} from \"./base_factory.js\";\nimport { isNodeJS } from \"../shared/is_node.js\";\nimport { unreachable } from \"../shared/util.js\";\n\nlet NodeCanvasFactory = class {\n  constructor() {\n    unreachable(\"Not implemented: NodeCanvasFactory\");\n  }\n};\n\nlet NodeCMapReaderFactory = class {\n  constructor() {\n    unreachable(\"Not implemented: NodeCMapReaderFactory\");\n  }\n};\n\nlet NodeStandardFontDataFactory = class {\n  constructor() {\n    unreachable(\"Not implemented: NodeStandardFontDataFactory\");\n  }\n};\n\nif ((typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) && isNodeJS) {\n  const fetchData = function (url) {\n    return new Promise((resolve, reject) => {\n      const fs = __non_webpack_require__(\"fs\");\n      fs.readFile(url, (error, data) => {\n        if (error || !data) {\n          reject(new Error(error));\n          return;\n        }\n        resolve(new Uint8Array(data));\n      });\n    });\n  };\n\n  NodeCanvasFactory = class extends BaseCanvasFactory {\n    _createCanvas(width, height) {\n      const Canvas = __non_webpack_require__(\"canvas\");\n      return Canvas.createCanvas(width, height);\n    }\n  };\n\n  NodeCMapReaderFactory = class extends BaseCMapReaderFactory {\n    _fetchData(url, compressionType) {\n      return fetchData(url).then(data => {\n        return { cMapData: data, compressionType };\n      });\n    }\n  };\n\n  NodeStandardFontDataFactory = class extends BaseStandardFontDataFactory {\n    _fetchData(url) {\n      return fetchData(url);\n    }\n  };\n}\n\nexport {\n  NodeCanvasFactory,\n  NodeCMapReaderFactory,\n  NodeStandardFontDataFactory,\n};\n","/* Copyright 2020 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { objectFromMap } from \"../shared/util.js\";\n\n/**\n * Key/value storage for annotation data in forms.\n */\nclass AnnotationStorage {\n  constructor() {\n    this._storage = new Map();\n    this._timeStamp = Date.now();\n    this._modified = false;\n\n    // Callbacks to signal when the modification state is set or reset.\n    // This is used by the viewer to only bind on `beforeunload` if forms\n    // are actually edited to prevent doing so unconditionally since that\n    // can have undesirable effects.\n    this.onSetModified = null;\n    this.onResetModified = null;\n  }\n\n  /**\n   * Get the value for a given key if it exists, or return the default value.\n   *\n   * @public\n   * @memberof AnnotationStorage\n   * @param {string} key\n   * @param {Object} defaultValue\n   * @returns {Object}\n   */\n  getValue(key, defaultValue) {\n    const value = this._storage.get(key);\n    if (value === undefined) {\n      return defaultValue;\n    }\n\n    return Object.assign(defaultValue, value);\n  }\n\n  /**\n   * Set the value for a given key\n   *\n   * @public\n   * @memberof AnnotationStorage\n   * @param {string} key\n   * @param {Object} value\n   */\n  setValue(key, value) {\n    const obj = this._storage.get(key);\n    let modified = false;\n    if (obj !== undefined) {\n      for (const [entry, val] of Object.entries(value)) {\n        if (obj[entry] !== val) {\n          modified = true;\n          obj[entry] = val;\n        }\n      }\n    } else {\n      modified = true;\n      this._storage.set(key, value);\n    }\n    if (modified) {\n      this._timeStamp = Date.now();\n      this._setModified();\n    }\n  }\n\n  getAll() {\n    return this._storage.size > 0 ? objectFromMap(this._storage) : null;\n  }\n\n  get size() {\n    return this._storage.size;\n  }\n\n  /**\n   * @private\n   */\n  _setModified() {\n    if (!this._modified) {\n      this._modified = true;\n      if (typeof this.onSetModified === \"function\") {\n        this.onSetModified();\n      }\n    }\n  }\n\n  resetModified() {\n    if (this._modified) {\n      this._modified = false;\n      if (typeof this.onResetModified === \"function\") {\n        this.onResetModified();\n      }\n    }\n  }\n\n  /**\n   * PLEASE NOTE: Only intended for usage within the API itself.\n   * @ignore\n   */\n  get serializable() {\n    return this._storage.size > 0 ? this._storage : null;\n  }\n\n  /**\n   * PLEASE NOTE: Only intended for usage within the API itself.\n   * @ignore\n   */\n  get lastModified() {\n    return this._timeStamp.toString();\n  }\n}\n\nexport { AnnotationStorage };\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  FONT_IDENTITY_MATRIX,\n  IDENTITY_MATRIX,\n  ImageKind,\n  info,\n  IsLittleEndianCached,\n  isNum,\n  OPS,\n  shadow,\n  TextRenderingMode,\n  unreachable,\n  Util,\n  warn,\n} from \"../shared/util.js\";\nimport {\n  getShadingPattern,\n  PathType,\n  TilingPattern,\n} from \"./pattern_helper.js\";\nimport { PixelsPerInch } from \"./display_utils.js\";\n\n// <canvas> contexts store most of the state we need natively.\n// However, PDF needs a bit more state, which we store here.\n// Minimal font size that would be used during canvas fillText operations.\nconst MIN_FONT_SIZE = 16;\n// Maximum font size that would be used during canvas fillText operations.\nconst MAX_FONT_SIZE = 100;\nconst MAX_GROUP_SIZE = 4096;\n\n// Defines the time the `executeOperatorList`-method is going to be executing\n// before it stops and shedules a continue of execution.\nconst EXECUTION_TIME = 15; // ms\n// Defines the number of steps before checking the execution time.\nconst EXECUTION_STEPS = 10;\n\nconst COMPILE_TYPE3_GLYPHS = true;\nconst MAX_SIZE_TO_COMPILE = 1000;\n\nconst FULL_CHUNK_HEIGHT = 16;\n\n// Because of https://bugs.chromium.org/p/chromium/issues/detail?id=1170396\n// some curves aren't rendered correctly.\n// Multiplying lineWidth by this factor should help to have \"correct\"\n// rendering with no artifacts.\n// Once the bug is fixed upstream, we can remove this constant and its use.\nconst LINEWIDTH_SCALE_FACTOR = 1.000001;\n\n/**\n * Overrides certain methods on a 2d ctx so that when they are called they\n * will also call the same method on the destCtx. The methods that are\n * overridden are all the transformation state modifiers, path creation, and\n * save/restore. We only forward these specific methods because they are the\n * only state modifiers that we cannot copy over when we switch contexts.\n *\n * To remove mirroring call `ctx._removeMirroring()`.\n *\n * @param {Object} ctx - The 2d canvas context that will duplicate its calls on\n *   the destCtx.\n * @param {Object} destCtx - The 2d canvas context that will receive the\n *   forwarded calls.\n */\nfunction mirrorContextOperations(ctx, destCtx) {\n  if (ctx._removeMirroring) {\n    throw new Error(\"Context is already forwarding operations.\");\n  }\n  ctx.__originalSave = ctx.save;\n  ctx.__originalRestore = ctx.restore;\n  ctx.__originalRotate = ctx.rotate;\n  ctx.__originalScale = ctx.scale;\n  ctx.__originalTranslate = ctx.translate;\n  ctx.__originalTransform = ctx.transform;\n  ctx.__originalSetTransform = ctx.setTransform;\n  ctx.__originalResetTransform = ctx.resetTransform;\n  ctx.__originalClip = ctx.clip;\n  ctx.__originalMoveTo = ctx.moveTo;\n  ctx.__originalLineTo = ctx.lineTo;\n  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n  ctx.__originalRect = ctx.rect;\n  ctx.__originalClosePath = ctx.closePath;\n  ctx.__originalBeginPath = ctx.beginPath;\n\n  ctx._removeMirroring = () => {\n    ctx.save = ctx.__originalSave;\n    ctx.restore = ctx.__originalRestore;\n    ctx.rotate = ctx.__originalRotate;\n    ctx.scale = ctx.__originalScale;\n    ctx.translate = ctx.__originalTranslate;\n    ctx.transform = ctx.__originalTransform;\n    ctx.setTransform = ctx.__originalSetTransform;\n    ctx.resetTransform = ctx.__originalResetTransform;\n\n    ctx.clip = ctx.__originalClip;\n    ctx.moveTo = ctx.__originalMoveTo;\n    ctx.lineTo = ctx.__originalLineTo;\n    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n    ctx.rect = ctx.__originalRect;\n    ctx.closePath = ctx.__originalClosePath;\n    ctx.beginPath = ctx.__originalBeginPath;\n    delete ctx._removeMirroring;\n  };\n\n  ctx.save = function ctxSave() {\n    destCtx.save();\n    this.__originalSave();\n  };\n\n  ctx.restore = function ctxRestore() {\n    destCtx.restore();\n    this.__originalRestore();\n  };\n\n  ctx.translate = function ctxTranslate(x, y) {\n    destCtx.translate(x, y);\n    this.__originalTranslate(x, y);\n  };\n\n  ctx.scale = function ctxScale(x, y) {\n    destCtx.scale(x, y);\n    this.__originalScale(x, y);\n  };\n\n  ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n    destCtx.transform(a, b, c, d, e, f);\n    this.__originalTransform(a, b, c, d, e, f);\n  };\n\n  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n    destCtx.setTransform(a, b, c, d, e, f);\n    this.__originalSetTransform(a, b, c, d, e, f);\n  };\n\n  ctx.resetTransform = function ctxResetTransform() {\n    destCtx.resetTransform();\n    this.__originalResetTransform();\n  };\n\n  ctx.rotate = function ctxRotate(angle) {\n    destCtx.rotate(angle);\n    this.__originalRotate(angle);\n  };\n\n  ctx.clip = function ctxRotate(rule) {\n    destCtx.clip(rule);\n    this.__originalClip(rule);\n  };\n\n  ctx.moveTo = function (x, y) {\n    destCtx.moveTo(x, y);\n    this.__originalMoveTo(x, y);\n  };\n\n  ctx.lineTo = function (x, y) {\n    destCtx.lineTo(x, y);\n    this.__originalLineTo(x, y);\n  };\n\n  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  };\n\n  ctx.rect = function (x, y, width, height) {\n    destCtx.rect(x, y, width, height);\n    this.__originalRect(x, y, width, height);\n  };\n\n  ctx.closePath = function () {\n    destCtx.closePath();\n    this.__originalClosePath();\n  };\n\n  ctx.beginPath = function () {\n    destCtx.beginPath();\n    this.__originalBeginPath();\n  };\n}\n\nfunction addContextCurrentTransform(ctx) {\n  // If the context doesn't expose a `mozCurrentTransform`, add a JS based one.\n  if (ctx.mozCurrentTransform) {\n    return;\n  }\n  ctx._originalSave = ctx.save;\n  ctx._originalRestore = ctx.restore;\n  ctx._originalRotate = ctx.rotate;\n  ctx._originalScale = ctx.scale;\n  ctx._originalTranslate = ctx.translate;\n  ctx._originalTransform = ctx.transform;\n  ctx._originalSetTransform = ctx.setTransform;\n  ctx._originalResetTransform = ctx.resetTransform;\n\n  ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\n  ctx._transformStack = [];\n\n  try {\n    // The call to getOwnPropertyDescriptor throws an exception in Node.js:\n    // \"TypeError: Method lineWidth called on incompatible receiver\n    //  #<CanvasRenderingContext2D>\".\n    const desc = Object.getOwnPropertyDescriptor(\n      Object.getPrototypeOf(ctx),\n      \"lineWidth\"\n    );\n\n    ctx._setLineWidth = desc.set;\n    ctx._getLineWidth = desc.get;\n\n    Object.defineProperty(ctx, \"lineWidth\", {\n      set: function setLineWidth(width) {\n        this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);\n      },\n      get: function getLineWidth() {\n        return this._getLineWidth();\n      },\n    });\n  } catch (_) {}\n\n  Object.defineProperty(ctx, \"mozCurrentTransform\", {\n    get: function getCurrentTransform() {\n      return this._transformMatrix;\n    },\n  });\n\n  Object.defineProperty(ctx, \"mozCurrentTransformInverse\", {\n    get: function getCurrentTransformInverse() {\n      // Calculation done using WolframAlpha:\n      // http://www.wolframalpha.com/input/?\n      //   i=Inverse+{{a%2C+c%2C+e}%2C+{b%2C+d%2C+f}%2C+{0%2C+0%2C+1}}\n\n      const [a, b, c, d, e, f] = this._transformMatrix;\n      const ad_bc = a * d - b * c;\n      const bc_ad = b * c - a * d;\n\n      return [\n        d / ad_bc,\n        b / bc_ad,\n        c / bc_ad,\n        a / ad_bc,\n        (d * e - c * f) / bc_ad,\n        (b * e - a * f) / ad_bc,\n      ];\n    },\n  });\n\n  ctx.save = function ctxSave() {\n    const old = this._transformMatrix;\n    this._transformStack.push(old);\n    this._transformMatrix = old.slice(0, 6);\n\n    this._originalSave();\n  };\n\n  ctx.restore = function ctxRestore() {\n    const prev = this._transformStack.pop();\n    if (prev) {\n      this._transformMatrix = prev;\n      this._originalRestore();\n    }\n  };\n\n  ctx.translate = function ctxTranslate(x, y) {\n    const m = this._transformMatrix;\n    m[4] = m[0] * x + m[2] * y + m[4];\n    m[5] = m[1] * x + m[3] * y + m[5];\n\n    this._originalTranslate(x, y);\n  };\n\n  ctx.scale = function ctxScale(x, y) {\n    const m = this._transformMatrix;\n    m[0] *= x;\n    m[1] *= x;\n    m[2] *= y;\n    m[3] *= y;\n\n    this._originalScale(x, y);\n  };\n\n  ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n    const m = this._transformMatrix;\n    this._transformMatrix = [\n      m[0] * a + m[2] * b,\n      m[1] * a + m[3] * b,\n      m[0] * c + m[2] * d,\n      m[1] * c + m[3] * d,\n      m[0] * e + m[2] * f + m[4],\n      m[1] * e + m[3] * f + m[5],\n    ];\n\n    ctx._originalTransform(a, b, c, d, e, f);\n  };\n\n  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n    this._transformMatrix = [a, b, c, d, e, f];\n\n    ctx._originalSetTransform(a, b, c, d, e, f);\n  };\n\n  ctx.resetTransform = function ctxResetTransform() {\n    this._transformMatrix = [1, 0, 0, 1, 0, 0];\n\n    ctx._originalResetTransform();\n  };\n\n  ctx.rotate = function ctxRotate(angle) {\n    const cosValue = Math.cos(angle);\n    const sinValue = Math.sin(angle);\n\n    const m = this._transformMatrix;\n    this._transformMatrix = [\n      m[0] * cosValue + m[2] * sinValue,\n      m[1] * cosValue + m[3] * sinValue,\n      m[0] * -sinValue + m[2] * cosValue,\n      m[1] * -sinValue + m[3] * cosValue,\n      m[4],\n      m[5],\n    ];\n\n    this._originalRotate(angle);\n  };\n}\n\nclass CachedCanvases {\n  constructor(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n\n  getCanvas(id, width, height, trackTransform) {\n    let canvasEntry;\n    if (this.cache[id] !== undefined) {\n      canvasEntry = this.cache[id];\n      this.canvasFactory.reset(canvasEntry, width, height);\n      // reset canvas transform for emulated mozCurrentTransform, if needed\n      canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\n    } else {\n      canvasEntry = this.canvasFactory.create(width, height);\n      this.cache[id] = canvasEntry;\n    }\n    if (trackTransform) {\n      addContextCurrentTransform(canvasEntry.context);\n    }\n    return canvasEntry;\n  }\n\n  clear() {\n    for (const id in this.cache) {\n      const canvasEntry = this.cache[id];\n      this.canvasFactory.destroy(canvasEntry);\n      delete this.cache[id];\n    }\n  }\n}\n\nfunction compileType3Glyph(imgData) {\n  const POINT_TO_PROCESS_LIMIT = 1000;\n  const POINT_TYPES = new Uint8Array([\n    0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0,\n  ]);\n\n  const width = imgData.width,\n    height = imgData.height,\n    width1 = width + 1;\n  let i, ii, j, j0;\n  const points = new Uint8Array(width1 * (height + 1));\n\n  // decodes bit-packed mask data\n  const lineSize = (width + 7) & ~7,\n    data0 = imgData.data;\n  const data = new Uint8Array(lineSize * height);\n  let pos = 0;\n  for (i = 0, ii = data0.length; i < ii; i++) {\n    const elem = data0[i];\n    let mask = 128;\n    while (mask > 0) {\n      data[pos++] = elem & mask ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n\n  // finding interesting points: every point is located between mask pixels,\n  // so there will be points of the (width + 1)x(height + 1) grid. Every point\n  // will have flags assigned based on neighboring mask pixels:\n  //   4 | 8\n  //   --P--\n  //   2 | 1\n  // We are interested only in points with the flags:\n  //   - outside corners: 1, 2, 4, 8;\n  //   - inside corners: 7, 11, 13, 14;\n  //   - and, intersections: 5, 10.\n  let count = 0;\n  pos = 0;\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n    pos++;\n  }\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n    // 'sum' is the position of the current pixel configuration in the 'TYPES'\n    // array (in order 8-1-2-4, so we can use '>>2' to shift the column).\n    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n    for (j = 1; j < width; j++) {\n      sum =\n        (sum >> 2) +\n        (data[pos + 1] ? 4 : 0) +\n        (data[pos - lineSize + 1] ? 8 : 0);\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n      pos++;\n    }\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n    pos++;\n  }\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n\n  // building outlines\n  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  const outlines = [];\n  for (i = 0; count && i <= height; i++) {\n    let p = i * width1;\n    const end = p + width;\n    while (p < end && !points[p]) {\n      p++;\n    }\n    if (p === end) {\n      continue;\n    }\n    const coords = [p % width1, i];\n\n    const p0 = p;\n    let type = points[p];\n    do {\n      const step = steps[type];\n      do {\n        p += step;\n      } while (!points[p]);\n\n      const pp = points[p];\n      if (pp !== 5 && pp !== 10) {\n        // set new direction\n        type = pp;\n        // delete mark\n        points[p] = 0;\n      } else {\n        // type is 5 or 10, ie, a crossing\n        // set new direction\n        type = pp & ((0x33 * type) >> 4);\n        // set new type for \"future hit\"\n        points[p] &= (type >> 2) | (type << 2);\n      }\n\n      coords.push(p % width1, (p / width1) | 0);\n\n      if (!points[p]) {\n        --count;\n      }\n    } while (p0 !== p);\n    outlines.push(coords);\n    --i;\n  }\n\n  const drawOutline = function (c) {\n    c.save();\n    // the path shall be painted in [0..1]x[0..1] space\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.beginPath();\n    for (let k = 0, kk = outlines.length; k < kk; k++) {\n      const o = outlines[k];\n      c.moveTo(o[0], o[1]);\n      for (let l = 2, ll = o.length; l < ll; l += 2) {\n        c.lineTo(o[l], o[l + 1]);\n      }\n    }\n    c.fill();\n    c.beginPath();\n    c.restore();\n  };\n\n  return drawOutline;\n}\n\nclass CanvasExtraState {\n  constructor(width, height) {\n    // Are soft masks and alpha values shapes or opacities?\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    // Current point (in user coordinates)\n    this.x = 0;\n    this.y = 0;\n    // Start of text line (in text coordinates)\n    this.lineX = 0;\n    this.lineY = 0;\n    // Character and word spacing\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = TextRenderingMode.FILL;\n    this.textRise = 0;\n    // Default fore and background colors\n    this.fillColor = \"#000000\";\n    this.strokeColor = \"#000000\";\n    this.patternFill = false;\n    // Note: fill alpha applies to all non-stroking operations\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null;\n    this.transferMaps = null;\n\n    this.startNewPathAndClipBox([0, 0, width, height]);\n  }\n\n  clone() {\n    const clone = Object.create(this);\n    clone.clipBox = this.clipBox.slice();\n    return clone;\n  }\n\n  setCurrentPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  updatePathMinMax(transform, x, y) {\n    [x, y] = Util.applyTransform([x, y], transform);\n    this.minX = Math.min(this.minX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxX = Math.max(this.maxX, x);\n    this.maxY = Math.max(this.maxY, y);\n  }\n\n  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3) {\n    const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n    this.updatePathMinMax(transform, box[0], box[1]);\n    this.updatePathMinMax(transform, box[2], box[3]);\n  }\n\n  getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n    const box = [this.minX, this.minY, this.maxX, this.maxY];\n    if (pathType === PathType.STROKE) {\n      if (!transform) {\n        unreachable(\"Stroke bounding box must include transform.\");\n      }\n      // Stroked paths can be outside of the path bounding box by 1/2 the line\n      // width.\n      const scale = Util.singularValueDecompose2dScale(transform);\n      const xStrokePad = (scale[0] * this.lineWidth) / 2;\n      const yStrokePad = (scale[1] * this.lineWidth) / 2;\n      box[0] -= xStrokePad;\n      box[1] -= yStrokePad;\n      box[2] += xStrokePad;\n      box[3] += yStrokePad;\n    }\n    return box;\n  }\n\n  updateClipFromPath() {\n    const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n  }\n\n  startNewPathAndClipBox(box) {\n    this.clipBox = box;\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = 0;\n    this.maxY = 0;\n  }\n\n  getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n    return Util.intersect(\n      this.clipBox,\n      this.getPathBoundingBox(pathType, transform)\n    );\n  }\n}\n\nfunction putBinaryImageData(ctx, imgData, transferMaps = null) {\n  if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n    ctx.putImageData(imgData, 0, 0);\n    return;\n  }\n\n  // Put the image data to the canvas in chunks, rather than putting the\n  // whole image at once.  This saves JS memory, because the ImageData object\n  // is smaller. It also possibly saves C++ memory within the implementation\n  // of putImageData(). (E.g. in Firefox we make two short-lived copies of\n  // the data passed to putImageData()). |n| shouldn't be too small, however,\n  // because too many putImageData() calls will slow things down.\n  //\n  // Note: as written, if the last chunk is partial, the putImageData() call\n  // will (conceptually) put pixels past the bounds of the canvas.  But\n  // that's ok; any such pixels are ignored.\n\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0,\n    destPos;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  let i, j, thisChunkHeight, elemsInThisChunk;\n\n  let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;\n  if (transferMaps) {\n    switch (transferMaps.length) {\n      case 1:\n        transferMapRed = transferMaps[0];\n        transferMapGreen = transferMaps[0];\n        transferMapBlue = transferMaps[0];\n        transferMapGray = transferMaps[0];\n        break;\n      case 4:\n        transferMapRed = transferMaps[0];\n        transferMapGreen = transferMaps[1];\n        transferMapBlue = transferMaps[2];\n        transferMapGray = transferMaps[3];\n        break;\n    }\n  }\n\n  // There are multiple forms in which the pixel data can be passed, and\n  // imgData.kind tells us which one this is.\n  if (imgData.kind === ImageKind.GRAYSCALE_1BPP) {\n    // Grayscale, 1 bit per pixel (i.e. black-and-white).\n    const srcLength = src.byteLength;\n    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n    const dest32DataLength = dest32.length;\n    const fullSrcDiff = (width + 7) >> 3;\n    let white = 0xffffffff;\n    let black = IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;\n\n    if (transferMapGray) {\n      if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {\n        [white, black] = [black, white];\n      }\n    }\n\n    for (i = 0; i < totalChunks; i++) {\n      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      destPos = 0;\n      for (j = 0; j < thisChunkHeight; j++) {\n        const srcDiff = srcLength - srcPos;\n        let k = 0;\n        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n        const kEndUnrolled = kEnd & ~7;\n        let mask = 0;\n        let srcByte = 0;\n        for (; k < kEndUnrolled; k += 8) {\n          srcByte = src[srcPos++];\n          dest32[destPos++] = srcByte & 128 ? white : black;\n          dest32[destPos++] = srcByte & 64 ? white : black;\n          dest32[destPos++] = srcByte & 32 ? white : black;\n          dest32[destPos++] = srcByte & 16 ? white : black;\n          dest32[destPos++] = srcByte & 8 ? white : black;\n          dest32[destPos++] = srcByte & 4 ? white : black;\n          dest32[destPos++] = srcByte & 2 ? white : black;\n          dest32[destPos++] = srcByte & 1 ? white : black;\n        }\n        for (; k < kEnd; k++) {\n          if (mask === 0) {\n            srcByte = src[srcPos++];\n            mask = 128;\n          }\n\n          dest32[destPos++] = srcByte & mask ? white : black;\n          mask >>= 1;\n        }\n      }\n      // We ran out of input. Make all remaining pixels transparent.\n      while (destPos < dest32DataLength) {\n        dest32[destPos++] = 0;\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else if (imgData.kind === ImageKind.RGBA_32BPP) {\n    // RGBA, 32-bits per pixel.\n    const hasTransferMaps = !!(\n      transferMapRed ||\n      transferMapGreen ||\n      transferMapBlue\n    );\n\n    j = 0;\n    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n    for (i = 0; i < fullChunks; i++) {\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      srcPos += elemsInThisChunk;\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < elemsInThisChunk; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, j);\n      j += FULL_CHUNK_HEIGHT;\n    }\n    if (i < totalChunks) {\n      elemsInThisChunk = width * partialChunkHeight * 4;\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < elemsInThisChunk; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, j);\n    }\n  } else if (imgData.kind === ImageKind.RGB_24BPP) {\n    // RGB, 24-bits per pixel.\n    const hasTransferMaps = !!(\n      transferMapRed ||\n      transferMapGreen ||\n      transferMapBlue\n    );\n\n    thisChunkHeight = FULL_CHUNK_HEIGHT;\n    elemsInThisChunk = width * thisChunkHeight;\n    for (i = 0; i < totalChunks; i++) {\n      if (i >= fullChunks) {\n        thisChunkHeight = partialChunkHeight;\n        elemsInThisChunk = width * thisChunkHeight;\n      }\n\n      destPos = 0;\n      for (j = elemsInThisChunk; j--; ) {\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = 255;\n      }\n\n      if (hasTransferMaps) {\n        for (let k = 0; k < destPos; k += 4) {\n          if (transferMapRed) {\n            dest[k + 0] = transferMapRed[dest[k + 0]];\n          }\n          if (transferMapGreen) {\n            dest[k + 1] = transferMapGreen[dest[k + 1]];\n          }\n          if (transferMapBlue) {\n            dest[k + 2] = transferMapBlue[dest[k + 2]];\n          }\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else {\n    throw new Error(`bad image kind: ${imgData.kind}`);\n  }\n}\n\nfunction putBinaryImageMask(ctx, imgData) {\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n\n  for (let i = 0; i < totalChunks; i++) {\n    const thisChunkHeight =\n      i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n\n    // Expand the mask so it can be used by the canvas.  Any required\n    // inversion has already been handled.\n    let destPos = 3; // alpha component offset\n    for (let j = 0; j < thisChunkHeight; j++) {\n      let elem,\n        mask = 0;\n      for (let k = 0; k < width; k++) {\n        if (!mask) {\n          elem = src[srcPos++];\n          mask = 128;\n        }\n        dest[destPos] = elem & mask ? 0 : 255;\n        destPos += 4;\n        mask >>= 1;\n      }\n    }\n    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n  }\n}\n\nfunction copyCtxState(sourceCtx, destCtx) {\n  const properties = [\n    \"strokeStyle\",\n    \"fillStyle\",\n    \"fillRule\",\n    \"globalAlpha\",\n    \"lineWidth\",\n    \"lineCap\",\n    \"lineJoin\",\n    \"miterLimit\",\n    \"globalCompositeOperation\",\n    \"font\",\n  ];\n  for (let i = 0, ii = properties.length; i < ii; i++) {\n    const property = properties[i];\n    if (sourceCtx[property] !== undefined) {\n      destCtx[property] = sourceCtx[property];\n    }\n  }\n  if (sourceCtx.setLineDash !== undefined) {\n    destCtx.setLineDash(sourceCtx.getLineDash());\n    destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n  }\n}\n\nfunction resetCtxToDefault(ctx) {\n  ctx.strokeStyle = \"#000000\";\n  ctx.fillStyle = \"#000000\";\n  ctx.fillRule = \"nonzero\";\n  ctx.globalAlpha = 1;\n  ctx.lineWidth = 1;\n  ctx.lineCap = \"butt\";\n  ctx.lineJoin = \"miter\";\n  ctx.miterLimit = 10;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.font = \"10px sans-serif\";\n  if (ctx.setLineDash !== undefined) {\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = 0;\n  }\n}\n\nfunction composeSMaskBackdrop(bytes, r0, g0, b0) {\n  const length = bytes.length;\n  for (let i = 3; i < length; i += 4) {\n    const alpha = bytes[i];\n    if (alpha === 0) {\n      bytes[i - 3] = r0;\n      bytes[i - 2] = g0;\n      bytes[i - 1] = b0;\n    } else if (alpha < 255) {\n      const alpha_ = 255 - alpha;\n      bytes[i - 3] = (bytes[i - 3] * alpha + r0 * alpha_) >> 8;\n      bytes[i - 2] = (bytes[i - 2] * alpha + g0 * alpha_) >> 8;\n      bytes[i - 1] = (bytes[i - 1] * alpha + b0 * alpha_) >> 8;\n    }\n  }\n}\n\nfunction composeSMaskAlpha(maskData, layerData, transferMap) {\n  const length = maskData.length;\n  const scale = 1 / 255;\n  for (let i = 3; i < length; i += 4) {\n    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n    layerData[i] = (layerData[i] * alpha * scale) | 0;\n  }\n}\n\nfunction composeSMaskLuminosity(maskData, layerData, transferMap) {\n  const length = maskData.length;\n  for (let i = 3; i < length; i += 4) {\n    const y =\n      maskData[i - 3] * 77 + // * 0.3 / 255 * 0x10000\n      maskData[i - 2] * 152 + // * 0.59 ....\n      maskData[i - 1] * 28; // * 0.11 ....\n    layerData[i] = transferMap\n      ? (layerData[i] * transferMap[y >> 8]) >> 8\n      : (layerData[i] * y) >> 16;\n  }\n}\n\nfunction genericComposeSMask(\n  maskCtx,\n  layerCtx,\n  width,\n  height,\n  subtype,\n  backdrop,\n  transferMap,\n  layerOffsetX,\n  layerOffsetY,\n  maskOffsetX,\n  maskOffsetY\n) {\n  const hasBackdrop = !!backdrop;\n  const r0 = hasBackdrop ? backdrop[0] : 0;\n  const g0 = hasBackdrop ? backdrop[1] : 0;\n  const b0 = hasBackdrop ? backdrop[2] : 0;\n\n  let composeFn;\n  if (subtype === \"Luminosity\") {\n    composeFn = composeSMaskLuminosity;\n  } else {\n    composeFn = composeSMaskAlpha;\n  }\n\n  // processing image in chunks to save memory\n  const PIXELS_TO_PROCESS = 1048576;\n  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n  for (let row = 0; row < height; row += chunkSize) {\n    const chunkHeight = Math.min(chunkSize, height - row);\n    const maskData = maskCtx.getImageData(\n      layerOffsetX - maskOffsetX,\n      row + (layerOffsetY - maskOffsetY),\n      width,\n      chunkHeight\n    );\n    const layerData = layerCtx.getImageData(\n      layerOffsetX,\n      row + layerOffsetY,\n      width,\n      chunkHeight\n    );\n\n    if (hasBackdrop) {\n      composeSMaskBackdrop(maskData.data, r0, g0, b0);\n    }\n    composeFn(maskData.data, layerData.data, transferMap);\n\n    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n  }\n}\n\nfunction composeSMask(ctx, smask, layerCtx, layerBox) {\n  const layerOffsetX = layerBox[0];\n  const layerOffsetY = layerBox[1];\n  const layerWidth = layerBox[2] - layerOffsetX;\n  const layerHeight = layerBox[3] - layerOffsetY;\n  if (layerWidth === 0 || layerHeight === 0) {\n    return;\n  }\n  genericComposeSMask(\n    smask.context,\n    layerCtx,\n    layerWidth,\n    layerHeight,\n    smask.subtype,\n    smask.backdrop,\n    smask.transferMap,\n    layerOffsetX,\n    layerOffsetY,\n    smask.offsetX,\n    smask.offsetY\n  );\n  ctx.save();\n  ctx.globalAlpha = 1;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.drawImage(layerCtx.canvas, 0, 0);\n  ctx.restore();\n}\n\nfunction getImageSmoothingEnabled(transform, interpolate) {\n  const scale = Util.singularValueDecompose2dScale(transform);\n  // Round to a 32bit float so that `<=` check below will pass for numbers that\n  // are very close, but not exactly the same 64bit floats.\n  scale[0] = Math.fround(scale[0]);\n  scale[1] = Math.fround(scale[1]);\n  const actualScale = Math.fround(\n    (globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS\n  );\n  if (interpolate !== undefined) {\n    // If the value is explicitly set use it.\n    return interpolate;\n  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n    // Smooth when downscaling.\n    return true;\n  }\n  // Don't smooth when upscaling.\n  return false;\n}\n\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\n\nclass CanvasGraphics {\n  constructor(\n    canvasCtx,\n    commonObjs,\n    objs,\n    canvasFactory,\n    imageLayer,\n    optionalContentConfig,\n    annotationCanvasMap\n  ) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState(\n      this.ctx.canvas.width,\n      this.ctx.canvas.height\n    );\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.imageLayer = imageLayer;\n    this.groupStack = [];\n    this.processingType3 = null;\n    // Patterns are painted relative to the initial page/form transform, see\n    // PDF spec 8.7.2 NOTE 1.\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.suspendedCtx = null;\n    this.contentVisible = true;\n    this.markedContentStack = [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n    this.cachedPatterns = new Map();\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.viewportScale = 1;\n    this.outputScaleX = 1;\n    this.outputScaleY = 1;\n    if (canvasCtx) {\n      // NOTE: if mozCurrentTransform is polyfilled, then the current state of\n      // the transformation must already be set in canvasCtx._transformMatrix.\n      addContextCurrentTransform(canvasCtx);\n    }\n    this._cachedGetSinglePixelWidth = null;\n  }\n\n  beginDrawing({\n    transform,\n    viewport,\n    transparency = false,\n    background = null,\n  }) {\n    // For pdfs that use blend modes we have to clear the canvas else certain\n    // blend modes can look wrong since we'd be blending with a white\n    // backdrop. The problem with a transparent backdrop though is we then\n    // don't get sub pixel anti aliasing on text, creating temporary\n    // transparent canvas when we have blend modes.\n    const width = this.ctx.canvas.width;\n    const height = this.ctx.canvas.height;\n\n    this.ctx.save();\n    this.ctx.fillStyle = background || \"rgb(255, 255, 255)\";\n    this.ctx.fillRect(0, 0, width, height);\n    this.ctx.restore();\n\n    if (transparency) {\n      const transparentCanvas = this.cachedCanvases.getCanvas(\n        \"transparent\",\n        width,\n        height,\n        true\n      );\n      this.compositeCtx = this.ctx;\n      this.transparentCanvas = transparentCanvas.canvas;\n      this.ctx = transparentCanvas.context;\n      this.ctx.save();\n      // The transform can be applied before rendering, transferring it to\n      // the new canvas.\n      this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);\n    }\n\n    this.ctx.save();\n    resetCtxToDefault(this.ctx);\n    if (transform) {\n      this.ctx.transform.apply(this.ctx, transform);\n      this.outputScaleX = transform[0];\n      this.outputScaleY = transform[0];\n    }\n    this.ctx.transform.apply(this.ctx, viewport.transform);\n    this.viewportScale = viewport.scale;\n\n    this.baseTransform = this.ctx.mozCurrentTransform.slice();\n    this._combinedScaleFactor = Math.hypot(\n      this.baseTransform[0],\n      this.baseTransform[2]\n    );\n\n    if (this.imageLayer) {\n      this.imageLayer.beginLayout();\n    }\n  }\n\n  executeOperatorList(\n    operatorList,\n    executionStartIdx,\n    continueCallback,\n    stepper\n  ) {\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    let i = executionStartIdx || 0;\n    const argsArrayLen = argsArray.length;\n\n    // Sometimes the OperatorList to execute is empty.\n    if (argsArrayLen === i) {\n      return i;\n    }\n\n    const chunkOperations =\n      argsArrayLen - i > EXECUTION_STEPS &&\n      typeof continueCallback === \"function\";\n    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n    let steps = 0;\n\n    const commonObjs = this.commonObjs;\n    const objs = this.objs;\n    let fnId;\n\n    while (true) {\n      if (stepper !== undefined && i === stepper.nextBreakPoint) {\n        stepper.breakIt(i, continueCallback);\n        return i;\n      }\n\n      fnId = fnArray[i];\n\n      if (fnId !== OPS.dependency) {\n        this[fnId].apply(this, argsArray[i]);\n      } else {\n        for (const depObjId of argsArray[i]) {\n          const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n\n          // If the promise isn't resolved yet, add the continueCallback\n          // to the promise and bail out.\n          if (!objsPool.has(depObjId)) {\n            objsPool.get(depObjId, continueCallback);\n            return i;\n          }\n        }\n      }\n\n      i++;\n\n      // If the entire operatorList was executed, stop as were done.\n      if (i === argsArrayLen) {\n        return i;\n      }\n\n      // If the execution took longer then a certain amount of time and\n      // `continueCallback` is specified, interrupt the execution.\n      if (chunkOperations && ++steps > EXECUTION_STEPS) {\n        if (Date.now() > endTime) {\n          continueCallback();\n          return i;\n        }\n        steps = 0;\n      }\n\n      // If the operatorList isn't executed completely yet OR the execution\n      // time was short enough, do another execution round.\n    }\n  }\n\n  endDrawing() {\n    // Finishing all opened operations such as SMask group painting.\n    while (this.stateStack.length || this.current.activeSMask !== null) {\n      this.restore();\n    }\n\n    this.ctx.restore();\n\n    if (this.transparentCanvas) {\n      this.ctx = this.compositeCtx;\n      this.ctx.save();\n      this.ctx.setTransform(1, 0, 0, 1, 0, 0); // Avoid apply transform twice\n      this.ctx.drawImage(this.transparentCanvas, 0, 0);\n      this.ctx.restore();\n      this.transparentCanvas = null;\n    }\n\n    this.cachedCanvases.clear();\n    this.cachedPatterns.clear();\n\n    if (this.imageLayer) {\n      this.imageLayer.endLayout();\n    }\n  }\n\n  _scaleImage(img, inverseTransform) {\n    // Vertical or horizontal scaling shall not be more than 2 to not lose the\n    // pixels during drawImage operation, painting on the temporary canvas(es)\n    // that are twice smaller in size.\n    const width = img.width;\n    const height = img.height;\n    let widthScale = Math.max(\n      Math.hypot(inverseTransform[0], inverseTransform[1]),\n      1\n    );\n    let heightScale = Math.max(\n      Math.hypot(inverseTransform[2], inverseTransform[3]),\n      1\n    );\n\n    let paintWidth = width,\n      paintHeight = height;\n    let tmpCanvasId = \"prescale1\";\n    let tmpCanvas, tmpCtx;\n    while (\n      (widthScale > 2 && paintWidth > 1) ||\n      (heightScale > 2 && paintHeight > 1)\n    ) {\n      let newWidth = paintWidth,\n        newHeight = paintHeight;\n      if (widthScale > 2 && paintWidth > 1) {\n        newWidth = Math.ceil(paintWidth / 2);\n        widthScale /= paintWidth / newWidth;\n      }\n      if (heightScale > 2 && paintHeight > 1) {\n        newHeight = Math.ceil(paintHeight / 2);\n        heightScale /= paintHeight / newHeight;\n      }\n      tmpCanvas = this.cachedCanvases.getCanvas(\n        tmpCanvasId,\n        newWidth,\n        newHeight\n      );\n      tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, newWidth, newHeight);\n      tmpCtx.drawImage(\n        img,\n        0,\n        0,\n        paintWidth,\n        paintHeight,\n        0,\n        0,\n        newWidth,\n        newHeight\n      );\n      img = tmpCanvas.canvas;\n      paintWidth = newWidth;\n      paintHeight = newHeight;\n      tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n    }\n    return {\n      img,\n      paintWidth,\n      paintHeight,\n    };\n  }\n\n  _createMaskCanvas(img) {\n    const ctx = this.ctx;\n    const width = img.width,\n      height = img.height;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    const maskCanvas = this.cachedCanvases.getCanvas(\n      \"maskCanvas\",\n      width,\n      height\n    );\n    const maskCtx = maskCanvas.context;\n    putBinaryImageMask(maskCtx, img);\n\n    // Create the mask canvas at the size it will be drawn at and also set\n    // its transform to match the current transform so if there are any\n    // patterns applied they will be applied relative to the correct\n    // transform.\n    const objToCanvas = ctx.mozCurrentTransform;\n    let maskToCanvas = Util.transform(objToCanvas, [\n      1 / width,\n      0,\n      0,\n      -1 / height,\n      0,\n      0,\n    ]);\n    maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n    const cord1 = Util.applyTransform([0, 0], maskToCanvas);\n    const cord2 = Util.applyTransform([width, height], maskToCanvas);\n    const rect = Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);\n    const drawnWidth = Math.ceil(rect[2] - rect[0]);\n    const drawnHeight = Math.ceil(rect[3] - rect[1]);\n    const fillCanvas = this.cachedCanvases.getCanvas(\n      \"fillCanvas\",\n      drawnWidth,\n      drawnHeight,\n      true\n    );\n    const fillCtx = fillCanvas.context;\n    // The offset will be the top-left cordinate mask.\n    const offsetX = Math.min(cord1[0], cord2[0]);\n    const offsetY = Math.min(cord1[1], cord2[1]);\n    fillCtx.translate(-offsetX, -offsetY);\n    fillCtx.transform.apply(fillCtx, maskToCanvas);\n    // Pre-scale if needed to improve image smoothing.\n    const scaled = this._scaleImage(\n      maskCanvas.canvas,\n      fillCtx.mozCurrentTransformInverse\n    );\n    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(\n      fillCtx.mozCurrentTransform,\n      img.interpolate\n    );\n    fillCtx.drawImage(\n      scaled.img,\n      0,\n      0,\n      scaled.img.width,\n      scaled.img.height,\n      0,\n      0,\n      width,\n      height\n    );\n    fillCtx.globalCompositeOperation = \"source-in\";\n\n    const inverse = Util.transform(fillCtx.mozCurrentTransformInverse, [\n      1,\n      0,\n      0,\n      1,\n      -offsetX,\n      -offsetY,\n    ]);\n    fillCtx.fillStyle = isPatternFill\n      ? fillColor.getPattern(ctx, this, inverse, PathType.FILL)\n      : fillColor;\n\n    fillCtx.fillRect(0, 0, width, height);\n\n    // Round the offsets to avoid drawing fractional pixels.\n    return {\n      canvas: fillCanvas.canvas,\n      offsetX: Math.round(offsetX),\n      offsetY: Math.round(offsetY),\n    };\n  }\n\n  // Graphics state\n  setLineWidth(width) {\n    this.current.lineWidth = width;\n    this.ctx.lineWidth = width;\n  }\n\n  setLineCap(style) {\n    this.ctx.lineCap = LINE_CAP_STYLES[style];\n  }\n\n  setLineJoin(style) {\n    this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n  }\n\n  setMiterLimit(limit) {\n    this.ctx.miterLimit = limit;\n  }\n\n  setDash(dashArray, dashPhase) {\n    const ctx = this.ctx;\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash(dashArray);\n      ctx.lineDashOffset = dashPhase;\n    }\n  }\n\n  setRenderingIntent(intent) {\n    // This operation is ignored since we haven't found a use case for it yet.\n  }\n\n  setFlatness(flatness) {\n    // This operation is ignored since we haven't found a use case for it yet.\n  }\n\n  setGState(states) {\n    for (let i = 0, ii = states.length; i < ii; i++) {\n      const state = states[i];\n      const key = state[0];\n      const value = state[1];\n\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(value);\n          break;\n        case \"LC\":\n          this.setLineCap(value);\n          break;\n        case \"LJ\":\n          this.setLineJoin(value);\n          break;\n        case \"ML\":\n          this.setMiterLimit(value);\n          break;\n        case \"D\":\n          this.setDash(value[0], value[1]);\n          break;\n        case \"RI\":\n          this.setRenderingIntent(value);\n          break;\n        case \"FL\":\n          this.setFlatness(value);\n          break;\n        case \"Font\":\n          this.setFont(value[0], value[1]);\n          break;\n        case \"CA\":\n          this.current.strokeAlpha = state[1];\n          break;\n        case \"ca\":\n          this.current.fillAlpha = state[1];\n          this.ctx.globalAlpha = state[1];\n          break;\n        case \"BM\":\n          this.ctx.globalCompositeOperation = value;\n          break;\n        case \"SMask\":\n          this.current.activeSMask = value ? this.tempSMask : null;\n          this.tempSMask = null;\n          this.checkSMaskState();\n          break;\n        case \"TR\":\n          this.current.transferMaps = value;\n      }\n    }\n  }\n\n  checkSMaskState() {\n    const inSMaskMode = !!this.suspendedCtx;\n    if (this.current.activeSMask && !inSMaskMode) {\n      this.beginSMaskMode();\n    } else if (!this.current.activeSMask && inSMaskMode) {\n      this.endSMaskMode();\n    }\n    // Else, the state is okay and nothing needs to be done.\n  }\n\n  /**\n   * Soft mask mode takes the current main drawing canvas and replaces it with\n   * a temporary canvas. Any drawing operations that happen on the temporary\n   * canvas need to be composed with the main canvas that was suspended (see\n   * `compose()`). The temporary canvas also duplicates many of its operations\n   * on the suspended canvas to keep them in sync, so that when the soft mask\n   * mode ends any clipping paths or transformations will still be active and in\n   * the right order on the canvas' graphics state stack.\n   */\n  beginSMaskMode() {\n    if (this.suspendedCtx) {\n      throw new Error(\"beginSMaskMode called while already in smask mode\");\n    }\n    const drawnWidth = this.ctx.canvas.width;\n    const drawnHeight = this.ctx.canvas.height;\n    const cacheId = \"smaskGroupAt\" + this.groupLevel;\n    const scratchCanvas = this.cachedCanvases.getCanvas(\n      cacheId,\n      drawnWidth,\n      drawnHeight,\n      true\n    );\n    this.suspendedCtx = this.ctx;\n    this.ctx = scratchCanvas.context;\n    const ctx = this.ctx;\n    ctx.setTransform.apply(ctx, this.suspendedCtx.mozCurrentTransform);\n    copyCtxState(this.suspendedCtx, ctx);\n    mirrorContextOperations(ctx, this.suspendedCtx);\n\n    this.setGState([\n      [\"BM\", \"source-over\"],\n      [\"ca\", 1],\n      [\"CA\", 1],\n    ]);\n  }\n\n  endSMaskMode() {\n    if (!this.suspendedCtx) {\n      throw new Error(\"endSMaskMode called while not in smask mode\");\n    }\n    // The soft mask is done, now restore the suspended canvas as the main\n    // drawing canvas.\n    this.ctx._removeMirroring();\n    copyCtxState(this.ctx, this.suspendedCtx);\n    this.ctx = this.suspendedCtx;\n\n    this.current.activeSMask = null;\n    this.suspendedCtx = null;\n  }\n\n  compose(dirtyBox) {\n    if (!this.current.activeSMask) {\n      return;\n    }\n\n    if (!dirtyBox) {\n      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n    } else {\n      dirtyBox[0] = Math.floor(dirtyBox[0]);\n      dirtyBox[1] = Math.floor(dirtyBox[1]);\n      dirtyBox[2] = Math.ceil(dirtyBox[2]);\n      dirtyBox[3] = Math.ceil(dirtyBox[3]);\n    }\n    const smask = this.current.activeSMask;\n    const suspendedCtx = this.suspendedCtx;\n\n    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n    // Whatever was drawn has been moved to the suspended canvas, now clear it\n    // out of the current canvas.\n    this.ctx.save();\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.restore();\n  }\n\n  save() {\n    this.ctx.save();\n    const old = this.current;\n    this.stateStack.push(old);\n    this.current = old.clone();\n  }\n\n  restore() {\n    if (this.stateStack.length === 0 && this.current.activeSMask) {\n      this.endSMaskMode();\n    }\n\n    if (this.stateStack.length !== 0) {\n      this.current = this.stateStack.pop();\n      this.ctx.restore();\n      this.checkSMaskState();\n\n      // Ensure that the clipping path is reset (fixes issue6413.pdf).\n      this.pendingClip = null;\n\n      this._cachedGetSinglePixelWidth = null;\n    }\n  }\n\n  transform(a, b, c, d, e, f) {\n    this.ctx.transform(a, b, c, d, e, f);\n\n    this._cachedGetSinglePixelWidth = null;\n  }\n\n  // Path\n  constructPath(ops, args) {\n    const ctx = this.ctx;\n    const current = this.current;\n    let x = current.x,\n      y = current.y;\n    let startX, startY;\n    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {\n      switch (ops[i] | 0) {\n        case OPS.rectangle:\n          x = args[j++];\n          y = args[j++];\n          const width = args[j++];\n          const height = args[j++];\n\n          const xw = x + width;\n          const yh = y + height;\n          ctx.moveTo(x, y);\n          if (width === 0 || height === 0) {\n            ctx.lineTo(xw, yh);\n          } else {\n            ctx.lineTo(xw, y);\n            ctx.lineTo(xw, yh);\n            ctx.lineTo(x, yh);\n          }\n          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n          current.updatePathMinMax(ctx.mozCurrentTransform, xw, yh);\n          ctx.closePath();\n          break;\n        case OPS.moveTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.moveTo(x, y);\n          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n          break;\n        case OPS.lineTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.lineTo(x, y);\n          current.updatePathMinMax(ctx.mozCurrentTransform, x, y);\n          break;\n        case OPS.curveTo:\n          startX = x;\n          startY = y;\n          x = args[j + 4];\n          y = args[j + 5];\n          ctx.bezierCurveTo(\n            args[j],\n            args[j + 1],\n            args[j + 2],\n            args[j + 3],\n            x,\n            y\n          );\n          current.updateCurvePathMinMax(\n            ctx.mozCurrentTransform,\n            startX,\n            startY,\n            args[j],\n            args[j + 1],\n            args[j + 2],\n            args[j + 3],\n            x,\n            y\n          );\n          j += 6;\n          break;\n        case OPS.curveTo2:\n          startX = x;\n          startY = y;\n          ctx.bezierCurveTo(\n            x,\n            y,\n            args[j],\n            args[j + 1],\n            args[j + 2],\n            args[j + 3]\n          );\n          current.updateCurvePathMinMax(\n            ctx.mozCurrentTransform,\n            startX,\n            startY,\n            x,\n            y,\n            args[j],\n            args[j + 1],\n            args[j + 2],\n            args[j + 3]\n          );\n          x = args[j + 2];\n          y = args[j + 3];\n          j += 4;\n          break;\n        case OPS.curveTo3:\n          startX = x;\n          startY = y;\n          x = args[j + 2];\n          y = args[j + 3];\n          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n          current.updateCurvePathMinMax(\n            ctx.mozCurrentTransform,\n            startX,\n            startY,\n            args[j],\n            args[j + 1],\n            x,\n            y,\n            x,\n            y\n          );\n          j += 4;\n          break;\n        case OPS.closePath:\n          ctx.closePath();\n          break;\n      }\n    }\n    current.setCurrentPoint(x, y);\n  }\n\n  closePath() {\n    this.ctx.closePath();\n  }\n\n  stroke(consumePath) {\n    consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n    const ctx = this.ctx;\n    const strokeColor = this.current.strokeColor;\n    // For stroke we want to temporarily change the global alpha to the\n    // stroking alpha.\n    ctx.globalAlpha = this.current.strokeAlpha;\n    if (this.contentVisible) {\n      if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n        const lineWidth = this.getSinglePixelWidth();\n        ctx.save();\n        ctx.strokeStyle = strokeColor.getPattern(\n          ctx,\n          this,\n          ctx.mozCurrentTransformInverse,\n          PathType.STROKE\n        );\n        // Prevent drawing too thin lines by enforcing a minimum line width.\n        ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);\n        ctx.stroke();\n        ctx.restore();\n      } else {\n        const lineWidth = this.getSinglePixelWidth();\n        if (lineWidth < 0 && -lineWidth >= this.current.lineWidth) {\n          // The current transform will transform a square pixel into a\n          // parallelogram where both heights are lower than 1 and not equal.\n          ctx.save();\n          ctx.resetTransform();\n          ctx.lineWidth = Math.round(this._combinedScaleFactor);\n          ctx.stroke();\n          ctx.restore();\n        } else {\n          // Prevent drawing too thin lines by enforcing a minimum line width.\n          ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);\n          ctx.stroke();\n        }\n      }\n    }\n    if (consumePath) {\n      this.consumePath(this.current.getClippedPathBoundingBox());\n    }\n    // Restore the global alpha to the fill alpha\n    ctx.globalAlpha = this.current.fillAlpha;\n  }\n\n  closeStroke() {\n    this.closePath();\n    this.stroke();\n  }\n\n  fill(consumePath) {\n    consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    let needRestore = false;\n\n    if (isPatternFill) {\n      ctx.save();\n      ctx.fillStyle = fillColor.getPattern(\n        ctx,\n        this,\n        ctx.mozCurrentTransformInverse,\n        PathType.FILL\n      );\n      needRestore = true;\n    }\n\n    const intersect = this.current.getClippedPathBoundingBox();\n    if (this.contentVisible && intersect !== null) {\n      if (this.pendingEOFill) {\n        ctx.fill(\"evenodd\");\n        this.pendingEOFill = false;\n      } else {\n        ctx.fill();\n      }\n    }\n\n    if (needRestore) {\n      ctx.restore();\n    }\n    if (consumePath) {\n      this.consumePath(intersect);\n    }\n  }\n\n  eoFill() {\n    this.pendingEOFill = true;\n    this.fill();\n  }\n\n  fillStroke() {\n    this.fill(false);\n    this.stroke(false);\n\n    this.consumePath();\n  }\n\n  eoFillStroke() {\n    this.pendingEOFill = true;\n    this.fillStroke();\n  }\n\n  closeFillStroke() {\n    this.closePath();\n    this.fillStroke();\n  }\n\n  closeEOFillStroke() {\n    this.pendingEOFill = true;\n    this.closePath();\n    this.fillStroke();\n  }\n\n  endPath() {\n    this.consumePath();\n  }\n\n  // Clipping\n  clip() {\n    this.pendingClip = NORMAL_CLIP;\n  }\n\n  eoClip() {\n    this.pendingClip = EO_CLIP;\n  }\n\n  // Text\n  beginText() {\n    this.current.textMatrix = IDENTITY_MATRIX;\n    this.current.textMatrixScale = 1;\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n\n  endText() {\n    const paths = this.pendingTextPaths;\n    const ctx = this.ctx;\n    if (paths === undefined) {\n      ctx.beginPath();\n      return;\n    }\n\n    ctx.save();\n    ctx.beginPath();\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      ctx.setTransform.apply(ctx, path.transform);\n      ctx.translate(path.x, path.y);\n      path.addToPath(ctx, path.fontSize);\n    }\n    ctx.restore();\n    ctx.clip();\n    ctx.beginPath();\n    delete this.pendingTextPaths;\n  }\n\n  setCharSpacing(spacing) {\n    this.current.charSpacing = spacing;\n  }\n\n  setWordSpacing(spacing) {\n    this.current.wordSpacing = spacing;\n  }\n\n  setHScale(scale) {\n    this.current.textHScale = scale / 100;\n  }\n\n  setLeading(leading) {\n    this.current.leading = -leading;\n  }\n\n  setFont(fontRefName, size) {\n    const fontObj = this.commonObjs.get(fontRefName);\n    const current = this.current;\n\n    if (!fontObj) {\n      throw new Error(`Can't find font for ${fontRefName}`);\n    }\n    current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n\n    // A valid matrix needs all main diagonal elements to be non-zero\n    // This also ensures we bypass FF bugzilla bug #719844.\n    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n      warn(\"Invalid font matrix for font \" + fontRefName);\n    }\n\n    // The spec for Tf (setFont) says that 'size' specifies the font 'scale',\n    // and in some docs this can be negative (inverted x-y axes).\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n\n    this.current.font = fontObj;\n    this.current.fontSize = size;\n\n    if (fontObj.isType3Font) {\n      return; // we don't need ctx.font for Type3 fonts\n    }\n\n    const name = fontObj.loadedName || \"sans-serif\";\n\n    let bold = \"normal\";\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    const typeface = `\"${name}\", ${fontObj.fallbackName}`;\n\n    // Some font backends cannot handle fonts below certain size.\n    // Keeping the font at minimal size and using the fontSizeScale to change\n    // the current transformation matrix before the fillText/strokeText.\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=726227\n    let browserFontSize = size;\n    if (size < MIN_FONT_SIZE) {\n      browserFontSize = MIN_FONT_SIZE;\n    } else if (size > MAX_FONT_SIZE) {\n      browserFontSize = MAX_FONT_SIZE;\n    }\n    this.current.fontSizeScale = size / browserFontSize;\n\n    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n  }\n\n  setTextRenderingMode(mode) {\n    this.current.textRenderingMode = mode;\n  }\n\n  setTextRise(rise) {\n    this.current.textRise = rise;\n  }\n\n  moveText(x, y) {\n    this.current.x = this.current.lineX += x;\n    this.current.y = this.current.lineY += y;\n  }\n\n  setLeadingMoveText(x, y) {\n    this.setLeading(-y);\n    this.moveText(x, y);\n  }\n\n  setTextMatrix(a, b, c, d, e, f) {\n    this.current.textMatrix = [a, b, c, d, e, f];\n    this.current.textMatrixScale = Math.hypot(a, b);\n\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n\n  nextLine() {\n    this.moveText(0, this.current.leading);\n  }\n\n  paintChar(character, x, y, patternTransform, resetLineWidthToOne) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const textRenderingMode = current.textRenderingMode;\n    const fontSize = current.fontSize / current.fontSizeScale;\n    const fillStrokeMode =\n      textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n    const isAddToPathSet = !!(\n      textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG\n    );\n    const patternFill = current.patternFill && !font.missingFile;\n\n    let addToPath;\n    if (font.disableFontFace || isAddToPathSet || patternFill) {\n      addToPath = font.getPathGenerator(this.commonObjs, character);\n    }\n\n    if (font.disableFontFace || patternFill) {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.beginPath();\n      addToPath(ctx, fontSize);\n      if (patternTransform) {\n        ctx.setTransform.apply(ctx, patternTransform);\n      }\n      if (\n        fillStrokeMode === TextRenderingMode.FILL ||\n        fillStrokeMode === TextRenderingMode.FILL_STROKE\n      ) {\n        ctx.fill();\n      }\n      if (\n        fillStrokeMode === TextRenderingMode.STROKE ||\n        fillStrokeMode === TextRenderingMode.FILL_STROKE\n      ) {\n        if (resetLineWidthToOne) {\n          ctx.resetTransform();\n          ctx.lineWidth = Math.round(this._combinedScaleFactor);\n        }\n        ctx.stroke();\n      }\n      ctx.restore();\n    } else {\n      if (\n        fillStrokeMode === TextRenderingMode.FILL ||\n        fillStrokeMode === TextRenderingMode.FILL_STROKE\n      ) {\n        ctx.fillText(character, x, y);\n      }\n      if (\n        fillStrokeMode === TextRenderingMode.STROKE ||\n        fillStrokeMode === TextRenderingMode.FILL_STROKE\n      ) {\n        if (resetLineWidthToOne) {\n          ctx.save();\n          ctx.moveTo(x, y);\n          ctx.resetTransform();\n          ctx.lineWidth = Math.round(this._combinedScaleFactor);\n          ctx.strokeText(character, 0, 0);\n          ctx.restore();\n        } else {\n          ctx.strokeText(character, x, y);\n        }\n      }\n    }\n\n    if (isAddToPathSet) {\n      const paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n      paths.push({\n        transform: ctx.mozCurrentTransform,\n        x,\n        y,\n        fontSize,\n        addToPath,\n      });\n    }\n  }\n\n  get isFontSubpixelAAEnabled() {\n    // Checks if anti-aliasing is enabled when scaled text is painted.\n    // On Windows GDI scaled fonts looks bad.\n    const { context: ctx } = this.cachedCanvases.getCanvas(\n      \"isFontSubpixelAAEnabled\",\n      10,\n      10\n    );\n    ctx.scale(1.5, 1);\n    ctx.fillText(\"I\", 0, 10);\n    const data = ctx.getImageData(0, 0, 10, 10).data;\n    let enabled = false;\n    for (let i = 3; i < data.length; i += 4) {\n      if (data[i] > 0 && data[i] < 255) {\n        enabled = true;\n        break;\n      }\n    }\n    return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n  }\n\n  showText(glyphs) {\n    const current = this.current;\n    const font = current.font;\n    if (font.isType3Font) {\n      return this.showType3Text(glyphs);\n    }\n\n    const fontSize = current.fontSize;\n    if (fontSize === 0) {\n      return undefined;\n    }\n\n    const ctx = this.ctx;\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const glyphsLength = glyphs.length;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n\n    const simpleFillText =\n      current.textRenderingMode === TextRenderingMode.FILL &&\n      !font.disableFontFace &&\n      !current.patternFill;\n\n    ctx.save();\n    ctx.transform.apply(ctx, current.textMatrix);\n    ctx.translate(current.x, current.y + current.textRise);\n\n    if (fontDirection > 0) {\n      ctx.scale(textHScale, -1);\n    } else {\n      ctx.scale(textHScale, 1);\n    }\n\n    let patternTransform;\n    if (current.patternFill) {\n      ctx.save();\n      const pattern = current.fillColor.getPattern(\n        ctx,\n        this,\n        ctx.mozCurrentTransformInverse,\n        PathType.FILL\n      );\n      patternTransform = ctx.mozCurrentTransform;\n      ctx.restore();\n      ctx.fillStyle = pattern;\n    }\n\n    let lineWidth = current.lineWidth;\n    let resetLineWidthToOne = false;\n    const scale = current.textMatrixScale;\n    if (scale === 0 || lineWidth === 0) {\n      const fillStrokeMode =\n        current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n      if (\n        fillStrokeMode === TextRenderingMode.STROKE ||\n        fillStrokeMode === TextRenderingMode.FILL_STROKE\n      ) {\n        this._cachedGetSinglePixelWidth = null;\n        lineWidth = this.getSinglePixelWidth();\n        resetLineWidthToOne = lineWidth < 0;\n      }\n    } else {\n      lineWidth /= scale;\n    }\n\n    if (fontSizeScale !== 1.0) {\n      ctx.scale(fontSizeScale, fontSizeScale);\n      lineWidth /= fontSizeScale;\n    }\n\n    ctx.lineWidth = lineWidth;\n\n    let x = 0,\n      i;\n    for (i = 0; i < glyphsLength; ++i) {\n      const glyph = glyphs[i];\n      if (isNum(glyph)) {\n        x += (spacingDir * glyph * fontSize) / 1000;\n        continue;\n      }\n\n      let restoreNeeded = false;\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      const accent = glyph.accent;\n      let scaledX, scaledY;\n      let width = glyph.width;\n      if (vertical) {\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        const vx =\n          -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n\n      if (font.remeasure && width > 0) {\n        // Some standard fonts may not have the exact width: rescale per\n        // character if measured width is greater than expected glyph width\n        // and subpixel-aa is enabled, otherwise just center the glyph.\n        const measuredWidth =\n          ((ctx.measureText(character).width * 1000) / fontSize) *\n          fontSizeScale;\n        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n          const characterScaleX = width / measuredWidth;\n          restoreNeeded = true;\n          ctx.save();\n          ctx.scale(characterScaleX, 1);\n          scaledX /= characterScaleX;\n        } else if (width !== measuredWidth) {\n          scaledX +=\n            (((width - measuredWidth) / 2000) * fontSize) / fontSizeScale;\n        }\n      }\n\n      // Only attempt to draw the glyph if it is actually in the embedded font\n      // file or if there isn't a font file so the fallback font is shown.\n      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n        if (simpleFillText && !accent) {\n          // common case\n          ctx.fillText(character, scaledX, scaledY);\n        } else {\n          this.paintChar(\n            character,\n            scaledX,\n            scaledY,\n            patternTransform,\n            resetLineWidthToOne\n          );\n          if (accent) {\n            const scaledAccentX =\n              scaledX + (fontSize * accent.offset.x) / fontSizeScale;\n            const scaledAccentY =\n              scaledY - (fontSize * accent.offset.y) / fontSizeScale;\n            this.paintChar(\n              accent.fontChar,\n              scaledAccentX,\n              scaledAccentY,\n              patternTransform,\n              resetLineWidthToOne\n            );\n          }\n        }\n      }\n\n      let charWidth;\n      if (vertical) {\n        charWidth = width * widthAdvanceScale - spacing * fontDirection;\n      } else {\n        charWidth = width * widthAdvanceScale + spacing * fontDirection;\n      }\n      x += charWidth;\n\n      if (restoreNeeded) {\n        ctx.restore();\n      }\n    }\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n    ctx.restore();\n    this.compose();\n    return undefined;\n  }\n\n  showType3Text(glyphs) {\n    // Type3 fonts - each glyph is a \"mini-PDF\"\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    const fontDirection = current.fontDirection;\n    const spacingDir = font.vertical ? 1 : -1;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const textHScale = current.textHScale * fontDirection;\n    const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n    const glyphsLength = glyphs.length;\n    const isTextInvisible =\n      current.textRenderingMode === TextRenderingMode.INVISIBLE;\n    let i, glyph, width, spacingLength;\n\n    if (isTextInvisible || fontSize === 0) {\n      return;\n    }\n    this._cachedGetSinglePixelWidth = null;\n\n    ctx.save();\n    ctx.transform.apply(ctx, current.textMatrix);\n    ctx.translate(current.x, current.y);\n\n    ctx.scale(textHScale, fontDirection);\n\n    for (i = 0; i < glyphsLength; ++i) {\n      glyph = glyphs[i];\n      if (isNum(glyph)) {\n        spacingLength = (spacingDir * glyph * fontSize) / 1000;\n        this.ctx.translate(spacingLength, 0);\n        current.x += spacingLength * textHScale;\n        continue;\n      }\n\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const operatorList = font.charProcOperatorList[glyph.operatorListId];\n      if (!operatorList) {\n        warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n        continue;\n      }\n      if (this.contentVisible) {\n        this.processingType3 = glyph;\n        this.save();\n        ctx.scale(fontSize, fontSize);\n        ctx.transform.apply(ctx, fontMatrix);\n        this.executeOperatorList(operatorList);\n        this.restore();\n      }\n\n      const transformed = Util.applyTransform([glyph.width, 0], fontMatrix);\n      width = transformed[0] * fontSize + spacing;\n\n      ctx.translate(width, 0);\n      current.x += width * textHScale;\n    }\n    ctx.restore();\n    this.processingType3 = null;\n  }\n\n  // Type3 fonts\n  setCharWidth(xWidth, yWidth) {\n    // We can safely ignore this since the width should be the same\n    // as the width in the Widths array.\n  }\n\n  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n    // TODO According to the spec we're also suppose to ignore any operators\n    // that set color or include images while processing this type3 font.\n    this.ctx.rect(llx, lly, urx - llx, ury - lly);\n    this.clip();\n    this.endPath();\n  }\n\n  // Color\n  getColorN_Pattern(IR) {\n    let pattern;\n    if (IR[0] === \"TilingPattern\") {\n      const color = IR[1];\n      const baseTransform =\n        this.baseTransform || this.ctx.mozCurrentTransform.slice();\n      const canvasGraphicsFactory = {\n        createCanvasGraphics: ctx => {\n          return new CanvasGraphics(\n            ctx,\n            this.commonObjs,\n            this.objs,\n            this.canvasFactory\n          );\n        },\n      };\n      pattern = new TilingPattern(\n        IR,\n        color,\n        this.ctx,\n        canvasGraphicsFactory,\n        baseTransform\n      );\n    } else {\n      pattern = this._getPattern(IR[1], IR[2]);\n    }\n    return pattern;\n  }\n\n  setStrokeColorN() {\n    this.current.strokeColor = this.getColorN_Pattern(arguments);\n  }\n\n  setFillColorN() {\n    this.current.fillColor = this.getColorN_Pattern(arguments);\n    this.current.patternFill = true;\n  }\n\n  setStrokeRGBColor(r, g, b) {\n    const color = Util.makeHexColor(r, g, b);\n    this.ctx.strokeStyle = color;\n    this.current.strokeColor = color;\n  }\n\n  setFillRGBColor(r, g, b) {\n    const color = Util.makeHexColor(r, g, b);\n    this.ctx.fillStyle = color;\n    this.current.fillColor = color;\n    this.current.patternFill = false;\n  }\n\n  _getPattern(objId, matrix = null) {\n    let pattern;\n    if (this.cachedPatterns.has(objId)) {\n      pattern = this.cachedPatterns.get(objId);\n    } else {\n      pattern = getShadingPattern(this.objs.get(objId));\n      this.cachedPatterns.set(objId, pattern);\n    }\n    if (matrix) {\n      pattern.matrix = matrix;\n    }\n    return pattern;\n  }\n\n  shadingFill(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n\n    this.save();\n    const pattern = this._getPattern(objId);\n    ctx.fillStyle = pattern.getPattern(\n      ctx,\n      this,\n      ctx.mozCurrentTransformInverse,\n      PathType.SHADING\n    );\n\n    const inv = ctx.mozCurrentTransformInverse;\n    if (inv) {\n      const canvas = ctx.canvas;\n      const width = canvas.width;\n      const height = canvas.height;\n\n      const bl = Util.applyTransform([0, 0], inv);\n      const br = Util.applyTransform([0, height], inv);\n      const ul = Util.applyTransform([width, 0], inv);\n      const ur = Util.applyTransform([width, height], inv);\n\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n\n      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n    } else {\n      // HACK to draw the gradient onto an infinite rectangle.\n      // PDF gradients are drawn across the entire image while\n      // Canvas only allows gradients to be drawn in a rectangle\n      // The following bug should allow us to remove this.\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=664884\n\n      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n    }\n\n    this.compose(this.current.getClippedPathBoundingBox());\n    this.restore();\n  }\n\n  // Images\n  beginInlineImage() {\n    unreachable(\"Should not call beginInlineImage\");\n  }\n\n  beginImageData() {\n    unreachable(\"Should not call beginImageData\");\n  }\n\n  paintFormXObjectBegin(matrix, bbox) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.save();\n    this.baseTransformStack.push(this.baseTransform);\n\n    if (Array.isArray(matrix) && matrix.length === 6) {\n      this.transform.apply(this, matrix);\n    }\n\n    this.baseTransform = this.ctx.mozCurrentTransform;\n\n    if (bbox) {\n      const width = bbox[2] - bbox[0];\n      const height = bbox[3] - bbox[1];\n      this.ctx.rect(bbox[0], bbox[1], width, height);\n      this.current.updatePathMinMax(\n        this.ctx.mozCurrentTransform,\n        bbox[0],\n        bbox[1]\n      );\n      this.current.updatePathMinMax(\n        this.ctx.mozCurrentTransform,\n        bbox[2],\n        bbox[3]\n      );\n      this.clip();\n      this.endPath();\n    }\n  }\n\n  paintFormXObjectEnd() {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.restore();\n    this.baseTransform = this.baseTransformStack.pop();\n  }\n\n  beginGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n\n    this.save();\n    // If there's an active soft mask we don't want it enabled for the group, so\n    // clear it out. The mask and suspended canvas will be restored in endGroup.\n    const suspendedCtx = this.suspendedCtx;\n    if (this.current.activeSMask) {\n      this.suspendedCtx = null;\n      this.current.activeSMask = null;\n    }\n\n    const currentCtx = this.ctx;\n    // TODO non-isolated groups - according to Rik at adobe non-isolated\n    // group results aren't usually that different and they even have tools\n    // that ignore this setting. Notes from Rik on implementing:\n    // - When you encounter an transparency group, create a new canvas with\n    // the dimensions of the bbox\n    // - copy the content from the previous canvas to the new canvas\n    // - draw as usual\n    // - remove the backdrop alpha:\n    // alphaNew = 1 - (1 - alpha)/(1 - alphaBackdrop) with 'alpha' the alpha\n    // value of your transparency group and 'alphaBackdrop' the alpha of the\n    // backdrop\n    // - remove background color:\n    // colorNew = color - alphaNew *colorBackdrop /(1 - alphaNew)\n    if (!group.isolated) {\n      info(\"TODO: Support non-isolated groups.\");\n    }\n\n    // TODO knockout - supposedly possible with the clever use of compositing\n    // modes.\n    if (group.knockout) {\n      warn(\"Knockout groups not supported.\");\n    }\n\n    const currentTransform = currentCtx.mozCurrentTransform;\n    if (group.matrix) {\n      currentCtx.transform.apply(currentCtx, group.matrix);\n    }\n    if (!group.bbox) {\n      throw new Error(\"Bounding box is required.\");\n    }\n\n    // Based on the current transform figure out how big the bounding box\n    // will actually be.\n    let bounds = Util.getAxialAlignedBoundingBox(\n      group.bbox,\n      currentCtx.mozCurrentTransform\n    );\n    // Clip the bounding box to the current canvas.\n    const canvasBounds = [\n      0,\n      0,\n      currentCtx.canvas.width,\n      currentCtx.canvas.height,\n    ];\n    bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n    // Use ceil in case we're between sizes so we don't create canvas that is\n    // too small and make the canvas at least 1x1 pixels.\n    const offsetX = Math.floor(bounds[0]);\n    const offsetY = Math.floor(bounds[1]);\n    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n    let scaleX = 1,\n      scaleY = 1;\n    if (drawnWidth > MAX_GROUP_SIZE) {\n      scaleX = drawnWidth / MAX_GROUP_SIZE;\n      drawnWidth = MAX_GROUP_SIZE;\n    }\n    if (drawnHeight > MAX_GROUP_SIZE) {\n      scaleY = drawnHeight / MAX_GROUP_SIZE;\n      drawnHeight = MAX_GROUP_SIZE;\n    }\n\n    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n\n    let cacheId = \"groupAt\" + this.groupLevel;\n    if (group.smask) {\n      // Using two cache entries is case if masks are used one after another.\n      cacheId += \"_smask_\" + (this.smaskCounter++ % 2);\n    }\n    const scratchCanvas = this.cachedCanvases.getCanvas(\n      cacheId,\n      drawnWidth,\n      drawnHeight,\n      true\n    );\n    const groupCtx = scratchCanvas.context;\n\n    // Since we created a new canvas that is just the size of the bounding box\n    // we have to translate the group ctx.\n    groupCtx.scale(1 / scaleX, 1 / scaleY);\n    groupCtx.translate(-offsetX, -offsetY);\n    groupCtx.transform.apply(groupCtx, currentTransform);\n\n    if (group.smask) {\n      // Saving state and cached mask to be used in setGState.\n      this.smaskStack.push({\n        canvas: scratchCanvas.canvas,\n        context: groupCtx,\n        offsetX,\n        offsetY,\n        scaleX,\n        scaleY,\n        subtype: group.smask.subtype,\n        backdrop: group.smask.backdrop,\n        transferMap: group.smask.transferMap || null,\n        startTransformInverse: null, // used during suspend operation\n      });\n    } else {\n      // Setup the current ctx so when the group is popped we draw it at the\n      // right location.\n      currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n      currentCtx.translate(offsetX, offsetY);\n      currentCtx.scale(scaleX, scaleY);\n      currentCtx.save();\n    }\n    // The transparency group inherits all off the current graphics state\n    // except the blend mode, soft mask, and alpha constants.\n    copyCtxState(currentCtx, groupCtx);\n    this.ctx = groupCtx;\n    this.setGState([\n      [\"BM\", \"source-over\"],\n      [\"ca\", 1],\n      [\"CA\", 1],\n    ]);\n    this.groupStack.push({\n      ctx: currentCtx,\n      suspendedCtx,\n    });\n    this.groupLevel++;\n  }\n\n  endGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.groupLevel--;\n    const groupCtx = this.ctx;\n    const { ctx, suspendedCtx } = this.groupStack.pop();\n    this.ctx = ctx;\n    // Turn off image smoothing to avoid sub pixel interpolation which can\n    // look kind of blurry for some pdfs.\n    this.ctx.imageSmoothingEnabled = false;\n\n    if (suspendedCtx) {\n      this.suspendedCtx = suspendedCtx;\n    }\n\n    if (group.smask) {\n      this.tempSMask = this.smaskStack.pop();\n      this.restore();\n    } else {\n      this.ctx.restore();\n      const currentMtx = this.ctx.mozCurrentTransform;\n      this.restore();\n      this.ctx.save();\n      this.ctx.setTransform.apply(this.ctx, currentMtx);\n      const dirtyBox = Util.getAxialAlignedBoundingBox(\n        [0, 0, groupCtx.canvas.width, groupCtx.canvas.height],\n        currentMtx\n      );\n      this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      this.ctx.restore();\n      this.compose(dirtyBox);\n    }\n  }\n\n  beginAnnotations() {\n    this.save();\n    if (this.baseTransform) {\n      this.ctx.setTransform.apply(this.ctx, this.baseTransform);\n    }\n  }\n\n  endAnnotations() {\n    this.restore();\n  }\n\n  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n    this.save();\n\n    if (Array.isArray(rect) && rect.length === 4) {\n      const width = rect[2] - rect[0];\n      const height = rect[3] - rect[1];\n\n      if (hasOwnCanvas && this.annotationCanvasMap) {\n        transform = transform.slice();\n        transform[4] -= rect[0];\n        transform[5] -= rect[1];\n\n        rect = rect.slice();\n        rect[0] = rect[1] = 0;\n        rect[2] = width;\n        rect[3] = height;\n\n        const [scaleX, scaleY] = Util.singularValueDecompose2dScale(\n          this.ctx.mozCurrentTransform\n        );\n        const { viewportScale } = this;\n        const canvasWidth = Math.ceil(\n          width * this.outputScaleX * viewportScale\n        );\n        const canvasHeight = Math.ceil(\n          height * this.outputScaleY * viewportScale\n        );\n\n        this.annotationCanvas = this.canvasFactory.create(\n          canvasWidth,\n          canvasHeight\n        );\n        const { canvas, context } = this.annotationCanvas;\n        canvas.style.width = `calc(${width}px * var(--viewport-scale-factor))`;\n        canvas.style.height = `calc(${height}px * var(--viewport-scale-factor))`;\n        this.annotationCanvasMap.set(id, canvas);\n        this.annotationCanvas.savedCtx = this.ctx;\n        this.ctx = context;\n        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n        addContextCurrentTransform(this.ctx);\n\n        resetCtxToDefault(this.ctx);\n      } else {\n        resetCtxToDefault(this.ctx);\n\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.clip();\n        this.endPath();\n      }\n    }\n\n    this.current = new CanvasExtraState(\n      this.ctx.canvas.width,\n      this.ctx.canvas.height\n    );\n\n    this.transform.apply(this, transform);\n    this.transform.apply(this, matrix);\n  }\n\n  endAnnotation() {\n    if (this.annotationCanvas) {\n      this.ctx = this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas;\n    }\n    this.restore();\n  }\n\n  paintImageMaskXObject(img) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    const width = img.width,\n      height = img.height;\n\n    const glyph = this.processingType3;\n\n    if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\n      if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\n        glyph.compiled = compileType3Glyph({ data: img.data, width, height });\n      } else {\n        glyph.compiled = null;\n      }\n    }\n\n    if (glyph?.compiled) {\n      glyph.compiled(ctx);\n      return;\n    }\n    const mask = this._createMaskCanvas(img);\n    const maskCanvas = mask.canvas;\n\n    ctx.save();\n    // The mask is drawn with the transform applied. Reset the current\n    // transform to draw to the identity.\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n    ctx.restore();\n    this.compose();\n  }\n\n  paintImageMaskXObjectRepeat(\n    imgData,\n    scaleX,\n    skewX = 0,\n    skewY = 0,\n    scaleY,\n    positions\n  ) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    ctx.save();\n    const currentTransform = ctx.mozCurrentTransform;\n    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n    const mask = this._createMaskCanvas(imgData);\n\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      const trans = Util.transform(currentTransform, [\n        scaleX,\n        skewX,\n        skewY,\n        scaleY,\n        positions[i],\n        positions[i + 1],\n      ]);\n\n      const [x, y] = Util.applyTransform([0, 0], trans);\n      ctx.drawImage(mask.canvas, x, y);\n    }\n    ctx.restore();\n    this.compose();\n  }\n\n  paintImageMaskXObjectGroup(images) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    for (let i = 0, ii = images.length; i < ii; i++) {\n      const image = images[i];\n      const width = image.width,\n        height = image.height;\n\n      const maskCanvas = this.cachedCanvases.getCanvas(\n        \"maskCanvas\",\n        width,\n        height\n      );\n      const maskCtx = maskCanvas.context;\n      maskCtx.save();\n\n      putBinaryImageMask(maskCtx, image);\n\n      maskCtx.globalCompositeOperation = \"source-in\";\n\n      maskCtx.fillStyle = isPatternFill\n        ? fillColor.getPattern(\n            maskCtx,\n            this,\n            ctx.mozCurrentTransformInverse,\n            PathType.FILL\n          )\n        : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n\n      maskCtx.restore();\n\n      ctx.save();\n      ctx.transform.apply(ctx, image.transform);\n      ctx.scale(1, -1);\n      ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n      ctx.restore();\n    }\n    this.compose();\n  }\n\n  paintImageXObject(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = objId.startsWith(\"g_\")\n      ? this.commonObjs.get(objId)\n      : this.objs.get(objId);\n    if (!imgData) {\n      warn(\"Dependent image isn't ready yet\");\n      return;\n    }\n\n    this.paintInlineImageXObject(imgData);\n  }\n\n  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = objId.startsWith(\"g_\")\n      ? this.commonObjs.get(objId)\n      : this.objs.get(objId);\n    if (!imgData) {\n      warn(\"Dependent image isn't ready yet\");\n      return;\n    }\n\n    const width = imgData.width;\n    const height = imgData.height;\n    const map = [];\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      map.push({\n        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n        x: 0,\n        y: 0,\n        w: width,\n        h: height,\n      });\n    }\n    this.paintInlineImageXObjectGroup(imgData, map);\n  }\n\n  paintInlineImageXObject(imgData) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const width = imgData.width;\n    const height = imgData.height;\n    const ctx = this.ctx;\n\n    this.save();\n    // scale the image to the unit square\n    ctx.scale(1 / width, -1 / height);\n\n    let imgToPaint;\n    // typeof check is needed due to node.js support, see issue #8489\n    if (\n      (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement) ||\n      !imgData.data\n    ) {\n      imgToPaint = imgData;\n    } else {\n      const tmpCanvas = this.cachedCanvases.getCanvas(\n        \"inlineImage\",\n        width,\n        height\n      );\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n      imgToPaint = tmpCanvas.canvas;\n    }\n\n    const scaled = this._scaleImage(imgToPaint, ctx.mozCurrentTransformInverse);\n    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(\n      ctx.mozCurrentTransform,\n      imgData.interpolate\n    );\n    ctx.drawImage(\n      scaled.img,\n      0,\n      0,\n      scaled.paintWidth,\n      scaled.paintHeight,\n      0,\n      -height,\n      width,\n      height\n    );\n\n    if (this.imageLayer) {\n      const position = this.getCanvasPosition(0, -height);\n      this.imageLayer.appendImage({\n        imgData,\n        left: position[0],\n        top: position[1],\n        width: width / ctx.mozCurrentTransformInverse[0],\n        height: height / ctx.mozCurrentTransformInverse[3],\n      });\n    }\n    this.compose();\n    this.restore();\n  }\n\n  paintInlineImageXObjectGroup(imgData, map) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    const w = imgData.width;\n    const h = imgData.height;\n\n    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n    const tmpCtx = tmpCanvas.context;\n    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n\n    for (let i = 0, ii = map.length; i < ii; i++) {\n      const entry = map[i];\n      ctx.save();\n      ctx.transform.apply(ctx, entry.transform);\n      ctx.scale(1, -1);\n      ctx.drawImage(\n        tmpCanvas.canvas,\n        entry.x,\n        entry.y,\n        entry.w,\n        entry.h,\n        0,\n        -1,\n        1,\n        1\n      );\n      if (this.imageLayer) {\n        const position = this.getCanvasPosition(entry.x, entry.y);\n        this.imageLayer.appendImage({\n          imgData,\n          left: position[0],\n          top: position[1],\n          width: w,\n          height: h,\n        });\n      }\n      ctx.restore();\n    }\n    this.compose();\n  }\n\n  paintSolidColorImageMask() {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.ctx.fillRect(0, 0, 1, 1);\n    this.compose();\n  }\n\n  // Marked content\n\n  markPoint(tag) {\n    // TODO Marked content.\n  }\n\n  markPointProps(tag, properties) {\n    // TODO Marked content.\n  }\n\n  beginMarkedContent(tag) {\n    this.markedContentStack.push({\n      visible: true,\n    });\n  }\n\n  beginMarkedContentProps(tag, properties) {\n    if (tag === \"OC\") {\n      this.markedContentStack.push({\n        visible: this.optionalContentConfig.isVisible(properties),\n      });\n    } else {\n      this.markedContentStack.push({\n        visible: true,\n      });\n    }\n    this.contentVisible = this.isContentVisible();\n  }\n\n  endMarkedContent() {\n    this.markedContentStack.pop();\n    this.contentVisible = this.isContentVisible();\n  }\n\n  // Compatibility\n\n  beginCompat() {\n    // TODO ignore undefined operators (should we do that anyway?)\n  }\n\n  endCompat() {\n    // TODO stop ignoring undefined operators\n  }\n\n  // Helper functions\n\n  consumePath(clipBox) {\n    if (this.pendingClip) {\n      this.current.updateClipFromPath();\n    }\n    if (!this.pendingClip) {\n      this.compose(clipBox);\n    }\n    const ctx = this.ctx;\n    if (this.pendingClip) {\n      if (this.pendingClip === EO_CLIP) {\n        ctx.clip(\"evenodd\");\n      } else {\n        ctx.clip();\n      }\n      this.pendingClip = null;\n    }\n    this.current.startNewPathAndClipBox(this.current.clipBox);\n    ctx.beginPath();\n  }\n\n  getSinglePixelWidth() {\n    if (this._cachedGetSinglePixelWidth === null) {\n      // If transform is [a b] then a pixel (square) is transformed\n      //                 [c d]\n      // into a parallelogram: its area is the abs value of the determinant.\n      // This parallelogram has 2 heights:\n      //  - Area / |col_1|;\n      //  - Area / |col_2|.\n      // so in order to get a height of at least 1, pixel height\n      // must be computed as followed:\n      //  h = max(sqrt(a + c) / |det(M)|, sqrt(b + d) / |det(M)|).\n      // This is equivalent to:\n      //  h = max(|line_1_inv(M)|, |line_2_inv(M)|)\n      const m = this.ctx.mozCurrentTransform;\n\n      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n      const sqNorm1 = m[0] ** 2 + m[2] ** 2;\n      const sqNorm2 = m[1] ** 2 + m[3] ** 2;\n      const pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;\n      if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {\n        // The parallelogram isn't a square and at least one height\n        // is lower than 1 so the resulting line width must be 1\n        // but it cannot be achieved with one scale: when scaling a pixel\n        // we'll get a rectangle (see issue #12295).\n        // For example with matrix [0.001 0, 0, 100], a pixel is transformed\n        // in a rectangle 0.001x100. If we just scale by 1000 (to have a 1)\n        // then we'll get a rectangle 1x1e5 which is wrong.\n        // In this case, we must reset the transform, set linewidth to 1\n        // and then stroke.\n        this._cachedGetSinglePixelWidth = -(\n          this._combinedScaleFactor * pixelHeight\n        );\n      } else if (absDet > Number.EPSILON) {\n        this._cachedGetSinglePixelWidth = pixelHeight;\n      } else {\n        // Matrix is non-invertible.\n        this._cachedGetSinglePixelWidth = 1;\n      }\n    }\n\n    return this._cachedGetSinglePixelWidth;\n  }\n\n  getCanvasPosition(x, y) {\n    const transform = this.ctx.mozCurrentTransform;\n    return [\n      transform[0] * x + transform[2] * y + transform[4],\n      transform[1] * x + transform[3] * y + transform[5],\n    ];\n  }\n\n  isContentVisible() {\n    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n      if (!this.markedContentStack[i].visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nfor (const op in OPS) {\n  if (CanvasGraphics.prototype[op] !== undefined) {\n    CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n  }\n}\n\nexport { CanvasGraphics };\n","/* Copyright 2014 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  FormatError,\n  info,\n  shadow,\n  unreachable,\n  Util,\n  warn,\n} from \"../shared/util.js\";\n\nconst PathType = {\n  FILL: \"Fill\",\n  STROKE: \"Stroke\",\n  SHADING: \"Shading\",\n};\n\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox || typeof Path2D === \"undefined\") {\n    return;\n  }\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\n\nclass BaseShadingPattern {\n  constructor() {\n    if (this.constructor === BaseShadingPattern) {\n      unreachable(\"Cannot initialize BaseShadingPattern.\");\n    }\n  }\n\n  getPattern() {\n    unreachable(\"Abstract method `getPattern` called.\");\n  }\n}\n\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._type = IR[1];\n    this._bbox = IR[2];\n    this._colorStops = IR[3];\n    this._p0 = IR[4];\n    this._p1 = IR[5];\n    this._r0 = IR[6];\n    this._r1 = IR[7];\n    this.matrix = null;\n  }\n\n  _createGradient(ctx) {\n    let grad;\n    if (this._type === \"axial\") {\n      grad = ctx.createLinearGradient(\n        this._p0[0],\n        this._p0[1],\n        this._p1[0],\n        this._p1[1]\n      );\n    } else if (this._type === \"radial\") {\n      grad = ctx.createRadialGradient(\n        this._p0[0],\n        this._p0[1],\n        this._r0,\n        this._p1[0],\n        this._p1[1],\n        this._r1\n      );\n    }\n\n    for (const colorStop of this._colorStops) {\n      grad.addColorStop(colorStop[0], colorStop[1]);\n    }\n    return grad;\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    let pattern;\n    if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n      const ownerBBox = owner.current.getClippedPathBoundingBox(\n        pathType,\n        ctx.mozCurrentTransform\n      ) || [0, 0, 0, 0];\n      // Create a canvas that is only as big as the current path. This doesn't\n      // allow us to cache the pattern, but it generally creates much smaller\n      // canvases and saves memory use. See bug 1722807 for an example.\n      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n\n      const tmpCanvas = owner.cachedCanvases.getCanvas(\n        \"pattern\",\n        width,\n        height,\n        true\n      );\n\n      const tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.beginPath();\n      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      // Non shading fill patterns are positioned relative to the base transform\n      // (usually the page's initial transform), but we may have created a\n      // smaller canvas based on the path, so we must account for the shift.\n      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n      inverse = Util.transform(inverse, [\n        1,\n        0,\n        0,\n        1,\n        ownerBBox[0],\n        ownerBBox[1],\n      ]);\n\n      tmpCtx.transform.apply(tmpCtx, owner.baseTransform);\n      if (this.matrix) {\n        tmpCtx.transform.apply(tmpCtx, this.matrix);\n      }\n      applyBoundingBox(tmpCtx, this._bbox);\n\n      tmpCtx.fillStyle = this._createGradient(tmpCtx);\n      tmpCtx.fill();\n\n      pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n      const domMatrix = new DOMMatrix(inverse);\n      try {\n        pattern.setTransform(domMatrix);\n      } catch (ex) {\n        // Avoid rendering breaking completely in Firefox 78 ESR,\n        // and in Node.js (see issue 13724).\n        warn(`RadialAxialShadingPattern.getPattern: \"${ex?.message}\".`);\n      }\n    } else {\n      // Shading fills are applied relative to the current matrix which is also\n      // how canvas gradients work, so there's no need to do anything special\n      // here.\n      applyBoundingBox(ctx, this._bbox);\n      pattern = this._createGradient(ctx);\n    }\n    return pattern;\n  }\n}\n\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n  // Very basic Gouraud-shaded triangle rasterization algorithm.\n  const coords = context.coords,\n    colors = context.colors;\n  const bytes = data.data,\n    rowSize = data.width * 4;\n  let tmp;\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  if (coords[p2 + 1] > coords[p3 + 1]) {\n    tmp = p2;\n    p2 = p3;\n    p3 = tmp;\n    tmp = c2;\n    c2 = c3;\n    c3 = tmp;\n  }\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n  const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n  const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n  if (y1 >= y3) {\n    return;\n  }\n  const c1r = colors[c1],\n    c1g = colors[c1 + 1],\n    c1b = colors[c1 + 2];\n  const c2r = colors[c2],\n    c2g = colors[c2 + 1],\n    c2b = colors[c2 + 2];\n  const c3r = colors[c3],\n    c3g = colors[c3 + 1],\n    c3b = colors[c3 + 2];\n\n  const minY = Math.round(y1),\n    maxY = Math.round(y3);\n  let xa, car, cag, cab;\n  let xb, cbr, cbg, cbb;\n  for (let y = minY; y <= maxY; y++) {\n    if (y < y2) {\n      let k;\n      if (y < y1) {\n        k = 0;\n      } else {\n        k = (y1 - y) / (y1 - y2);\n      }\n      xa = x1 - (x1 - x2) * k;\n      car = c1r - (c1r - c2r) * k;\n      cag = c1g - (c1g - c2g) * k;\n      cab = c1b - (c1b - c2b) * k;\n    } else {\n      let k;\n      if (y > y3) {\n        k = 1;\n      } else if (y2 === y3) {\n        k = 0;\n      } else {\n        k = (y2 - y) / (y2 - y3);\n      }\n      xa = x2 - (x2 - x3) * k;\n      car = c2r - (c2r - c3r) * k;\n      cag = c2g - (c2g - c3g) * k;\n      cab = c2b - (c2b - c3b) * k;\n    }\n\n    let k;\n    if (y < y1) {\n      k = 0;\n    } else if (y > y3) {\n      k = 1;\n    } else {\n      k = (y1 - y) / (y1 - y3);\n    }\n    xb = x1 - (x1 - x3) * k;\n    cbr = c1r - (c1r - c3r) * k;\n    cbg = c1g - (c1g - c3g) * k;\n    cbb = c1b - (c1b - c3b) * k;\n    const x1_ = Math.round(Math.min(xa, xb));\n    const x2_ = Math.round(Math.max(xa, xb));\n    let j = rowSize * y + x1_ * 4;\n    for (let x = x1_; x <= x2_; x++) {\n      k = (xa - x) / (xa - xb);\n      if (k < 0) {\n        k = 0;\n      } else if (k > 1) {\n        k = 1;\n      }\n      bytes[j++] = (car - (car - cbr) * k) | 0;\n      bytes[j++] = (cag - (cag - cbg) * k) | 0;\n      bytes[j++] = (cab - (cab - cbb) * k) | 0;\n      bytes[j++] = 255;\n    }\n  }\n}\n\nfunction drawFigure(data, figure, context) {\n  const ps = figure.coords;\n  const cs = figure.colors;\n  let i, ii;\n  switch (figure.type) {\n    case \"lattice\":\n      const verticesPerRow = figure.verticesPerRow;\n      const rows = Math.floor(ps.length / verticesPerRow) - 1;\n      const cols = verticesPerRow - 1;\n      for (i = 0; i < rows; i++) {\n        let q = i * verticesPerRow;\n        for (let j = 0; j < cols; j++, q++) {\n          drawTriangle(\n            data,\n            context,\n            ps[q],\n            ps[q + 1],\n            ps[q + verticesPerRow],\n            cs[q],\n            cs[q + 1],\n            cs[q + verticesPerRow]\n          );\n          drawTriangle(\n            data,\n            context,\n            ps[q + verticesPerRow + 1],\n            ps[q + 1],\n            ps[q + verticesPerRow],\n            cs[q + verticesPerRow + 1],\n            cs[q + 1],\n            cs[q + verticesPerRow]\n          );\n        }\n      }\n      break;\n    case \"triangles\":\n      for (i = 0, ii = ps.length; i < ii; i += 3) {\n        drawTriangle(\n          data,\n          context,\n          ps[i],\n          ps[i + 1],\n          ps[i + 2],\n          cs[i],\n          cs[i + 1],\n          cs[i + 2]\n        );\n      }\n      break;\n    default:\n      throw new Error(\"illegal figure\");\n  }\n}\n\nclass MeshShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._coords = IR[2];\n    this._colors = IR[3];\n    this._figures = IR[4];\n    this._bounds = IR[5];\n    this._bbox = IR[7];\n    this._background = IR[8];\n    this.matrix = null;\n  }\n\n  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n    // we will increase scale on some weird factor to let antialiasing take\n    // care of \"rough\" edges\n    const EXPECTED_SCALE = 1.1;\n    // MAX_PATTERN_SIZE is used to avoid OOM situation.\n    const MAX_PATTERN_SIZE = 3000; // 10in @ 300dpi shall be enough\n    // We need to keep transparent border around our pattern for fill():\n    // createPattern with 'no-repeat' will bleed edges across entire area.\n    const BORDER_SIZE = 2;\n\n    const offsetX = Math.floor(this._bounds[0]);\n    const offsetY = Math.floor(this._bounds[1]);\n    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n\n    const width = Math.min(\n      Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)),\n      MAX_PATTERN_SIZE\n    );\n    const height = Math.min(\n      Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)),\n      MAX_PATTERN_SIZE\n    );\n    const scaleX = boundsWidth / width;\n    const scaleY = boundsHeight / height;\n\n    const context = {\n      coords: this._coords,\n      colors: this._colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY,\n    };\n\n    const paddedWidth = width + BORDER_SIZE * 2;\n    const paddedHeight = height + BORDER_SIZE * 2;\n\n    const tmpCanvas = cachedCanvases.getCanvas(\n      \"mesh\",\n      paddedWidth,\n      paddedHeight,\n      false\n    );\n    const tmpCtx = tmpCanvas.context;\n\n    const data = tmpCtx.createImageData(width, height);\n    if (backgroundColor) {\n      const bytes = data.data;\n      for (let i = 0, ii = bytes.length; i < ii; i += 4) {\n        bytes[i] = backgroundColor[0];\n        bytes[i + 1] = backgroundColor[1];\n        bytes[i + 2] = backgroundColor[2];\n        bytes[i + 3] = 255;\n      }\n    }\n    for (const figure of this._figures) {\n      drawFigure(data, figure, context);\n    }\n    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n    const canvas = tmpCanvas.canvas;\n\n    return {\n      canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX,\n      scaleY,\n    };\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    applyBoundingBox(ctx, this._bbox);\n    let scale;\n    if (pathType === PathType.SHADING) {\n      scale = Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\n    } else {\n      // Obtain scale from matrix and current transformation matrix.\n      scale = Util.singularValueDecompose2dScale(owner.baseTransform);\n      if (this.matrix) {\n        const matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n      }\n    }\n\n    // Rasterizing on the main thread since sending/queue large canvases\n    // might cause OOM.\n    const temporaryPatternCanvas = this._createMeshCanvas(\n      scale,\n      pathType === PathType.SHADING ? null : this._background,\n      owner.cachedCanvases\n    );\n\n    if (pathType !== PathType.SHADING) {\n      ctx.setTransform.apply(ctx, owner.baseTransform);\n      if (this.matrix) {\n        ctx.transform.apply(ctx, this.matrix);\n      }\n    }\n\n    ctx.translate(\n      temporaryPatternCanvas.offsetX,\n      temporaryPatternCanvas.offsetY\n    );\n    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n\n    return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n  }\n}\n\nclass DummyShadingPattern extends BaseShadingPattern {\n  getPattern() {\n    return \"hotpink\";\n  }\n}\n\nfunction getShadingPattern(IR) {\n  switch (IR[0]) {\n    case \"RadialAxial\":\n      return new RadialAxialShadingPattern(IR);\n    case \"Mesh\":\n      return new MeshShadingPattern(IR);\n    case \"Dummy\":\n      return new DummyShadingPattern();\n  }\n  throw new Error(`Unknown IR type: ${IR[0]}`);\n}\n\nconst PaintType = {\n  COLORED: 1,\n  UNCOLORED: 2,\n};\n\nclass TilingPattern {\n  // 10in @ 300dpi shall be enough.\n  static get MAX_PATTERN_SIZE() {\n    return shadow(this, \"MAX_PATTERN_SIZE\", 3000);\n  }\n\n  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.ctx = ctx;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n  }\n\n  createPatternCanvas(owner) {\n    const operatorList = this.operatorList;\n    const bbox = this.bbox;\n    const xstep = this.xstep;\n    const ystep = this.ystep;\n    const paintType = this.paintType;\n    const tilingType = this.tilingType;\n    const color = this.color;\n    const canvasGraphicsFactory = this.canvasGraphicsFactory;\n\n    info(\"TilingType: \" + tilingType);\n\n    // A tiling pattern as defined by PDF spec 8.7.2 is a cell whose size is\n    // described by bbox, and may repeat regularly by shifting the cell by\n    // xstep and ystep.\n    // Because the HTML5 canvas API does not support pattern repetition with\n    // gaps in between, we use the xstep/ystep instead of the bbox's size.\n    //\n    // This has the following consequences (similarly for ystep):\n    //\n    // - If xstep is the same as bbox, then there is no observable difference.\n    //\n    // - If xstep is larger than bbox, then the pattern canvas is partially\n    //   empty: the area bounded by bbox is painted, the outside area is void.\n    //\n    // - If xstep is smaller than bbox, then the pixels between xstep and the\n    //   bbox boundary will be missing. This is INCORRECT behavior.\n    //   \"Figures on adjacent tiles should not overlap\" (PDF spec 8.7.3.1),\n    //   but overlapping cells without common pixels are still valid.\n    //   TODO: Fix the implementation, to allow this scenario to be painted\n    //   correctly.\n\n    const x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3];\n\n    // Obtain scale from matrix and current transformation matrix.\n    const matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n    const curMatrixScale = Util.singularValueDecompose2dScale(\n      this.baseTransform\n    );\n    const combinedScale = [\n      matrixScale[0] * curMatrixScale[0],\n      matrixScale[1] * curMatrixScale[1],\n    ];\n\n    // Use width and height values that are as close as possible to the end\n    // result when the pattern is used. Too low value makes the pattern look\n    // blurry. Too large value makes it look too crispy.\n    const dimx = this.getSizeAndScale(\n      xstep,\n      this.ctx.canvas.width,\n      combinedScale[0]\n    );\n    const dimy = this.getSizeAndScale(\n      ystep,\n      this.ctx.canvas.height,\n      combinedScale[1]\n    );\n\n    const tmpCanvas = owner.cachedCanvases.getCanvas(\n      \"pattern\",\n      dimx.size,\n      dimy.size,\n      true\n    );\n    const tmpCtx = tmpCanvas.context;\n    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n    graphics.groupLevel = owner.groupLevel;\n\n    this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n\n    let adjustedX0 = x0;\n    let adjustedY0 = y0;\n    let adjustedX1 = x1;\n    let adjustedY1 = y1;\n    // Some bounding boxes have negative x0/y0 cordinates which will cause the\n    // some of the drawing to be off of the canvas. To avoid this shift the\n    // bounding box over.\n    if (x0 < 0) {\n      adjustedX0 = 0;\n      adjustedX1 += Math.abs(x0);\n    }\n    if (y0 < 0) {\n      adjustedY0 = 0;\n      adjustedY1 += Math.abs(y0);\n    }\n    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n\n    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n\n    graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();\n\n    graphics.executeOperatorList(operatorList);\n\n    graphics.endDrawing();\n\n    return {\n      canvas: tmpCanvas.canvas,\n      scaleX: dimx.scale,\n      scaleY: dimy.scale,\n      offsetX: adjustedX0,\n      offsetY: adjustedY0,\n    };\n  }\n\n  getSizeAndScale(step, realOutputSize, scale) {\n    // xstep / ystep may be negative -- normalize.\n    step = Math.abs(step);\n    // MAX_PATTERN_SIZE is used to avoid OOM situation.\n    // Use the destination canvas's size if it is bigger than the hard-coded\n    // limit of MAX_PATTERN_SIZE to avoid clipping patterns that cover the\n    // whole canvas.\n    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n    let size = Math.ceil(step * scale);\n    if (size >= maxSize) {\n      size = maxSize;\n    } else {\n      scale = size / step;\n    }\n    return { scale, size };\n  }\n\n  clipBbox(graphics, x0, y0, x1, y1) {\n    const bboxWidth = x1 - x0;\n    const bboxHeight = y1 - y0;\n    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n    graphics.clip();\n    graphics.endPath();\n  }\n\n  setFillAndStrokeStyleToContext(graphics, paintType, color) {\n    const context = graphics.ctx,\n      current = graphics.current;\n    switch (paintType) {\n      case PaintType.COLORED:\n        const ctx = this.ctx;\n        context.fillStyle = ctx.fillStyle;\n        context.strokeStyle = ctx.strokeStyle;\n        current.fillColor = ctx.fillStyle;\n        current.strokeColor = ctx.strokeStyle;\n        break;\n      case PaintType.UNCOLORED:\n        const cssColor = Util.makeHexColor(color[0], color[1], color[2]);\n        context.fillStyle = cssColor;\n        context.strokeStyle = cssColor;\n        // Set color needed by image masks (fixes issues 3226 and 8741).\n        current.fillColor = cssColor;\n        current.strokeColor = cssColor;\n        break;\n      default:\n        throw new FormatError(`Unsupported paint type: ${paintType}`);\n    }\n  }\n\n  getPattern(ctx, owner, inverse, pathType) {\n    // PDF spec 8.7.2 NOTE 1: pattern's matrix is relative to initial matrix.\n    let matrix = inverse;\n    if (pathType !== PathType.SHADING) {\n      matrix = Util.transform(matrix, owner.baseTransform);\n      if (this.matrix) {\n        matrix = Util.transform(matrix, this.matrix);\n      }\n    }\n\n    const temporaryPatternCanvas = this.createPatternCanvas(owner);\n\n    let domMatrix = new DOMMatrix(matrix);\n    // Rescale and so that the ctx.createPattern call generates a pattern with\n    // the desired size.\n    domMatrix = domMatrix.translate(\n      temporaryPatternCanvas.offsetX,\n      temporaryPatternCanvas.offsetY\n    );\n    domMatrix = domMatrix.scale(\n      1 / temporaryPatternCanvas.scaleX,\n      1 / temporaryPatternCanvas.scaleY\n    );\n\n    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n    try {\n      pattern.setTransform(domMatrix);\n    } catch (ex) {\n      // Avoid rendering breaking completely in Firefox 78 ESR,\n      // and in Node.js (see issue 13724).\n      warn(`TilingPattern.getPattern: \"${ex?.message}\".`);\n    }\n    return pattern;\n  }\n}\n\nexport { getShadingPattern, PathType, TilingPattern };\n","/* Copyright 2018 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @typedef {Object} GlobalWorkerOptionsType\n * @property {Worker | null} workerPort - Defines global port for worker\n *   process. Overrides the `workerSrc` option.\n * @property {string} workerSrc - A string containing the path and filename\n *   of the worker file.\n *\n *   NOTE: The `workerSrc` option should always be set, in order to prevent any\n *         issues when using the PDF.js library.\n */\n\n/** @type {GlobalWorkerOptionsType} */\nconst GlobalWorkerOptions = Object.create(null);\n\nGlobalWorkerOptions.workerPort =\n  GlobalWorkerOptions.workerPort === undefined\n    ? null\n    : GlobalWorkerOptions.workerPort;\n\nGlobalWorkerOptions.workerSrc =\n  GlobalWorkerOptions.workerSrc === undefined\n    ? \"\"\n    : GlobalWorkerOptions.workerSrc;\n\nexport { GlobalWorkerOptions };\n","/* Copyright 2018 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbortException,\n  assert,\n  createPromiseCapability,\n  MissingPDFException,\n  PasswordException,\n  UnexpectedResponseException,\n  UnknownErrorException,\n  warn,\n} from \"./util.js\";\n\nconst CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2,\n};\n\nconst StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8,\n};\n\nfunction wrapReason(reason) {\n  if (\n    !(\n      reason instanceof Error ||\n      (typeof reason === \"object\" && reason !== null)\n    )\n  ) {\n    if (\n      typeof PDFJSDev === \"undefined\" ||\n      PDFJSDev.test(\"!PRODUCTION || TESTING\")\n    ) {\n      throw new Error(\n        'wrapReason: Expected \"reason\" to be a (possibly cloned) Error.'\n      );\n    }\n    warn('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n    return reason;\n  }\n  switch (reason.name) {\n    case \"AbortException\":\n      return new AbortException(reason.message);\n    case \"MissingPDFException\":\n      return new MissingPDFException(reason.message);\n    case \"PasswordException\":\n      return new PasswordException(reason.message, reason.code);\n    case \"UnexpectedResponseException\":\n      return new UnexpectedResponseException(reason.message, reason.status);\n    case \"UnknownErrorException\":\n      return new UnknownErrorException(reason.message, reason.details);\n    default:\n      return new UnknownErrorException(reason.message, reason.toString());\n  }\n}\n\nclass MessageHandler {\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n\n    this._onComObjOnMessage = event => {\n      const data = event.data;\n      if (data.targetName !== this.sourceName) {\n        return;\n      }\n      if (data.stream) {\n        this._processStreamMessage(data);\n        return;\n      }\n      if (data.callback) {\n        const callbackId = data.callbackId;\n        const capability = this.callbackCapabilities[callbackId];\n        if (!capability) {\n          throw new Error(`Cannot resolve callback ${callbackId}`);\n        }\n        delete this.callbackCapabilities[callbackId];\n\n        if (data.callback === CallbackKind.DATA) {\n          capability.resolve(data.data);\n        } else if (data.callback === CallbackKind.ERROR) {\n          capability.reject(wrapReason(data.reason));\n        } else {\n          throw new Error(\"Unexpected callback case\");\n        }\n        return;\n      }\n      const action = this.actionHandler[data.action];\n      if (!action) {\n        throw new Error(`Unknown action from worker: ${data.action}`);\n      }\n      if (data.callbackId) {\n        const cbSourceName = this.sourceName;\n        const cbTargetName = data.sourceName;\n\n        new Promise(function (resolve) {\n          resolve(action(data.data));\n        }).then(\n          function (result) {\n            comObj.postMessage({\n              sourceName: cbSourceName,\n              targetName: cbTargetName,\n              callback: CallbackKind.DATA,\n              callbackId: data.callbackId,\n              data: result,\n            });\n          },\n          function (reason) {\n            comObj.postMessage({\n              sourceName: cbSourceName,\n              targetName: cbTargetName,\n              callback: CallbackKind.ERROR,\n              callbackId: data.callbackId,\n              reason: wrapReason(reason),\n            });\n          }\n        );\n        return;\n      }\n      if (data.streamId) {\n        this._createStreamSink(data);\n        return;\n      }\n      action(data.data);\n    };\n    comObj.addEventListener(\"message\", this._onComObjOnMessage);\n  }\n\n  on(actionName, handler) {\n    if (\n      typeof PDFJSDev === \"undefined\" ||\n      PDFJSDev.test(\"!PRODUCTION || TESTING\")\n    ) {\n      assert(\n        typeof handler === \"function\",\n        'MessageHandler.on: Expected \"handler\" to be a function.'\n      );\n    }\n    const ah = this.actionHandler;\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\n    }\n    ah[actionName] = handler;\n  }\n\n  /**\n   * Sends a message to the comObj to invoke the action with the supplied data.\n   * @param {string} actionName - Action to call.\n   * @param {JSON} data - JSON data to send.\n   * @param {Array} [transfers] - List of transfers/ArrayBuffers.\n   */\n  send(actionName, data, transfers) {\n    this.comObj.postMessage(\n      {\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        data,\n      },\n      transfers\n    );\n  }\n\n  /**\n   * Sends a message to the comObj to invoke the action with the supplied data.\n   * Expects that the other side will callback with the response.\n   * @param {string} actionName - Action to call.\n   * @param {JSON} data - JSON data to send.\n   * @param {Array} [transfers] - List of transfers/ArrayBuffers.\n   * @returns {Promise} Promise to be resolved with response data.\n   */\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = createPromiseCapability();\n    this.callbackCapabilities[callbackId] = capability;\n    try {\n      this.comObj.postMessage(\n        {\n          sourceName: this.sourceName,\n          targetName: this.targetName,\n          action: actionName,\n          callbackId,\n          data,\n        },\n        transfers\n      );\n    } catch (ex) {\n      capability.reject(ex);\n    }\n    return capability.promise;\n  }\n\n  /**\n   * Sends a message to the comObj to invoke the action with the supplied data.\n   * Expect that the other side will callback to signal 'start_complete'.\n   * @param {string} actionName - Action to call.\n   * @param {JSON} data - JSON data to send.\n   * @param {Object} queueingStrategy - Strategy to signal backpressure based on\n   *                 internal queue.\n   * @param {Array} [transfers] - List of transfers/ArrayBuffers.\n   * @returns {ReadableStream} ReadableStream to read data in chunks.\n   */\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++,\n      sourceName = this.sourceName,\n      targetName = this.targetName,\n      comObj = this.comObj;\n\n    return new ReadableStream(\n      {\n        start: controller => {\n          const startCapability = createPromiseCapability();\n          this.streamControllers[streamId] = {\n            controller,\n            startCall: startCapability,\n            pullCall: null,\n            cancelCall: null,\n            isClosed: false,\n          };\n          comObj.postMessage(\n            {\n              sourceName,\n              targetName,\n              action: actionName,\n              streamId,\n              data,\n              desiredSize: controller.desiredSize,\n            },\n            transfers\n          );\n          // Return Promise for Async process, to signal success/failure.\n          return startCapability.promise;\n        },\n\n        pull: controller => {\n          const pullCapability = createPromiseCapability();\n          this.streamControllers[streamId].pullCall = pullCapability;\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL,\n            streamId,\n            desiredSize: controller.desiredSize,\n          });\n          // Returning Promise will not call \"pull\"\n          // again until current pull is resolved.\n          return pullCapability.promise;\n        },\n\n        cancel: reason => {\n          assert(reason instanceof Error, \"cancel must have a valid reason\");\n          const cancelCapability = createPromiseCapability();\n          this.streamControllers[streamId].cancelCall = cancelCapability;\n          this.streamControllers[streamId].isClosed = true;\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL,\n            streamId,\n            reason: wrapReason(reason),\n          });\n          // Return Promise to signal success or failure.\n          return cancelCapability.promise;\n        },\n      },\n      queueingStrategy\n    );\n  }\n\n  /**\n   * @private\n   */\n  _createStreamSink(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const self = this,\n      action = this.actionHandler[data.action];\n\n    const streamSink = {\n      enqueue(chunk, size = 1, transfers) {\n        if (this.isCancelled) {\n          return;\n        }\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n        // Enqueue decreases the desiredSize property of sink,\n        // so when it changes from positive to negative,\n        // set ready as unresolved promise.\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = createPromiseCapability();\n          this.ready = this.sinkCapability.promise;\n        }\n        comObj.postMessage(\n          {\n            sourceName,\n            targetName,\n            stream: StreamKind.ENQUEUE,\n            streamId,\n            chunk,\n          },\n          transfers\n        );\n      },\n\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId,\n        });\n        delete self.streamSinks[streamId];\n      },\n\n      error(reason) {\n        assert(reason instanceof Error, \"error must have a valid reason\");\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason),\n        });\n      },\n\n      sinkCapability: createPromiseCapability(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null,\n    };\n\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n\n    new Promise(function (resolve) {\n      resolve(action(data.data, streamSink));\n    }).then(\n      function () {\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.START_COMPLETE,\n          streamId,\n          success: true,\n        });\n      },\n      function (reason) {\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.START_COMPLETE,\n          streamId,\n          reason: wrapReason(reason),\n        });\n      }\n    );\n  }\n\n  /**\n   * @private\n   */\n  _processStreamMessage(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const streamController = this.streamControllers[streamId],\n      streamSink = this.streamSinks[streamId];\n\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          streamController.startCall.resolve();\n        } else {\n          streamController.startCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          streamController.pullCall.resolve();\n        } else {\n          streamController.pullCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL:\n        // Ignore any pull after close is called.\n        if (!streamSink) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true,\n          });\n          break;\n        }\n        // Pull increases the desiredSize property of sink, so when it changes\n        // from negative to positive, set ready property as resolved promise.\n        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n          streamSink.sinkCapability.resolve();\n        }\n        // Reset desiredSize property of sink on every pull.\n        streamSink.desiredSize = data.desiredSize;\n\n        new Promise(function (resolve) {\n          resolve(streamSink.onPull && streamSink.onPull());\n        }).then(\n          function () {\n            comObj.postMessage({\n              sourceName,\n              targetName,\n              stream: StreamKind.PULL_COMPLETE,\n              streamId,\n              success: true,\n            });\n          },\n          function (reason) {\n            comObj.postMessage({\n              sourceName,\n              targetName,\n              stream: StreamKind.PULL_COMPLETE,\n              streamId,\n              reason: wrapReason(reason),\n            });\n          }\n        );\n        break;\n      case StreamKind.ENQUEUE:\n        assert(streamController, \"enqueue should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.controller.enqueue(data.chunk);\n        break;\n      case StreamKind.CLOSE:\n        assert(streamController, \"close should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.isClosed = true;\n        streamController.controller.close();\n        this._deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.ERROR:\n        assert(streamController, \"error should have stream controller\");\n        streamController.controller.error(wrapReason(data.reason));\n        this._deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          streamController.cancelCall.resolve();\n        } else {\n          streamController.cancelCall.reject(wrapReason(data.reason));\n        }\n        this._deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL:\n        if (!streamSink) {\n          break;\n        }\n\n        new Promise(function (resolve) {\n          resolve(\n            streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason))\n          );\n        }).then(\n          function () {\n            comObj.postMessage({\n              sourceName,\n              targetName,\n              stream: StreamKind.CANCEL_COMPLETE,\n              streamId,\n              success: true,\n            });\n          },\n          function (reason) {\n            comObj.postMessage({\n              sourceName,\n              targetName,\n              stream: StreamKind.CANCEL_COMPLETE,\n              streamId,\n              reason: wrapReason(reason),\n            });\n          }\n        );\n        streamSink.sinkCapability.reject(wrapReason(data.reason));\n        streamSink.isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n\n  /**\n   * @private\n   */\n  async _deleteStreamController(streamController, streamId) {\n    // Delete the `streamController` only when the start, pull, and cancel\n    // capabilities have settled, to prevent `TypeError`s.\n    await Promise.allSettled([\n      streamController.startCall && streamController.startCall.promise,\n      streamController.pullCall && streamController.pullCall.promise,\n      streamController.cancelCall && streamController.cancelCall.promise,\n    ]);\n    delete this.streamControllers[streamId];\n  }\n\n  destroy() {\n    this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n  }\n}\n\nexport { MessageHandler };\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { objectFromMap } from \"../shared/util.js\";\n\nclass Metadata {\n  #metadataMap;\n\n  #data;\n\n  constructor({ parsedData, rawData }) {\n    this.#metadataMap = parsedData;\n    this.#data = rawData;\n  }\n\n  getRaw() {\n    return this.#data;\n  }\n\n  get(name) {\n    return this.#metadataMap.get(name) ?? null;\n  }\n\n  getAll() {\n    return objectFromMap(this.#metadataMap);\n  }\n\n  has(name) {\n    return this.#metadataMap.has(name);\n  }\n}\n\nexport { Metadata };\n","/* Copyright 2020 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { objectFromMap, warn } from \"../shared/util.js\";\n\nclass OptionalContentGroup {\n  constructor(name, intent) {\n    this.visible = true;\n    this.name = name;\n    this.intent = intent;\n  }\n}\n\nclass OptionalContentConfig {\n  constructor(data) {\n    this.name = null;\n    this.creator = null;\n    this._order = null;\n    this._groups = new Map();\n\n    if (data === null) {\n      return;\n    }\n    this.name = data.name;\n    this.creator = data.creator;\n    this._order = data.order;\n    for (const group of data.groups) {\n      this._groups.set(\n        group.id,\n        new OptionalContentGroup(group.name, group.intent)\n      );\n    }\n\n    if (data.baseState === \"OFF\") {\n      for (const group of this._groups) {\n        group.visible = false;\n      }\n    }\n\n    for (const on of data.on) {\n      this._groups.get(on).visible = true;\n    }\n\n    for (const off of data.off) {\n      this._groups.get(off).visible = false;\n    }\n  }\n\n  _evaluateVisibilityExpression(array) {\n    const length = array.length;\n    if (length < 2) {\n      return true;\n    }\n    const operator = array[0];\n    for (let i = 1; i < length; i++) {\n      const element = array[i];\n      let state;\n      if (Array.isArray(element)) {\n        state = this._evaluateVisibilityExpression(element);\n      } else if (this._groups.has(element)) {\n        state = this._groups.get(element).visible;\n      } else {\n        warn(`Optional content group not found: ${element}`);\n        return true;\n      }\n      switch (operator) {\n        case \"And\":\n          if (!state) {\n            return false;\n          }\n          break;\n        case \"Or\":\n          if (state) {\n            return true;\n          }\n          break;\n        case \"Not\":\n          return !state;\n        default:\n          return true;\n      }\n    }\n    return operator === \"And\";\n  }\n\n  isVisible(group) {\n    if (this._groups.size === 0) {\n      return true;\n    }\n    if (!group) {\n      warn(\"Optional content group not defined.\");\n      return true;\n    }\n    if (group.type === \"OCG\") {\n      if (!this._groups.has(group.id)) {\n        warn(`Optional content group not found: ${group.id}`);\n        return true;\n      }\n      return this._groups.get(group.id).visible;\n    } else if (group.type === \"OCMD\") {\n      // Per the spec, the expression should be preferred if available.\n      if (group.expression) {\n        return this._evaluateVisibilityExpression(group.expression);\n      }\n      if (!group.policy || group.policy === \"AnyOn\") {\n        // Default\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this._groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOn\") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this._groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      } else if (group.policy === \"AnyOff\") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this._groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOff\") {\n        for (const id of group.ids) {\n          if (!this._groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this._groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      }\n      warn(`Unknown optional content policy ${group.policy}.`);\n      return true;\n    }\n    warn(`Unknown group type ${group.type}.`);\n    return true;\n  }\n\n  setVisibility(id, visible = true) {\n    if (!this._groups.has(id)) {\n      warn(`Optional content group not found: ${id}`);\n      return;\n    }\n    this._groups.get(id).visible = !!visible;\n  }\n\n  getOrder() {\n    if (!this._groups.size) {\n      return null;\n    }\n    if (this._order) {\n      return this._order.slice();\n    }\n    return Array.from(this._groups.keys());\n  }\n\n  getGroups() {\n    return this._groups.size > 0 ? objectFromMap(this._groups) : null;\n  }\n\n  getGroup(id) {\n    return this._groups.get(id) || null;\n  }\n}\n\nexport { OptionalContentConfig };\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, createPromiseCapability } from \"../shared/util.js\";\nimport { isPdfFile } from \"./display_utils.js\";\n\n/** @implements {IPDFStream} */\nclass PDFDataTransportStream {\n  constructor(params, pdfDataRangeTransport) {\n    assert(\n      pdfDataRangeTransport,\n      'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.'\n    );\n\n    this._queuedChunks = [];\n    this._progressiveDone = params.progressiveDone || false;\n    this._contentDispositionFilename =\n      params.contentDispositionFilename || null;\n\n    const initialData = params.initialData;\n    if (initialData?.length > 0) {\n      const buffer = new Uint8Array(initialData).buffer;\n      this._queuedChunks.push(buffer);\n    }\n\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !params.disableStream;\n    this._isRangeSupported = !params.disableRange;\n    this._contentLength = params.length;\n\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n\n    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n      this._onReceiveData({ begin, chunk });\n    });\n\n    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {\n      this._onProgress({ loaded, total });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n      this._onReceiveData({ chunk });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {\n      this._onProgressiveDone();\n    });\n\n    this._pdfDataRangeTransport.transportReady();\n  }\n\n  _onReceiveData(args) {\n    const buffer = new Uint8Array(args.chunk).buffer;\n    if (args.begin === undefined) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader._enqueue(buffer);\n      } else {\n        this._queuedChunks.push(buffer);\n      }\n    } else {\n      const found = this._rangeReaders.some(function (rangeReader) {\n        if (rangeReader._begin !== args.begin) {\n          return false;\n        }\n        rangeReader._enqueue(buffer);\n        return true;\n      });\n      assert(\n        found,\n        \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\"\n      );\n    }\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  _onProgress(evt) {\n    if (evt.total === undefined) {\n      // Reporting to first range reader, if it exists.\n      const firstReader = this._rangeReaders[0];\n      if (firstReader?.onProgress) {\n        firstReader.onProgress({ loaded: evt.loaded });\n      }\n    } else {\n      const fullReader = this._fullRequestReader;\n      if (fullReader?.onProgress) {\n        fullReader.onProgress({ loaded: evt.loaded, total: evt.total });\n      }\n    }\n  }\n\n  _onProgressiveDone() {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.progressiveDone();\n    }\n    this._progressiveDone = true;\n  }\n\n  _removeRangeReader(reader) {\n    const i = this._rangeReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    assert(\n      !this._fullRequestReader,\n      \"PDFDataTransportStream.getFullReader can only be called once.\"\n    );\n    const queuedChunks = this._queuedChunks;\n    this._queuedChunks = null;\n    return new PDFDataTransportStreamReader(\n      this,\n      queuedChunks,\n      this._progressiveDone,\n      this._contentDispositionFilename\n    );\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\n    this._rangeReaders.push(reader);\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n    for (const reader of this._rangeReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n    this._pdfDataRangeTransport.abort();\n  }\n}\n\n/** @implements {IPDFStreamReader} */\nclass PDFDataTransportStreamReader {\n  constructor(\n    stream,\n    queuedChunks,\n    progressiveDone = false,\n    contentDispositionFilename = null\n  ) {\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = isPdfFile(contentDispositionFilename)\n      ? contentDispositionFilename\n      : null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n    for (const chunk of this._queuedChunks) {\n      this._loaded += chunk.byteLength;\n    }\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return; // Ignore new data.\n    }\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({ value: chunk, done: false });\n    } else {\n      this._queuedChunks.push(chunk);\n    }\n    this._loaded += chunk.byteLength;\n  }\n\n  get headersReady() {\n    return this._headersReady;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._stream._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._stream._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._stream._contentLength;\n  }\n\n  async read() {\n    if (this._queuedChunks.length > 0) {\n      const chunk = this._queuedChunks.shift();\n      return { value: chunk, done: false };\n    }\n    if (this._done) {\n      return { value: undefined, done: true };\n    }\n    const requestCapability = createPromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({ value: undefined, done: true });\n    }\n    this._requests.length = 0;\n  }\n\n  progressiveDone() {\n    if (this._done) {\n      return;\n    }\n    this._done = true;\n  }\n}\n\n/** @implements {IPDFStreamRangeReader} */\nclass PDFDataTransportStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n\n    this.onProgress = null;\n  }\n\n  _enqueue(chunk) {\n    if (this._done) {\n      return; // ignore new data\n    }\n    if (this._requests.length === 0) {\n      this._queuedChunk = chunk;\n    } else {\n      const requestsCapability = this._requests.shift();\n      requestsCapability.resolve({ value: chunk, done: false });\n      for (const requestCapability of this._requests) {\n        requestCapability.resolve({ value: undefined, done: true });\n      }\n      this._requests.length = 0;\n    }\n    this._done = true;\n    this._stream._removeRangeReader(this);\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._queuedChunk) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return { value: chunk, done: false };\n    }\n    if (this._done) {\n      return { value: undefined, done: true };\n    }\n    const requestCapability = createPromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({ value: undefined, done: true });\n    }\n    this._requests.length = 0;\n    this._stream._removeRangeReader(this);\n  }\n}\n\nexport { PDFDataTransportStream };\n","/* Copyright 2021 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nclass XfaText {\n  /**\n   * Walk an XFA tree and create an array of text nodes that is compatible\n   * with a regular PDFs TextContent. Currently, only TextItem.str is supported,\n   * all other fields and styles haven't been implemented.\n   *\n   * @param {Object} xfa - An XFA fake DOM object.\n   *\n   * @returns {TextContent}\n   */\n  static textContent(xfa) {\n    const items = [];\n    const output = {\n      items,\n      styles: Object.create(null),\n    };\n    function walk(node) {\n      if (!node) {\n        return;\n      }\n      let str = null;\n      const name = node.name;\n      if (name === \"#text\") {\n        str = node.value;\n      } else if (!XfaText.shouldBuildText(name)) {\n        return;\n      } else if (node?.attributes?.textContent) {\n        str = node.attributes.textContent;\n      } else if (node.value) {\n        str = node.value;\n      }\n      if (str !== null) {\n        items.push({\n          str,\n        });\n      }\n      if (!node.children) {\n        return;\n      }\n      for (const child of node.children) {\n        walk(child);\n      }\n    }\n    walk(xfa);\n    return output;\n  }\n\n  /**\n   * @param {string} name - DOM node name. (lower case)\n   *\n   * @returns {boolean} true if the DOM node should have a corresponding text\n   * node.\n   */\n  static shouldBuildText(name) {\n    return !(\n      name === \"textarea\" ||\n      name === \"input\" ||\n      name === \"option\" ||\n      name === \"select\"\n    );\n  }\n}\n\nexport { XfaText };\n","/* Copyright 2014 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @typedef {import(\"./api\").PDFPageProxy} PDFPageProxy */\n/** @typedef {import(\"./display_utils\").PageViewport} PageViewport */\n/** @typedef {import(\"./interfaces\").IDownloadManager} IDownloadManager */\n/** @typedef {import(\"../../web/interfaces\").IPDFLinkService} IPDFLinkService */\n\nimport {\n  AnnotationBorderStyleType,\n  AnnotationType,\n  assert,\n  shadow,\n  stringToPDFString,\n  unreachable,\n  Util,\n  warn,\n} from \"../shared/util.js\";\nimport {\n  DOMSVGFactory,\n  getFilenameFromUrl,\n  PDFDateString,\n} from \"./display_utils.js\";\nimport { AnnotationStorage } from \"./annotation_storage.js\";\nimport { ColorConverters } from \"../shared/scripting_utils.js\";\nimport { XfaLayer } from \"./xfa_layer.js\";\n\nconst DEFAULT_TAB_INDEX = 1000;\nconst GetElementsByNameSet = new WeakSet();\n\n/**\n * @typedef {Object} AnnotationElementParameters\n * @property {Object} data\n * @property {HTMLDivElement} layer\n * @property {PDFPageProxy} page\n * @property {PageViewport} viewport\n * @property {IPDFLinkService} linkService\n * @property {IDownloadManager} downloadManager\n * @property {AnnotationStorage} [annotationStorage]\n * @property {string} [imageResourcesPath] - Path for image resources, mainly\n *   for annotation icons. Include trailing slash.\n * @property {boolean} renderForms\n * @property {Object} svgFactory\n * @property {boolean} [enableScripting]\n * @property {boolean} [hasJSActions]\n * @property {Object} [fieldObjects]\n * @property {Object} [mouseState]\n */\n\nclass AnnotationElementFactory {\n  /**\n   * @param {AnnotationElementParameters} parameters\n   * @returns {AnnotationElement}\n   */\n  static create(parameters) {\n    const subtype = parameters.data.annotationType;\n\n    switch (subtype) {\n      case AnnotationType.LINK:\n        return new LinkAnnotationElement(parameters);\n\n      case AnnotationType.TEXT:\n        return new TextAnnotationElement(parameters);\n\n      case AnnotationType.WIDGET:\n        const fieldType = parameters.data.fieldType;\n\n        switch (fieldType) {\n          case \"Tx\":\n            return new TextWidgetAnnotationElement(parameters);\n          case \"Btn\":\n            if (parameters.data.radioButton) {\n              return new RadioButtonWidgetAnnotationElement(parameters);\n            } else if (parameters.data.checkBox) {\n              return new CheckboxWidgetAnnotationElement(parameters);\n            }\n            return new PushButtonWidgetAnnotationElement(parameters);\n          case \"Ch\":\n            return new ChoiceWidgetAnnotationElement(parameters);\n        }\n        return new WidgetAnnotationElement(parameters);\n\n      case AnnotationType.POPUP:\n        return new PopupAnnotationElement(parameters);\n\n      case AnnotationType.FREETEXT:\n        return new FreeTextAnnotationElement(parameters);\n\n      case AnnotationType.LINE:\n        return new LineAnnotationElement(parameters);\n\n      case AnnotationType.SQUARE:\n        return new SquareAnnotationElement(parameters);\n\n      case AnnotationType.CIRCLE:\n        return new CircleAnnotationElement(parameters);\n\n      case AnnotationType.POLYLINE:\n        return new PolylineAnnotationElement(parameters);\n\n      case AnnotationType.CARET:\n        return new CaretAnnotationElement(parameters);\n\n      case AnnotationType.INK:\n        return new InkAnnotationElement(parameters);\n\n      case AnnotationType.POLYGON:\n        return new PolygonAnnotationElement(parameters);\n\n      case AnnotationType.HIGHLIGHT:\n        return new HighlightAnnotationElement(parameters);\n\n      case AnnotationType.UNDERLINE:\n        return new UnderlineAnnotationElement(parameters);\n\n      case AnnotationType.SQUIGGLY:\n        return new SquigglyAnnotationElement(parameters);\n\n      case AnnotationType.STRIKEOUT:\n        return new StrikeOutAnnotationElement(parameters);\n\n      case AnnotationType.STAMP:\n        return new StampAnnotationElement(parameters);\n\n      case AnnotationType.FILEATTACHMENT:\n        return new FileAttachmentAnnotationElement(parameters);\n\n      default:\n        return new AnnotationElement(parameters);\n    }\n  }\n}\n\nclass AnnotationElement {\n  constructor(\n    parameters,\n    {\n      isRenderable = false,\n      ignoreBorder = false,\n      createQuadrilaterals = false,\n    } = {}\n  ) {\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.page = parameters.page;\n    this.viewport = parameters.viewport;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderForms = parameters.renderForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n    this.enableScripting = parameters.enableScripting;\n    this.hasJSActions = parameters.hasJSActions;\n    this._fieldObjects = parameters.fieldObjects;\n    this._mouseState = parameters.mouseState;\n\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n    if (createQuadrilaterals) {\n      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);\n    }\n  }\n\n  /**\n   * Create an empty container for the annotation's HTML element.\n   *\n   * @private\n   * @param {boolean} ignoreBorder\n   * @memberof AnnotationElement\n   * @returns {HTMLSectionElement}\n   */\n  _createContainer(ignoreBorder = false) {\n    const data = this.data,\n      page = this.page,\n      viewport = this.viewport;\n    const container = document.createElement(\"section\");\n    let width = data.rect[2] - data.rect[0];\n    let height = data.rect[3] - data.rect[1];\n\n    container.setAttribute(\"data-annotation-id\", data.id);\n\n    // Do *not* modify `data.rect`, since that will corrupt the annotation\n    // position on subsequent calls to `_createContainer` (see issue 6804).\n    const rect = Util.normalizeRect([\n      data.rect[0],\n      page.view[3] - data.rect[1] + page.view[1],\n      data.rect[2],\n      page.view[3] - data.rect[3] + page.view[1],\n    ]);\n\n    if (data.hasOwnCanvas) {\n      const transform = viewport.transform.slice();\n      const [scaleX, scaleY] = Util.singularValueDecompose2dScale(transform);\n      width = Math.ceil(width * scaleX);\n      height = Math.ceil(height * scaleY);\n      rect[0] *= scaleX;\n      rect[1] *= scaleY;\n      // Reset the scale part of the transform matrix (which must be diagonal\n      // or anti-diagonal) in order to avoid to rescale the canvas.\n      // The canvas for the annotation is correctly scaled when it is drawn\n      // (see `beginAnnotation` in canvas.js).\n      for (let i = 0; i < 4; i++) {\n        transform[i] = Math.sign(transform[i]);\n      }\n      container.style.transform = `matrix(${transform.join(\",\")})`;\n    } else {\n      container.style.transform = `matrix(${viewport.transform.join(\",\")})`;\n    }\n\n    container.style.transformOrigin = `${-rect[0]}px ${-rect[1]}px`;\n\n    if (!ignoreBorder && data.borderStyle.width > 0) {\n      container.style.borderWidth = `${data.borderStyle.width}px`;\n      if (data.borderStyle.style !== AnnotationBorderStyleType.UNDERLINE) {\n        // Underline styles only have a bottom border, so we do not need\n        // to adjust for all borders. This yields a similar result as\n        // Adobe Acrobat/Reader.\n        width -= 2 * data.borderStyle.width;\n        height -= 2 * data.borderStyle.width;\n      }\n\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\n      if (horizontalRadius > 0 || verticalRadius > 0) {\n        const radius = `${horizontalRadius}px / ${verticalRadius}px`;\n        container.style.borderRadius = radius;\n      }\n\n      switch (data.borderStyle.style) {\n        case AnnotationBorderStyleType.SOLID:\n          container.style.borderStyle = \"solid\";\n          break;\n\n        case AnnotationBorderStyleType.DASHED:\n          container.style.borderStyle = \"dashed\";\n          break;\n\n        case AnnotationBorderStyleType.BEVELED:\n          warn(\"Unimplemented border style: beveled\");\n          break;\n\n        case AnnotationBorderStyleType.INSET:\n          warn(\"Unimplemented border style: inset\");\n          break;\n\n        case AnnotationBorderStyleType.UNDERLINE:\n          container.style.borderBottomStyle = \"solid\";\n          break;\n\n        default:\n          break;\n      }\n\n      const borderColor = data.borderColor || data.color || null;\n      if (borderColor) {\n        container.style.borderColor = Util.makeHexColor(\n          data.color[0] | 0,\n          data.color[1] | 0,\n          data.color[2] | 0\n        );\n      } else {\n        // Transparent (invisible) border, so do not draw it at all.\n        container.style.borderWidth = 0;\n      }\n    }\n\n    container.style.left = `${rect[0]}px`;\n    container.style.top = `${rect[1]}px`;\n\n    if (data.hasOwnCanvas) {\n      container.style.width = container.style.height = \"auto\";\n    } else {\n      container.style.width = `${width}px`;\n      container.style.height = `${height}px`;\n    }\n    return container;\n  }\n\n  /**\n   * Create quadrilaterals from the annotation's quadpoints.\n   *\n   * @private\n   * @param {boolean} ignoreBorder\n   * @memberof AnnotationElement\n   * @returns {Array<HTMLSectionElement>}\n   */\n  _createQuadrilaterals(ignoreBorder = false) {\n    if (!this.data.quadPoints) {\n      return null;\n    }\n\n    const quadrilaterals = [];\n    const savedRect = this.data.rect;\n    for (const quadPoint of this.data.quadPoints) {\n      this.data.rect = [\n        quadPoint[2].x,\n        quadPoint[2].y,\n        quadPoint[1].x,\n        quadPoint[1].y,\n      ];\n      quadrilaterals.push(this._createContainer(ignoreBorder));\n    }\n    this.data.rect = savedRect;\n    return quadrilaterals;\n  }\n\n  /**\n   * Create a popup for the annotation's HTML element. This is used for\n   * annotations that do not have a Popup entry in the dictionary, but\n   * are of a type that works with popups (such as Highlight annotations).\n   *\n   * @private\n   * @param {HTMLDivElement|HTMLImageElement|null} trigger\n   * @param {Object} data\n   * @memberof AnnotationElement\n   */\n  _createPopup(trigger, data) {\n    let container = this.container;\n    if (this.quadrilaterals) {\n      trigger = trigger || this.quadrilaterals;\n      container = this.quadrilaterals[0];\n    }\n\n    // If no trigger element is specified, create it.\n    if (!trigger) {\n      trigger = document.createElement(\"div\");\n      trigger.style.height = container.style.height;\n      trigger.style.width = container.style.width;\n      container.appendChild(trigger);\n    }\n\n    const popupElement = new PopupElement({\n      container,\n      trigger,\n      color: data.color,\n      titleObj: data.titleObj,\n      modificationDate: data.modificationDate,\n      contentsObj: data.contentsObj,\n      richText: data.richText,\n      hideWrapper: true,\n    });\n    const popup = popupElement.render();\n\n    // Position the popup next to the annotation's container.\n    popup.style.left = container.style.width;\n\n    container.appendChild(popup);\n  }\n\n  /**\n   * Render the quadrilaterals of the annotation.\n   *\n   * @private\n   * @param {string} className\n   * @memberof AnnotationElement\n   * @returns {Array<HTMLSectionElement>}\n   */\n  _renderQuadrilaterals(className) {\n    if (\n      typeof PDFJSDev === \"undefined\" ||\n      PDFJSDev.test(\"!PRODUCTION || TESTING\")\n    ) {\n      assert(this.quadrilaterals, \"Missing quadrilaterals during rendering\");\n    }\n\n    for (const quadrilateral of this.quadrilaterals) {\n      quadrilateral.className = className;\n    }\n    return this.quadrilaterals;\n  }\n\n  /**\n   * Render the annotation's HTML element(s).\n   *\n   * @public\n   * @memberof AnnotationElement\n   * @returns {HTMLSectionElement|Array<HTMLSectionElement>}\n   */\n  render() {\n    unreachable(\"Abstract method `AnnotationElement.render` called\");\n  }\n\n  /**\n   * @private\n   * @returns {Array}\n   */\n  _getElementsByName(name, skipId = null) {\n    const fields = [];\n\n    if (this._fieldObjects) {\n      const fieldObj = this._fieldObjects[name];\n      if (fieldObj) {\n        for (const { page, id, exportValues } of fieldObj) {\n          if (page === -1) {\n            continue;\n          }\n          if (id === skipId) {\n            continue;\n          }\n          const exportValue =\n            typeof exportValues === \"string\" ? exportValues : null;\n\n          const domElement = document.getElementById(id);\n          if (domElement && !GetElementsByNameSet.has(domElement)) {\n            warn(`_getElementsByName - element not allowed: ${id}`);\n            continue;\n          }\n          fields.push({ id, exportValue, domElement });\n        }\n      }\n      return fields;\n    }\n    // Fallback to a regular DOM lookup, to ensure that the standalone\n    // viewer components won't break.\n    for (const domElement of document.getElementsByName(name)) {\n      const { id, exportValue } = domElement;\n      if (id === skipId) {\n        continue;\n      }\n      if (!GetElementsByNameSet.has(domElement)) {\n        continue;\n      }\n      fields.push({ id, exportValue, domElement });\n    }\n    return fields;\n  }\n\n  static get platform() {\n    const platform = typeof navigator !== \"undefined\" ? navigator.platform : \"\";\n\n    return shadow(this, \"platform\", {\n      isWin: platform.includes(\"Win\"),\n      isMac: platform.includes(\"Mac\"),\n    });\n  }\n}\n\nclass LinkAnnotationElement extends AnnotationElement {\n  constructor(parameters, options = null) {\n    const isRenderable = !!(\n      parameters.data.url ||\n      parameters.data.dest ||\n      parameters.data.action ||\n      parameters.data.isTooltipOnly ||\n      parameters.data.resetForm ||\n      (parameters.data.actions &&\n        (parameters.data.actions.Action ||\n          parameters.data.actions[\"Mouse Up\"] ||\n          parameters.data.actions[\"Mouse Down\"]))\n    );\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: !!options?.ignoreBorder,\n      createQuadrilaterals: true,\n    });\n  }\n\n  render() {\n    const { data, linkService } = this;\n    const link = document.createElement(\"a\");\n\n    if (data.url) {\n      if (\n        (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) &&\n        !linkService.addLinkAttributes\n      ) {\n        warn(\n          \"LinkAnnotationElement.render - missing `addLinkAttributes`-method on the `linkService`-instance.\"\n        );\n      }\n      linkService.addLinkAttributes?.(link, data.url, data.newWindow);\n    } else if (data.action) {\n      this._bindNamedAction(link, data.action);\n    } else if (data.dest) {\n      this._bindLink(link, data.dest);\n    } else {\n      let hasClickAction = false;\n      if (\n        data.actions &&\n        (data.actions.Action ||\n          data.actions[\"Mouse Up\"] ||\n          data.actions[\"Mouse Down\"]) &&\n        this.enableScripting &&\n        this.hasJSActions\n      ) {\n        hasClickAction = true;\n        this._bindJSAction(link, data);\n      }\n\n      if (data.resetForm) {\n        this._bindResetFormAction(link, data.resetForm);\n      } else if (!hasClickAction) {\n        this._bindLink(link, \"\");\n      }\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"linkAnnotation\").map(\n        (quadrilateral, index) => {\n          const linkElement = index === 0 ? link : link.cloneNode();\n          quadrilateral.appendChild(linkElement);\n          return quadrilateral;\n        }\n      );\n    }\n\n    this.container.className = \"linkAnnotation\";\n    this.container.appendChild(link);\n    return this.container;\n  }\n\n  /**\n   * Bind internal links to the link element.\n   *\n   * @private\n   * @param {Object} link\n   * @param {Object} destination\n   * @memberof LinkAnnotationElement\n   */\n  _bindLink(link, destination) {\n    link.href = this.linkService.getDestinationHash(destination);\n    link.onclick = () => {\n      if (destination) {\n        this.linkService.goToDestination(destination);\n      }\n      return false;\n    };\n    if (destination || destination === /* isTooltipOnly = */ \"\") {\n      link.className = \"internalLink\";\n    }\n  }\n\n  /**\n   * Bind named actions to the link element.\n   *\n   * @private\n   * @param {Object} link\n   * @param {Object} action\n   * @memberof LinkAnnotationElement\n   */\n  _bindNamedAction(link, action) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.linkService.executeNamedAction(action);\n      return false;\n    };\n    link.className = \"internalLink\";\n  }\n\n  /**\n   * Bind JS actions to the link element.\n   *\n   * @private\n   * @param {Object} link\n   * @param {Object} data\n   * @memberof LinkAnnotationElement\n   */\n  _bindJSAction(link, data) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    const map = new Map([\n      [\"Action\", \"onclick\"],\n      [\"Mouse Up\", \"onmouseup\"],\n      [\"Mouse Down\", \"onmousedown\"],\n    ]);\n    for (const name of Object.keys(data.actions)) {\n      const jsName = map.get(name);\n      if (!jsName) {\n        continue;\n      }\n      link[jsName] = () => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: data.id,\n            name,\n          },\n        });\n        return false;\n      };\n    }\n\n    if (!link.onclick) {\n      link.onclick = () => false;\n    }\n    link.className = \"internalLink\";\n  }\n\n  _bindResetFormAction(link, resetForm) {\n    const otherClickAction = link.onclick;\n    if (!otherClickAction) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n    }\n    link.className = \"internalLink\";\n\n    if (!this._fieldObjects) {\n      warn(\n        `_bindResetFormAction - \"resetForm\" action not supported, ` +\n          \"ensure that the `fieldObjects` parameter is provided.\"\n      );\n      if (!otherClickAction) {\n        link.onclick = () => false;\n      }\n      return;\n    }\n\n    link.onclick = () => {\n      if (otherClickAction) {\n        otherClickAction();\n      }\n\n      const {\n        fields: resetFormFields,\n        refs: resetFormRefs,\n        include,\n      } = resetForm;\n\n      const allFields = [];\n      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n        const fieldIds = new Set(resetFormRefs);\n        for (const fieldName of resetFormFields) {\n          const fields = this._fieldObjects[fieldName] || [];\n          for (const { id } of fields) {\n            fieldIds.add(id);\n          }\n        }\n        for (const fields of Object.values(this._fieldObjects)) {\n          for (const field of fields) {\n            if (fieldIds.has(field.id) === include) {\n              allFields.push(field);\n            }\n          }\n        }\n      } else {\n        for (const fields of Object.values(this._fieldObjects)) {\n          allFields.push(...fields);\n        }\n      }\n\n      const storage = this.annotationStorage;\n      const allIds = [];\n      for (const field of allFields) {\n        const { id } = field;\n        allIds.push(id);\n        switch (field.type) {\n          case \"text\": {\n            const value = field.defaultValue || \"\";\n            storage.setValue(id, { value, valueAsString: value });\n            break;\n          }\n          case \"checkbox\":\n          case \"radiobutton\": {\n            const value = field.defaultValue === field.exportValues;\n            storage.setValue(id, { value });\n            break;\n          }\n          case \"combobox\":\n          case \"listbox\": {\n            const value = field.defaultValue || \"\";\n            storage.setValue(id, { value });\n            break;\n          }\n          default:\n            continue;\n        }\n        const domElement = document.getElementById(id);\n        if (!domElement || !GetElementsByNameSet.has(domElement)) {\n          continue;\n        }\n        domElement.dispatchEvent(new Event(\"resetform\"));\n      }\n\n      if (this.enableScripting) {\n        // Update the values in the sandbox.\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: \"app\",\n            ids: allIds,\n            name: \"ResetForm\",\n          },\n        });\n      }\n\n      return false;\n    };\n  }\n}\n\nclass TextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, { isRenderable });\n  }\n\n  render() {\n    this.container.className = \"textAnnotation\";\n\n    const image = document.createElement(\"img\");\n    image.style.height = this.container.style.height;\n    image.style.width = this.container.style.width;\n    image.src =\n      this.imageResourcesPath +\n      \"annotation-\" +\n      this.data.name.toLowerCase() +\n      \".svg\";\n    image.alt = \"[{{type}} Annotation]\";\n    image.dataset.l10nId = \"text_annotation_type\";\n    image.dataset.l10nArgs = JSON.stringify({ type: this.data.name });\n\n    if (!this.data.hasPopup) {\n      this._createPopup(image, this.data);\n    }\n\n    this.container.appendChild(image);\n    return this.container;\n  }\n}\n\nclass WidgetAnnotationElement extends AnnotationElement {\n  render() {\n    // Show only the container for unsupported field types.\n    if (this.data.alternativeText) {\n      this.container.title = this.data.alternativeText;\n    }\n\n    return this.container;\n  }\n\n  _getKeyModifier(event) {\n    const { isWin, isMac } = AnnotationElement.platform;\n    return (isWin && event.ctrlKey) || (isMac && event.metaKey);\n  }\n\n  _setEventListener(element, baseName, eventName, valueGetter) {\n    if (baseName.includes(\"mouse\")) {\n      // Mouse events\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event),\n            shift: event.shiftKey,\n            modifier: this._getKeyModifier(event),\n          },\n        });\n      });\n    } else {\n      // Non mouse event\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: event.target.checked,\n          },\n        });\n      });\n    }\n  }\n\n  _setEventListeners(element, names, getter) {\n    for (const [baseName, eventName] of names) {\n      if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n        this._setEventListener(element, baseName, eventName, getter);\n      }\n    }\n  }\n\n  _setBackgroundColor(element) {\n    const color = this.data.backgroundColor || null;\n    element.style.backgroundColor =\n      color === null\n        ? \"transparent\"\n        : Util.makeHexColor(color[0], color[1], color[2]);\n  }\n\n  _dispatchEventFromSandbox(actions, jsEvent) {\n    const setColor = (jsName, styleName, event) => {\n      const color = event.detail[jsName];\n      event.target.style[styleName] = ColorConverters[`${color[0]}_HTML`](\n        color.slice(1)\n      );\n    };\n\n    const commonActions = {\n      display: event => {\n        const hidden = event.detail.display % 2 === 1;\n        event.target.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          hidden,\n          print: event.detail.display === 0 || event.detail.display === 3,\n        });\n      },\n      print: event => {\n        this.annotationStorage.setValue(this.data.id, {\n          print: event.detail.print,\n        });\n      },\n      hidden: event => {\n        event.target.style.visibility = event.detail.hidden\n          ? \"hidden\"\n          : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          hidden: event.detail.hidden,\n        });\n      },\n      focus: event => {\n        setTimeout(() => event.target.focus({ preventScroll: false }), 0);\n      },\n      userName: event => {\n        // tooltip\n        event.target.title = event.detail.userName;\n      },\n      readonly: event => {\n        if (event.detail.readonly) {\n          event.target.setAttribute(\"readonly\", \"\");\n        } else {\n          event.target.removeAttribute(\"readonly\");\n        }\n      },\n      required: event => {\n        if (event.detail.required) {\n          event.target.setAttribute(\"required\", \"\");\n        } else {\n          event.target.removeAttribute(\"required\");\n        }\n      },\n      bgColor: event => {\n        setColor(\"bgColor\", \"backgroundColor\", event);\n      },\n      fillColor: event => {\n        setColor(\"fillColor\", \"backgroundColor\", event);\n      },\n      fgColor: event => {\n        setColor(\"fgColor\", \"color\", event);\n      },\n      textColor: event => {\n        setColor(\"textColor\", \"color\", event);\n      },\n      borderColor: event => {\n        setColor(\"borderColor\", \"borderColor\", event);\n      },\n      strokeColor: event => {\n        setColor(\"strokeColor\", \"borderColor\", event);\n      },\n    };\n\n    for (const name of Object.keys(jsEvent.detail)) {\n      const action = actions[name] || commonActions[name];\n      if (action) {\n        action(jsEvent);\n      }\n    }\n  }\n}\n\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    const isRenderable =\n      parameters.renderForms ||\n      (!parameters.data.hasAppearance && !!parameters.data.fieldValue);\n    super(parameters, { isRenderable });\n  }\n\n  setPropertyOnSiblings(base, key, value, keyInStorage) {\n    const storage = this.annotationStorage;\n    for (const element of this._getElementsByName(\n      base.name,\n      /* skipId = */ base.id\n    )) {\n      if (element.domElement) {\n        element.domElement[key] = value;\n      }\n      storage.setValue(element.id, { [keyInStorage]: value });\n    }\n  }\n\n  render() {\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n\n    this.container.className = \"textWidgetAnnotation\";\n\n    let element = null;\n    if (this.renderForms) {\n      // NOTE: We cannot set the values using `element.value` below, since it\n      //       prevents the AnnotationLayer rasterizer in `test/driver.js`\n      //       from parsing the elements correctly for the reference tests.\n      const storedData = storage.getValue(id, {\n        value: this.data.fieldValue,\n        valueAsString: this.data.fieldValue,\n      });\n      const textContent = storedData.valueAsString || storedData.value || \"\";\n      const elementData = {\n        userValue: null,\n        formattedValue: null,\n        beforeInputSelectionRange: null,\n        beforeInputValue: null,\n      };\n\n      if (this.data.multiLine) {\n        element = document.createElement(\"textarea\");\n        element.textContent = textContent;\n      } else {\n        element = document.createElement(\"input\");\n        element.type = \"text\";\n        element.setAttribute(\"value\", textContent);\n      }\n      GetElementsByNameSet.add(element);\n      element.disabled = this.data.readOnly;\n      element.name = this.data.fieldName;\n      element.tabIndex = DEFAULT_TAB_INDEX;\n\n      elementData.userValue = textContent;\n      element.setAttribute(\"id\", id);\n\n      element.addEventListener(\"input\", event => {\n        storage.setValue(id, { value: event.target.value });\n        this.setPropertyOnSiblings(\n          element,\n          \"value\",\n          event.target.value,\n          \"value\"\n        );\n      });\n\n      element.addEventListener(\"resetform\", event => {\n        const defaultValue = this.data.defaultFieldValue || \"\";\n        element.value = elementData.userValue = defaultValue;\n        delete elementData.formattedValue;\n      });\n\n      let blurListener = event => {\n        if (elementData.formattedValue) {\n          event.target.value = elementData.formattedValue;\n        }\n        // Reset the cursor position to the start of the field (issue 12359).\n        event.target.scrollLeft = 0;\n        elementData.beforeInputSelectionRange = null;\n      };\n\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"focus\", event => {\n          if (elementData.userValue) {\n            event.target.value = elementData.userValue;\n          }\n        });\n\n        element.addEventListener(\"updatefromsandbox\", jsEvent => {\n          const actions = {\n            value(event) {\n              elementData.userValue = event.detail.value || \"\";\n              storage.setValue(id, { value: elementData.userValue.toString() });\n              if (!elementData.formattedValue) {\n                event.target.value = elementData.userValue;\n              }\n            },\n            valueAsString(event) {\n              elementData.formattedValue = event.detail.valueAsString || \"\";\n              if (event.target !== document.activeElement) {\n                // Input hasn't the focus so display formatted string\n                event.target.value = elementData.formattedValue;\n              }\n              storage.setValue(id, {\n                formattedValue: elementData.formattedValue,\n              });\n            },\n            selRange(event) {\n              const [selStart, selEnd] = event.detail.selRange;\n              if (selStart >= 0 && selEnd < event.target.value.length) {\n                event.target.setSelectionRange(selStart, selEnd);\n              }\n            },\n          };\n          this._dispatchEventFromSandbox(actions, jsEvent);\n        });\n\n        // Even if the field hasn't any actions\n        // leaving it can still trigger some actions with Calculate\n        element.addEventListener(\"keydown\", event => {\n          elementData.beforeInputValue = event.target.value;\n          // if the key is one of Escape, Enter or Tab\n          // then the data are committed\n          let commitKey = -1;\n          if (event.key === \"Escape\") {\n            commitKey = 0;\n          } else if (event.key === \"Enter\") {\n            commitKey = 2;\n          } else if (event.key === \"Tab\") {\n            commitKey = 3;\n          }\n          if (commitKey === -1) {\n            return;\n          }\n          // Save the entered value\n          elementData.userValue = event.target.value;\n          this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n            source: this,\n            detail: {\n              id,\n              name: \"Keystroke\",\n              value: event.target.value,\n              willCommit: true,\n              commitKey,\n              selStart: event.target.selectionStart,\n              selEnd: event.target.selectionEnd,\n            },\n          });\n        });\n        const _blurListener = blurListener;\n        blurListener = null;\n        element.addEventListener(\"blur\", event => {\n          if (this._mouseState.isDown) {\n            // Focus out using the mouse: data are committed\n            elementData.userValue = event.target.value;\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value: event.target.value,\n                willCommit: true,\n                commitKey: 1,\n                selStart: event.target.selectionStart,\n                selEnd: event.target.selectionEnd,\n              },\n            });\n          }\n          _blurListener(event);\n        });\n        element.addEventListener(\"mousedown\", event => {\n          elementData.beforeInputValue = event.target.value;\n          elementData.beforeInputSelectionRange = null;\n        });\n        element.addEventListener(\"keyup\", event => {\n          // keyup is triggered after input\n          if (event.target.selectionStart === event.target.selectionEnd) {\n            elementData.beforeInputSelectionRange = null;\n          }\n        });\n        element.addEventListener(\"select\", event => {\n          elementData.beforeInputSelectionRange = [\n            event.target.selectionStart,\n            event.target.selectionEnd,\n          ];\n        });\n\n        if (this.data.actions?.Keystroke) {\n          // We should use beforeinput but this\n          // event isn't available in Firefox\n          element.addEventListener(\"input\", event => {\n            let selStart = -1;\n            let selEnd = -1;\n            if (elementData.beforeInputSelectionRange) {\n              [selStart, selEnd] = elementData.beforeInputSelectionRange;\n            }\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value: elementData.beforeInputValue,\n                change: event.data,\n                willCommit: false,\n                selStart,\n                selEnd,\n              },\n            });\n          });\n        }\n\n        this._setEventListeners(\n          element,\n          [\n            [\"focus\", \"Focus\"],\n            [\"blur\", \"Blur\"],\n            [\"mousedown\", \"Mouse Down\"],\n            [\"mouseenter\", \"Mouse Enter\"],\n            [\"mouseleave\", \"Mouse Exit\"],\n            [\"mouseup\", \"Mouse Up\"],\n          ],\n          event => event.target.value\n        );\n      }\n\n      if (blurListener) {\n        element.addEventListener(\"blur\", blurListener);\n      }\n\n      if (this.data.maxLen !== null) {\n        element.maxLength = this.data.maxLen;\n      }\n\n      if (this.data.comb) {\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n        const combWidth = fieldWidth / this.data.maxLen;\n\n        element.classList.add(\"comb\");\n        element.style.letterSpacing = `calc(${combWidth}px - 1ch)`;\n      }\n    } else {\n      element = document.createElement(\"div\");\n      element.textContent = this.data.fieldValue;\n      element.style.verticalAlign = \"middle\";\n      element.style.display = \"table-cell\";\n    }\n\n    this._setTextStyle(element);\n    this._setBackgroundColor(element);\n\n    this.container.appendChild(element);\n    return this.container;\n  }\n\n  /**\n   * Apply text styles to the text in the element.\n   *\n   * @private\n   * @param {HTMLDivElement} element\n   * @memberof TextWidgetAnnotationElement\n   */\n  _setTextStyle(element) {\n    const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n    const { fontSize, fontColor } = this.data.defaultAppearanceData;\n    const style = element.style;\n\n    // TODO: If the font-size is zero, calculate it based on the height and\n    //       width of the element.\n    // Not setting `style.fontSize` will use the default font-size for now.\n    if (fontSize) {\n      style.fontSize = `${fontSize}px`;\n    }\n\n    style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n\n    if (this.data.textAlignment !== null) {\n      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n    }\n  }\n}\n\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, { isRenderable: parameters.renderForms });\n  }\n\n  render() {\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.exportValue === data.fieldValue,\n    }).value;\n    if (typeof value === \"string\") {\n      // The value has been changed through js and set in annotationStorage.\n      value = value !== \"Off\";\n      storage.setValue(id, { value });\n    }\n\n    this.container.className = \"buttonWidgetAnnotation checkBox\";\n\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.disabled = data.readOnly;\n    element.type = \"checkbox\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.setAttribute(\"id\", id);\n    element.setAttribute(\"exportValue\", data.exportValue);\n    element.tabIndex = DEFAULT_TAB_INDEX;\n\n    element.addEventListener(\"change\", event => {\n      const { name, checked } = event.target;\n      for (const checkbox of this._getElementsByName(name, /* skipId = */ id)) {\n        const curChecked = checked && checkbox.exportValue === data.exportValue;\n        if (checkbox.domElement) {\n          checkbox.domElement.checked = curChecked;\n        }\n        storage.setValue(checkbox.id, { value: curChecked });\n      }\n      storage.setValue(id, { value: checked });\n    });\n\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue || \"Off\";\n      event.target.checked = defaultValue === data.exportValue;\n    });\n\n    if (this.enableScripting && this.hasJSActions) {\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            event.target.checked = event.detail.value !== \"Off\";\n            storage.setValue(id, { value: event.target.checked });\n          },\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n\n      this._setEventListeners(\n        element,\n        [\n          [\"change\", \"Validate\"],\n          [\"change\", \"Action\"],\n          [\"focus\", \"Focus\"],\n          [\"blur\", \"Blur\"],\n          [\"mousedown\", \"Mouse Down\"],\n          [\"mouseenter\", \"Mouse Enter\"],\n          [\"mouseleave\", \"Mouse Exit\"],\n          [\"mouseup\", \"Mouse Up\"],\n        ],\n        event => event.target.checked\n      );\n    }\n\n    this._setBackgroundColor(element);\n\n    this.container.appendChild(element);\n    return this.container;\n  }\n}\n\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, { isRenderable: parameters.renderForms });\n  }\n\n  render() {\n    this.container.className = \"buttonWidgetAnnotation radioButton\";\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.fieldValue === data.buttonValue,\n    }).value;\n    if (typeof value === \"string\") {\n      // The value has been changed through js and set in annotationStorage.\n      value = value !== data.buttonValue;\n      storage.setValue(id, { value });\n    }\n\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.disabled = data.readOnly;\n    element.type = \"radio\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.setAttribute(\"id\", id);\n    element.tabIndex = DEFAULT_TAB_INDEX;\n\n    element.addEventListener(\"change\", event => {\n      const { name, checked } = event.target;\n      for (const radio of this._getElementsByName(name, /* skipId = */ id)) {\n        storage.setValue(radio.id, { value: false });\n      }\n      storage.setValue(id, { value: checked });\n    });\n\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue;\n      event.target.checked =\n        defaultValue !== null &&\n        defaultValue !== undefined &&\n        defaultValue === data.buttonValue;\n    });\n\n    if (this.enableScripting && this.hasJSActions) {\n      const pdfButtonValue = data.buttonValue;\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value: event => {\n            const checked = pdfButtonValue === event.detail.value;\n            for (const radio of this._getElementsByName(event.target.name)) {\n              const curChecked = checked && radio.id === id;\n              if (radio.domElement) {\n                radio.domElement.checked = curChecked;\n              }\n              storage.setValue(radio.id, { value: curChecked });\n            }\n          },\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n\n      this._setEventListeners(\n        element,\n        [\n          [\"change\", \"Validate\"],\n          [\"change\", \"Action\"],\n          [\"focus\", \"Focus\"],\n          [\"blur\", \"Blur\"],\n          [\"mousedown\", \"Mouse Down\"],\n          [\"mouseenter\", \"Mouse Enter\"],\n          [\"mouseleave\", \"Mouse Exit\"],\n          [\"mouseup\", \"Mouse Up\"],\n        ],\n        event => event.target.checked\n      );\n    }\n\n    this._setBackgroundColor(element);\n\n    this.container.appendChild(element);\n    return this.container;\n  }\n}\n\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n  constructor(parameters) {\n    super(parameters, { ignoreBorder: parameters.data.hasAppearance });\n  }\n\n  render() {\n    // The rendering and functionality of a push button widget annotation is\n    // equal to that of a link annotation, but may have more functionality, such\n    // as performing actions on form fields (resetting, submitting, et cetera).\n    const container = super.render();\n    container.className = \"buttonWidgetAnnotation pushButton\";\n\n    if (this.data.alternativeText) {\n      container.title = this.data.alternativeText;\n    }\n\n    return container;\n  }\n}\n\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, { isRenderable: parameters.renderForms });\n  }\n\n  render() {\n    this.container.className = \"choiceWidgetAnnotation\";\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n\n    // For printing/saving we currently only support choice widgets with one\n    // option selection. Therefore, listboxes (#12189) and comboboxes (#12224)\n    // are not properly printed/saved yet, so we only store the first item in\n    // the field value array instead of the entire array. Once support for those\n    // two field types is implemented, we should use the same pattern as the\n    // other interactive widgets where the return value of `getValue`\n    // is used and the full array of field values is stored.\n    storage.getValue(id, {\n      value:\n        this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined,\n    });\n\n    let { fontSize } = this.data.defaultAppearanceData;\n    if (!fontSize) {\n      fontSize = 9;\n    }\n    const fontSizeStyle = `calc(${fontSize}px * var(--zoom-factor))`;\n\n    const selectElement = document.createElement(\"select\");\n    GetElementsByNameSet.add(selectElement);\n    selectElement.disabled = this.data.readOnly;\n    selectElement.name = this.data.fieldName;\n    selectElement.setAttribute(\"id\", id);\n    selectElement.tabIndex = DEFAULT_TAB_INDEX;\n\n    selectElement.style.fontSize = `${fontSize}px`;\n\n    if (!this.data.combo) {\n      // List boxes have a size and (optionally) multiple selection.\n      selectElement.size = this.data.options.length;\n      if (this.data.multiSelect) {\n        selectElement.multiple = true;\n      }\n    }\n\n    selectElement.addEventListener(\"resetform\", event => {\n      const defaultValue = this.data.defaultFieldValue;\n      for (const option of selectElement.options) {\n        option.selected = option.value === defaultValue;\n      }\n    });\n\n    // Insert the options into the choice field.\n    for (const option of this.data.options) {\n      const optionElement = document.createElement(\"option\");\n      optionElement.textContent = option.displayValue;\n      optionElement.value = option.exportValue;\n      if (this.data.combo) {\n        optionElement.style.fontSize = fontSizeStyle;\n      }\n      if (this.data.fieldValue.includes(option.exportValue)) {\n        optionElement.setAttribute(\"selected\", true);\n      }\n      selectElement.appendChild(optionElement);\n    }\n\n    const getValue = (event, isExport) => {\n      const name = isExport ? \"value\" : \"textContent\";\n      const options = event.target.options;\n      if (!event.target.multiple) {\n        return options.selectedIndex === -1\n          ? null\n          : options[options.selectedIndex][name];\n      }\n      return Array.prototype.filter\n        .call(options, option => option.selected)\n        .map(option => option[name]);\n    };\n\n    const getItems = event => {\n      const options = event.target.options;\n      return Array.prototype.map.call(options, option => {\n        return { displayValue: option.textContent, exportValue: option.value };\n      });\n    };\n\n    if (this.enableScripting && this.hasJSActions) {\n      selectElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            const value = event.detail.value;\n            const values = new Set(Array.isArray(value) ? value : [value]);\n            for (const option of selectElement.options) {\n              option.selected = values.has(option.value);\n            }\n            storage.setValue(id, {\n              value: getValue(event, /* isExport */ true),\n            });\n          },\n          multipleSelection(event) {\n            selectElement.multiple = true;\n          },\n          remove(event) {\n            const options = selectElement.options;\n            const index = event.detail.remove;\n            options[index].selected = false;\n            selectElement.remove(index);\n            if (options.length > 0) {\n              const i = Array.prototype.findIndex.call(\n                options,\n                option => option.selected\n              );\n              if (i === -1) {\n                options[0].selected = true;\n              }\n            }\n            storage.setValue(id, {\n              value: getValue(event, /* isExport */ true),\n              items: getItems(event),\n            });\n          },\n          clear(event) {\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            storage.setValue(id, { value: null, items: [] });\n          },\n          insert(event) {\n            const { index, displayValue, exportValue } = event.detail.insert;\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = displayValue;\n            optionElement.value = exportValue;\n            selectElement.insertBefore(\n              optionElement,\n              selectElement.children[index]\n            );\n            storage.setValue(id, {\n              value: getValue(event, /* isExport */ true),\n              items: getItems(event),\n            });\n          },\n          items(event) {\n            const { items } = event.detail;\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            for (const item of items) {\n              const { displayValue, exportValue } = item;\n              const optionElement = document.createElement(\"option\");\n              optionElement.textContent = displayValue;\n              optionElement.value = exportValue;\n              selectElement.appendChild(optionElement);\n            }\n            if (selectElement.options.length > 0) {\n              selectElement.options[0].selected = true;\n            }\n            storage.setValue(id, {\n              value: getValue(event, /* isExport */ true),\n              items: getItems(event),\n            });\n          },\n          indices(event) {\n            const indices = new Set(event.detail.indices);\n            for (const option of event.target.options) {\n              option.selected = indices.has(option.index);\n            }\n            storage.setValue(id, {\n              value: getValue(event, /* isExport */ true),\n            });\n          },\n          editable(event) {\n            event.target.disabled = !event.detail.editable;\n          },\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n\n      selectElement.addEventListener(\"input\", event => {\n        const exportValue = getValue(event, /* isExport */ true);\n        const value = getValue(event, /* isExport */ false);\n        storage.setValue(id, { value: exportValue });\n\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id,\n            name: \"Keystroke\",\n            value,\n            changeEx: exportValue,\n            willCommit: true,\n            commitKey: 1,\n            keyDown: false,\n          },\n        });\n      });\n\n      this._setEventListeners(\n        selectElement,\n        [\n          [\"focus\", \"Focus\"],\n          [\"blur\", \"Blur\"],\n          [\"mousedown\", \"Mouse Down\"],\n          [\"mouseenter\", \"Mouse Enter\"],\n          [\"mouseleave\", \"Mouse Exit\"],\n          [\"mouseup\", \"Mouse Up\"],\n          [\"input\", \"Action\"],\n        ],\n        event => event.target.checked\n      );\n    } else {\n      selectElement.addEventListener(\"input\", function (event) {\n        storage.setValue(id, { value: getValue(event) });\n      });\n    }\n\n    this._setBackgroundColor(selectElement);\n\n    this.container.appendChild(selectElement);\n    return this.container;\n  }\n}\n\nclass PopupAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, { isRenderable });\n  }\n\n  render() {\n    // Do not render popup annotations for parent elements with these types as\n    // they create the popups themselves (because of custom trigger divs).\n    const IGNORE_TYPES = [\n      \"Line\",\n      \"Square\",\n      \"Circle\",\n      \"PolyLine\",\n      \"Polygon\",\n      \"Ink\",\n    ];\n\n    this.container.className = \"popupAnnotation\";\n\n    if (IGNORE_TYPES.includes(this.data.parentType)) {\n      return this.container;\n    }\n\n    const selector = `[data-annotation-id=\"${this.data.parentId}\"]`;\n    const parentElements = this.layer.querySelectorAll(selector);\n    if (parentElements.length === 0) {\n      return this.container;\n    }\n\n    const popup = new PopupElement({\n      container: this.container,\n      trigger: Array.from(parentElements),\n      color: this.data.color,\n      titleObj: this.data.titleObj,\n      modificationDate: this.data.modificationDate,\n      contentsObj: this.data.contentsObj,\n      richText: this.data.richText,\n    });\n\n    // Position the popup next to the parent annotation's container.\n    // PDF viewers ignore a popup annotation's rectangle.\n    const page = this.page;\n    const rect = Util.normalizeRect([\n      this.data.parentRect[0],\n      page.view[3] - this.data.parentRect[1] + page.view[1],\n      this.data.parentRect[2],\n      page.view[3] - this.data.parentRect[3] + page.view[1],\n    ]);\n    const popupLeft =\n      rect[0] + this.data.parentRect[2] - this.data.parentRect[0];\n    const popupTop = rect[1];\n\n    this.container.style.transformOrigin = `${-popupLeft}px ${-popupTop}px`;\n    this.container.style.left = `${popupLeft}px`;\n    this.container.style.top = `${popupTop}px`;\n\n    this.container.appendChild(popup.render());\n    return this.container;\n  }\n}\n\nclass PopupElement {\n  constructor(parameters) {\n    this.container = parameters.container;\n    this.trigger = parameters.trigger;\n    this.color = parameters.color;\n    this.titleObj = parameters.titleObj;\n    this.modificationDate = parameters.modificationDate;\n    this.contentsObj = parameters.contentsObj;\n    this.richText = parameters.richText;\n    this.hideWrapper = parameters.hideWrapper || false;\n\n    this.pinned = false;\n  }\n\n  render() {\n    const BACKGROUND_ENLIGHT = 0.7;\n\n    const wrapper = document.createElement(\"div\");\n    wrapper.className = \"popupWrapper\";\n\n    // For Popup annotations we hide the entire section because it contains\n    // only the popup. However, for Text annotations without a separate Popup\n    // annotation, we cannot hide the entire container as the image would\n    // disappear too. In that special case, hiding the wrapper suffices.\n    this.hideElement = this.hideWrapper ? wrapper : this.container;\n    this.hideElement.hidden = true;\n\n    const popup = document.createElement(\"div\");\n    popup.className = \"popup\";\n\n    const color = this.color;\n    if (color) {\n      // Enlighten the color.\n      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n      popup.style.backgroundColor = Util.makeHexColor(r | 0, g | 0, b | 0);\n    }\n\n    const title = document.createElement(\"h1\");\n    title.dir = this.titleObj.dir;\n    title.textContent = this.titleObj.str;\n    popup.appendChild(title);\n\n    // The modification date is shown in the popup instead of the creation\n    // date if it is available and can be parsed correctly, which is\n    // consistent with other viewers such as Adobe Acrobat.\n    const dateObject = PDFDateString.toDateObject(this.modificationDate);\n    if (dateObject) {\n      const modificationDate = document.createElement(\"span\");\n      modificationDate.className = \"popupDate\";\n      modificationDate.textContent = \"{{date}}, {{time}}\";\n      modificationDate.dataset.l10nId = \"annotation_date_string\";\n      modificationDate.dataset.l10nArgs = JSON.stringify({\n        date: dateObject.toLocaleDateString(),\n        time: dateObject.toLocaleTimeString(),\n      });\n      popup.appendChild(modificationDate);\n    }\n\n    if (\n      this.richText?.str &&\n      (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)\n    ) {\n      XfaLayer.render({\n        xfaHtml: this.richText.html,\n        intent: \"richText\",\n        div: popup,\n      });\n      popup.lastChild.className = \"richText popupContent\";\n    } else {\n      const contents = this._formatContents(this.contentsObj);\n      popup.appendChild(contents);\n    }\n\n    if (!Array.isArray(this.trigger)) {\n      this.trigger = [this.trigger];\n    }\n\n    // Attach the event listeners to the trigger element.\n    for (const element of this.trigger) {\n      element.addEventListener(\"click\", this._toggle.bind(this));\n      element.addEventListener(\"mouseover\", this._show.bind(this, false));\n      element.addEventListener(\"mouseout\", this._hide.bind(this, false));\n    }\n    popup.addEventListener(\"click\", this._hide.bind(this, true));\n\n    wrapper.appendChild(popup);\n    return wrapper;\n  }\n\n  /**\n   * Format the contents of the popup by adding newlines where necessary.\n   *\n   * @private\n   * @param {Object<string, string>} contentsObj\n   * @memberof PopupElement\n   * @returns {HTMLParagraphElement}\n   */\n  _formatContents({ str, dir }) {\n    const p = document.createElement(\"p\");\n    p.className = \"popupContent\";\n    p.dir = dir;\n    const lines = str.split(/(?:\\r\\n?|\\n)/);\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      p.appendChild(document.createTextNode(line));\n      if (i < ii - 1) {\n        p.appendChild(document.createElement(\"br\"));\n      }\n    }\n    return p;\n  }\n\n  /**\n   * Toggle the visibility of the popup.\n   *\n   * @private\n   * @memberof PopupElement\n   */\n  _toggle() {\n    if (this.pinned) {\n      this._hide(true);\n    } else {\n      this._show(true);\n    }\n  }\n\n  /**\n   * Show the popup.\n   *\n   * @private\n   * @param {boolean} pin\n   * @memberof PopupElement\n   */\n  _show(pin = false) {\n    if (pin) {\n      this.pinned = true;\n    }\n    if (this.hideElement.hidden) {\n      this.hideElement.hidden = false;\n      this.container.style.zIndex += 1;\n    }\n  }\n\n  /**\n   * Hide the popup.\n   *\n   * @private\n   * @param {boolean} unpin\n   * @memberof PopupElement\n   */\n  _hide(unpin = true) {\n    if (unpin) {\n      this.pinned = false;\n    }\n    if (!this.hideElement.hidden && !this.pinned) {\n      this.hideElement.hidden = true;\n      this.container.style.zIndex -= 1;\n    }\n  }\n}\n\nclass FreeTextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, { isRenderable, ignoreBorder: true });\n  }\n\n  render() {\n    this.container.className = \"freeTextAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n    return this.container;\n  }\n}\n\nclass LineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, { isRenderable, ignoreBorder: true });\n  }\n\n  render() {\n    this.container.className = \"lineAnnotation\";\n\n    // Create an invisible line with the same starting and ending coordinates\n    // that acts as the trigger for the popup. Only the line itself should\n    // trigger the popup, not the entire container.\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n\n    // PDF coordinates are calculated from a bottom left origin, so transform\n    // the line coordinates to a top left origin for the SVG element.\n    const line = this.svgFactory.createElement(\"svg:line\");\n    line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n    line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n    line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n    line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n    // Ensure that the 'stroke-width' is always non-zero, since otherwise it\n    // won't be possible to open/close the popup (note e.g. issue 11122).\n    line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    line.setAttribute(\"stroke\", \"transparent\");\n    line.setAttribute(\"fill\", \"transparent\");\n\n    svg.appendChild(line);\n    this.container.append(svg);\n\n    // Create the popup ourselves so that we can bind it to the line instead\n    // of to the entire container (which is the default).\n    this._createPopup(line, data);\n\n    return this.container;\n  }\n}\n\nclass SquareAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, { isRenderable, ignoreBorder: true });\n  }\n\n  render() {\n    this.container.className = \"squareAnnotation\";\n\n    // Create an invisible square with the same rectangle that acts as the\n    // trigger for the popup. Only the square itself should trigger the\n    // popup, not the entire container.\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n\n    // The browser draws half of the borders inside the square and half of\n    // the borders outside the square by default. This behavior cannot be\n    // changed programmatically, so correct for that here.\n    const borderWidth = data.borderStyle.width;\n    const square = this.svgFactory.createElement(\"svg:rect\");\n    square.setAttribute(\"x\", borderWidth / 2);\n    square.setAttribute(\"y\", borderWidth / 2);\n    square.setAttribute(\"width\", width - borderWidth);\n    square.setAttribute(\"height\", height - borderWidth);\n    // Ensure that the 'stroke-width' is always non-zero, since otherwise it\n    // won't be possible to open/close the popup (note e.g. issue 11122).\n    square.setAttribute(\"stroke-width\", borderWidth || 1);\n    square.setAttribute(\"stroke\", \"transparent\");\n    square.setAttribute(\"fill\", \"transparent\");\n\n    svg.appendChild(square);\n    this.container.append(svg);\n\n    // Create the popup ourselves so that we can bind it to the square instead\n    // of to the entire container (which is the default).\n    this._createPopup(square, data);\n\n    return this.container;\n  }\n}\n\nclass CircleAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, { isRenderable, ignoreBorder: true });\n  }\n\n  render() {\n    this.container.className = \"circleAnnotation\";\n\n    // Create an invisible circle with the same ellipse that acts as the\n    // trigger for the popup. Only the circle itself should trigger the\n    // popup, not the entire container.\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n\n    // The browser draws half of the borders inside the circle and half of\n    // the borders outside the circle by default. This behavior cannot be\n    // changed programmatically, so correct for that here.\n    const borderWidth = data.borderStyle.width;\n    const circle = this.svgFactory.createElement(\"svg:ellipse\");\n    circle.setAttribute(\"cx\", width / 2);\n    circle.setAttribute(\"cy\", height / 2);\n    circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n    circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n    // Ensure that the 'stroke-width' is always non-zero, since otherwise it\n    // won't be possible to open/close the popup (note e.g. issue 11122).\n    circle.setAttribute(\"stroke-width\", borderWidth || 1);\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill\", \"transparent\");\n\n    svg.appendChild(circle);\n    this.container.append(svg);\n\n    // Create the popup ourselves so that we can bind it to the circle instead\n    // of to the entire container (which is the default).\n    this._createPopup(circle, data);\n\n    return this.container;\n  }\n}\n\nclass PolylineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, { isRenderable, ignoreBorder: true });\n\n    this.containerClassName = \"polylineAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n\n    // Create an invisible polyline with the same points that acts as the\n    // trigger for the popup. Only the polyline itself should trigger the\n    // popup, not the entire container.\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n\n    // Convert the vertices array to a single points string that the SVG\n    // polyline element expects (\"x1,y1 x2,y2 ...\"). PDF coordinates are\n    // calculated from a bottom left origin, so transform the polyline\n    // coordinates to a top left origin for the SVG element.\n    let points = [];\n    for (const coordinate of data.vertices) {\n      const x = coordinate.x - data.rect[0];\n      const y = data.rect[3] - coordinate.y;\n      points.push(x + \",\" + y);\n    }\n    points = points.join(\" \");\n\n    const polyline = this.svgFactory.createElement(this.svgElementName);\n    polyline.setAttribute(\"points\", points);\n    // Ensure that the 'stroke-width' is always non-zero, since otherwise it\n    // won't be possible to open/close the popup (note e.g. issue 11122).\n    polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    polyline.setAttribute(\"stroke\", \"transparent\");\n    polyline.setAttribute(\"fill\", \"transparent\");\n\n    svg.appendChild(polyline);\n    this.container.append(svg);\n\n    // Create the popup ourselves so that we can bind it to the polyline\n    // instead of to the entire container (which is the default).\n    this._createPopup(polyline, data);\n\n    return this.container;\n  }\n}\n\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n  constructor(parameters) {\n    // Polygons are specific forms of polylines, so reuse their logic.\n    super(parameters);\n\n    this.containerClassName = \"polygonAnnotation\";\n    this.svgElementName = \"svg:polygon\";\n  }\n}\n\nclass CaretAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, { isRenderable, ignoreBorder: true });\n  }\n\n  render() {\n    this.container.className = \"caretAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n    return this.container;\n  }\n}\n\nclass InkAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, { isRenderable, ignoreBorder: true });\n\n    this.containerClassName = \"inkAnnotation\";\n\n    // Use the polyline SVG element since it allows us to use coordinates\n    // directly and to draw both straight lines and curves.\n    this.svgElementName = \"svg:polyline\";\n  }\n\n  render() {\n    this.container.className = this.containerClassName;\n\n    // Create an invisible polyline with the same points that acts as the\n    // trigger for the popup.\n    const data = this.data;\n    const width = data.rect[2] - data.rect[0];\n    const height = data.rect[3] - data.rect[1];\n    const svg = this.svgFactory.create(width, height);\n\n    for (const inkList of data.inkLists) {\n      // Convert the ink list to a single points string that the SVG\n      // polyline element expects (\"x1,y1 x2,y2 ...\"). PDF coordinates are\n      // calculated from a bottom left origin, so transform the polyline\n      // coordinates to a top left origin for the SVG element.\n      let points = [];\n      for (const coordinate of inkList) {\n        const x = coordinate.x - data.rect[0];\n        const y = data.rect[3] - coordinate.y;\n        points.push(`${x},${y}`);\n      }\n      points = points.join(\" \");\n\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      polyline.setAttribute(\"points\", points);\n      // Ensure that the 'stroke-width' is always non-zero, since otherwise it\n      // won't be possible to open/close the popup (note e.g. issue 11122).\n      polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      polyline.setAttribute(\"stroke\", \"transparent\");\n      polyline.setAttribute(\"fill\", \"transparent\");\n\n      // Create the popup ourselves so that we can bind it to the polyline\n      // instead of to the entire container (which is the default).\n      this._createPopup(polyline, data);\n\n      svg.appendChild(polyline);\n    }\n\n    this.container.append(svg);\n    return this.container;\n  }\n}\n\nclass HighlightAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true,\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"highlightAnnotation\");\n    }\n\n    this.container.className = \"highlightAnnotation\";\n    return this.container;\n  }\n}\n\nclass UnderlineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true,\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"underlineAnnotation\");\n    }\n\n    this.container.className = \"underlineAnnotation\";\n    return this.container;\n  }\n}\n\nclass SquigglyAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true,\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"squigglyAnnotation\");\n    }\n\n    this.container.className = \"squigglyAnnotation\";\n    return this.container;\n  }\n}\n\nclass StrikeOutAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, {\n      isRenderable,\n      ignoreBorder: true,\n      createQuadrilaterals: true,\n    });\n  }\n\n  render() {\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n\n    if (this.quadrilaterals) {\n      return this._renderQuadrilaterals(\"strikeoutAnnotation\");\n    }\n\n    this.container.className = \"strikeoutAnnotation\";\n    return this.container;\n  }\n}\n\nclass StampAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const isRenderable = !!(\n      parameters.data.hasPopup ||\n      parameters.data.titleObj?.str ||\n      parameters.data.contentsObj?.str ||\n      parameters.data.richText?.str\n    );\n    super(parameters, { isRenderable, ignoreBorder: true });\n  }\n\n  render() {\n    this.container.className = \"stampAnnotation\";\n\n    if (!this.data.hasPopup) {\n      this._createPopup(null, this.data);\n    }\n    return this.container;\n  }\n}\n\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, { isRenderable: true });\n\n    const { filename, content } = this.data.file;\n    this.filename = getFilenameFromUrl(filename);\n    this.content = content;\n\n    this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n      source: this,\n      id: stringToPDFString(filename),\n      filename,\n      content,\n    });\n  }\n\n  render() {\n    this.container.className = \"fileAttachmentAnnotation\";\n\n    const trigger = document.createElement(\"div\");\n    trigger.style.height = this.container.style.height;\n    trigger.style.width = this.container.style.width;\n    trigger.addEventListener(\"dblclick\", this._download.bind(this));\n\n    if (\n      !this.data.hasPopup &&\n      (this.data.titleObj?.str ||\n        this.data.contentsObj?.str ||\n        this.data.richText)\n    ) {\n      this._createPopup(trigger, this.data);\n    }\n\n    this.container.appendChild(trigger);\n    return this.container;\n  }\n\n  /**\n   * Download the file attachment associated with this annotation.\n   *\n   * @private\n   * @memberof FileAttachmentAnnotationElement\n   */\n  _download() {\n    this.downloadManager?.openOrDownloadData(\n      this.container,\n      this.content,\n      this.filename\n    );\n  }\n}\n\n/**\n * @typedef {Object} AnnotationLayerParameters\n * @property {PageViewport} viewport\n * @property {HTMLDivElement} div\n * @property {Array} annotations\n * @property {PDFPageProxy} page\n * @property {IPDFLinkService} linkService\n * @property {IDownloadManager} downloadManager\n * @property {string} [imageResourcesPath] - Path for image resources, mainly\n *   for annotation icons. Include trailing slash.\n * @property {boolean} renderForms\n * @property {boolean} [enableScripting] - Enable embedded script execution.\n * @property {boolean} [hasJSActions] - Some fields have JS actions.\n *   The default value is `false`.\n * @property {Map<string, HTMLCanvasElement>} [annotationCanvasMap]\n */\n\nclass AnnotationLayer {\n  /**\n   * Render a new annotation layer with all annotation elements.\n   *\n   * @public\n   * @param {AnnotationLayerParameters} parameters\n   * @memberof AnnotationLayer\n   */\n  static render(parameters) {\n    const sortedAnnotations = [],\n      popupAnnotations = [];\n    // Ensure that Popup annotations are handled last, since they're dependant\n    // upon the parent annotation having already been rendered (please refer to\n    // the `PopupAnnotationElement.render` method); fixes issue 11362.\n    for (const data of parameters.annotations) {\n      if (!data) {\n        continue;\n      }\n      if (data.annotationType === AnnotationType.POPUP) {\n        popupAnnotations.push(data);\n        continue;\n      }\n      sortedAnnotations.push(data);\n    }\n    if (popupAnnotations.length) {\n      sortedAnnotations.push(...popupAnnotations);\n    }\n\n    const div = parameters.div;\n\n    for (const data of sortedAnnotations) {\n      const element = AnnotationElementFactory.create({\n        data,\n        layer: div,\n        page: parameters.page,\n        viewport: parameters.viewport,\n        linkService: parameters.linkService,\n        downloadManager: parameters.downloadManager,\n        imageResourcesPath: parameters.imageResourcesPath || \"\",\n        renderForms: parameters.renderForms !== false,\n        svgFactory: new DOMSVGFactory(),\n        annotationStorage:\n          parameters.annotationStorage || new AnnotationStorage(),\n        enableScripting: parameters.enableScripting,\n        hasJSActions: parameters.hasJSActions,\n        fieldObjects: parameters.fieldObjects,\n        mouseState: parameters.mouseState || { isDown: false },\n      });\n      if (element.isRenderable) {\n        const rendered = element.render();\n        if (data.hidden) {\n          rendered.style.visibility = \"hidden\";\n        }\n        if (Array.isArray(rendered)) {\n          for (const renderedElement of rendered) {\n            div.appendChild(renderedElement);\n          }\n        } else {\n          if (element instanceof PopupAnnotationElement) {\n            // Popup annotation elements should not be on top of other\n            // annotation elements to prevent interfering with mouse events.\n            div.prepend(rendered);\n          } else {\n            div.appendChild(rendered);\n          }\n        }\n      }\n    }\n\n    this.#setAnnotationCanvasMap(div, parameters.annotationCanvasMap);\n  }\n\n  /**\n   * Update the annotation elements on existing annotation layer.\n   *\n   * @public\n   * @param {AnnotationLayerParameters} parameters\n   * @memberof AnnotationLayer\n   */\n  static update(parameters) {\n    const { page, viewport, annotations, annotationCanvasMap, div } =\n      parameters;\n    const transform = viewport.transform;\n    const matrix = `matrix(${transform.join(\",\")})`;\n\n    let scale, ownMatrix;\n    for (const data of annotations) {\n      const elements = div.querySelectorAll(\n        `[data-annotation-id=\"${data.id}\"]`\n      );\n      if (elements) {\n        for (const element of elements) {\n          if (data.hasOwnCanvas) {\n            const rect = Util.normalizeRect([\n              data.rect[0],\n              page.view[3] - data.rect[1] + page.view[1],\n              data.rect[2],\n              page.view[3] - data.rect[3] + page.view[1],\n            ]);\n\n            if (!ownMatrix) {\n              // When an annotation has its own canvas, then\n              // the scale has been already applied to the canvas,\n              // so we musn't scale it twice.\n              scale = Math.abs(transform[0] || transform[1]);\n              const ownTransform = transform.slice();\n              for (let i = 0; i < 4; i++) {\n                ownTransform[i] = Math.sign(ownTransform[i]);\n              }\n              ownMatrix = `matrix(${ownTransform.join(\",\")})`;\n            }\n\n            const left = rect[0] * scale;\n            const top = rect[1] * scale;\n            element.style.left = `${left}px`;\n            element.style.top = `${top}px`;\n            element.style.transformOrigin = `${-left}px ${-top}px`;\n            element.style.transform = ownMatrix;\n          } else {\n            element.style.transform = matrix;\n          }\n        }\n      }\n    }\n\n    this.#setAnnotationCanvasMap(div, annotationCanvasMap);\n    div.hidden = false;\n  }\n\n  static #setAnnotationCanvasMap(div, annotationCanvasMap) {\n    if (!annotationCanvasMap) {\n      return;\n    }\n    for (const [id, canvas] of annotationCanvasMap) {\n      const element = div.querySelector(`[data-annotation-id=\"${id}\"]`);\n      if (!element) {\n        continue;\n      }\n\n      const { firstChild } = element;\n      if (firstChild.nodeName === \"CANVAS\") {\n        element.replaceChild(canvas, firstChild);\n      } else {\n        element.insertBefore(canvas, firstChild);\n      }\n    }\n    annotationCanvasMap.clear();\n  }\n}\n\nexport { AnnotationLayer };\n","/* Copyright 2020 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * PLEASE NOTE: This file is currently imported in both the `../display/` and\n *              `../scripting_api/` folders, hence be EXTREMELY careful about\n *              introducing any dependencies here since that can lead to an\n *              unexpected/unnecessary size increase of the *built* files.\n */\n\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255)\n    .toString(16)\n    .padStart(2, \"0\");\n}\n\n// PDF specifications section 10.3\nclass ColorConverters {\n  static CMYK_G([c, y, m, k]) {\n    return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n  }\n\n  static G_CMYK([g]) {\n    return [\"CMYK\", 0, 0, 0, 1 - g];\n  }\n\n  static G_RGB([g]) {\n    return [\"RGB\", g, g, g];\n  }\n\n  static G_HTML([g]) {\n    const G = makeColorComp(g);\n    return `#${G}${G}${G}`;\n  }\n\n  static RGB_G([r, g, b]) {\n    return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n  }\n\n  static RGB_HTML([r, g, b]) {\n    const R = makeColorComp(r);\n    const G = makeColorComp(g);\n    const B = makeColorComp(b);\n    return `#${R}${G}${B}`;\n  }\n\n  static T_HTML() {\n    return \"#00000000\";\n  }\n\n  static CMYK_RGB([c, y, m, k]) {\n    return [\n      \"RGB\",\n      1 - Math.min(1, c + k),\n      1 - Math.min(1, m + k),\n      1 - Math.min(1, y + k),\n    ];\n  }\n\n  static CMYK_HTML(components) {\n    return this.RGB_HTML(this.CMYK_RGB(components));\n  }\n\n  static RGB_CMYK([r, g, b]) {\n    const c = 1 - r;\n    const m = 1 - g;\n    const y = 1 - b;\n    const k = Math.min(c, m, y);\n    return [\"CMYK\", c, m, y, k];\n  }\n}\n\nexport { ColorConverters };\n","/* Copyright 2021 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @typedef {import(\"./display_utils\").PageViewport} PageViewport */\n/** @typedef {import(\"../../web/interfaces\").IPDFLinkService} IPDFLinkService */\n\nimport { warn } from \"../shared/util.js\";\nimport { XfaText } from \"./xfa_text.js\";\n\n/**\n * @typedef {Object} XfaLayerParameters\n * @property {PageViewport} viewport\n * @property {HTMLDivElement} div\n * @property {Object} xfaHtml\n * @property {AnnotationStorage} [annotationStorage]\n * @property {IPDFLinkService} linkService\n * @property {string} [intent] - (default value is 'display').\n */\n\nclass XfaLayer {\n  static setupStorage(html, id, element, storage, intent) {\n    const storedData = storage.getValue(id, { value: null });\n    switch (element.name) {\n      case \"textarea\":\n        if (storedData.value !== null) {\n          html.textContent = storedData.value;\n        }\n        if (intent === \"print\") {\n          break;\n        }\n        html.addEventListener(\"input\", event => {\n          storage.setValue(id, { value: event.target.value });\n        });\n        break;\n      case \"input\":\n        if (\n          element.attributes.type === \"radio\" ||\n          element.attributes.type === \"checkbox\"\n        ) {\n          if (storedData.value === element.attributes.xfaOn) {\n            html.setAttribute(\"checked\", true);\n          } else if (storedData.value === element.attributes.xfaOff) {\n            // The checked attribute may have been set when opening the file,\n            // unset through the UI and we're here because of printing.\n            html.removeAttribute(\"checked\");\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"change\", event => {\n            storage.setValue(id, {\n              value: event.target.checked\n                ? event.target.getAttribute(\"xfaOn\")\n                : event.target.getAttribute(\"xfaOff\"),\n            });\n          });\n        } else {\n          if (storedData.value !== null) {\n            html.setAttribute(\"value\", storedData.value);\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"input\", event => {\n            storage.setValue(id, { value: event.target.value });\n          });\n        }\n        break;\n      case \"select\":\n        if (storedData.value !== null) {\n          for (const option of element.children) {\n            if (option.attributes.value === storedData.value) {\n              option.attributes.selected = true;\n            }\n          }\n        }\n        html.addEventListener(\"input\", event => {\n          const options = event.target.options;\n          const value =\n            options.selectedIndex === -1\n              ? \"\"\n              : options[options.selectedIndex].value;\n          storage.setValue(id, { value });\n        });\n        break;\n    }\n  }\n\n  static setAttributes({ html, element, storage = null, intent, linkService }) {\n    const { attributes } = element;\n    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n\n    if (attributes.type === \"radio\") {\n      // Avoid to have a radio group when printing with the same as one\n      // already displayed.\n      attributes.name = `${attributes.name}-${intent}`;\n    }\n    for (const [key, value] of Object.entries(attributes)) {\n      // We don't need to add dataId in the html object but it can\n      // be useful to know its value when writing printing tests:\n      // in this case, don't skip dataId to have its value.\n      if (value === null || value === undefined || key === \"dataId\") {\n        continue;\n      }\n\n      if (key !== \"style\") {\n        if (key === \"textContent\") {\n          html.textContent = value;\n        } else if (key === \"class\") {\n          if (value.length) {\n            html.setAttribute(key, value.join(\" \"));\n          }\n        } else {\n          if (isHTMLAnchorElement && (key === \"href\" || key === \"newWindow\")) {\n            continue; // Handled below.\n          }\n          html.setAttribute(key, value);\n        }\n      } else {\n        Object.assign(html.style, value);\n      }\n    }\n\n    if (isHTMLAnchorElement) {\n      if (\n        (typeof PDFJSDev === \"undefined\" || PDFJSDev.test(\"GENERIC\")) &&\n        !linkService.addLinkAttributes\n      ) {\n        warn(\n          \"XfaLayer.setAttribute - missing `addLinkAttributes`-method on the `linkService`-instance.\"\n        );\n      }\n      linkService.addLinkAttributes?.(\n        html,\n        attributes.href,\n        attributes.newWindow\n      );\n    }\n\n    // Set the value after the others to be sure overwrite\n    // any other values.\n    if (storage && attributes.dataId) {\n      this.setupStorage(html, attributes.dataId, element, storage);\n    }\n  }\n\n  /**\n   * Render the XFA layer.\n   *\n   * @param {XfaLayerParameters} parameters\n   */\n  static render(parameters) {\n    const storage = parameters.annotationStorage;\n    const linkService = parameters.linkService;\n    const root = parameters.xfaHtml;\n    const intent = parameters.intent || \"display\";\n    const rootHtml = document.createElement(root.name);\n    if (root.attributes) {\n      this.setAttributes({\n        html: rootHtml,\n        element: root,\n        intent,\n        linkService,\n      });\n    }\n    const stack = [[root, -1, rootHtml]];\n\n    const rootDiv = parameters.div;\n    rootDiv.appendChild(rootHtml);\n\n    if (parameters.viewport) {\n      const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n      rootDiv.style.transform = transform;\n    }\n\n    // Set defaults.\n    if (intent !== \"richText\") {\n      rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n    }\n\n    // Text nodes used for the text highlighter.\n    const textDivs = [];\n\n    while (stack.length > 0) {\n      const [parent, i, html] = stack[stack.length - 1];\n      if (i + 1 === parent.children.length) {\n        stack.pop();\n        continue;\n      }\n\n      const child = parent.children[++stack[stack.length - 1][1]];\n      if (child === null) {\n        continue;\n      }\n\n      const { name } = child;\n      if (name === \"#text\") {\n        const node = document.createTextNode(child.value);\n        textDivs.push(node);\n        html.appendChild(node);\n        continue;\n      }\n\n      let childHtml;\n      if (child?.attributes?.xmlns) {\n        childHtml = document.createElementNS(child.attributes.xmlns, name);\n      } else {\n        childHtml = document.createElement(name);\n      }\n\n      html.appendChild(childHtml);\n      if (child.attributes) {\n        this.setAttributes({\n          html: childHtml,\n          element: child,\n          storage,\n          intent,\n          linkService,\n        });\n      }\n\n      if (child.children && child.children.length > 0) {\n        stack.push([child, -1, childHtml]);\n      } else if (child.value) {\n        const node = document.createTextNode(child.value);\n        if (XfaText.shouldBuildText(name)) {\n          textDivs.push(node);\n        }\n        childHtml.appendChild(node);\n      }\n    }\n\n    /**\n     * TODO: re-enable that stuff once we've JS implementation.\n     * See https://bugzilla.mozilla.org/show_bug.cgi?id=1719465.\n     *\n     * for (const el of rootDiv.querySelectorAll(\n     * \".xfaDisabled input, .xfaDisabled textarea\"\n     * )) {\n     * el.setAttribute(\"disabled\", true);\n     * }\n     * for (const el of rootDiv.querySelectorAll(\n     * \".xfaReadOnly input, .xfaReadOnly textarea\"\n     * )) {\n     * el.setAttribute(\"readOnly\", true);\n     * }\n     */\n\n    for (const el of rootDiv.querySelectorAll(\n      \".xfaNonInteractive input, .xfaNonInteractive textarea\"\n    )) {\n      el.setAttribute(\"readOnly\", true);\n    }\n\n    return {\n      textDivs,\n    };\n  }\n\n  /**\n   * Update the XFA layer.\n   *\n   * @param {XfaLayerParameters} parameters\n   */\n  static update(parameters) {\n    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n    parameters.div.style.transform = transform;\n    parameters.div.hidden = false;\n  }\n}\n\nexport { XfaLayer };\n","/* Copyright 2015 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbortException,\n  createPromiseCapability,\n  Util,\n} from \"../shared/util.js\";\n\n/**\n * Text layer render parameters.\n *\n * @typedef {Object} TextLayerRenderParameters\n * @property {import(\"./api\").TextContent} [textContent] - Text content to\n *   render (the object is returned by the page's `getTextContent` method).\n * @property {ReadableStream} [textContentStream] - Text content stream to\n *   render (the stream is returned by the page's `streamTextContent` method).\n * @property {HTMLElement} container - HTML element that will contain text runs.\n * @property {import(\"./display_utils\").PageViewport} viewport - The target\n *   viewport to properly layout the text runs.\n * @property {Array<HTMLElement>} [textDivs] - HTML elements that are correspond\n *   to the text items of the textContent input. This is output and shall be\n *   initially be set to empty array.\n * @property {Array<string>} [textContentItemsStr] - Strings that correspond to\n *    the `str` property of the text items of textContent input. This is output\n *   and shall be initially be set to empty array.\n * @property {number} [timeout] - Delay in milliseconds before rendering of the\n *   text runs occurs.\n * @property {boolean} [enhanceTextSelection] - Whether to turn on the text\n *   selection enhancement.\n */\n\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nconst DEFAULT_FONT_ASCENT = 0.8;\nconst ascentCache = new Map();\nconst AllWhitespaceRegexp = /^\\s+$/g;\n\nfunction getAscent(fontFamily, ctx) {\n  const cachedAscent = ascentCache.get(fontFamily);\n  if (cachedAscent) {\n    return cachedAscent;\n  }\n\n  ctx.save();\n  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;\n  const metrics = ctx.measureText(\"\");\n\n  // Both properties aren't available by default in Firefox.\n  let ascent = metrics.fontBoundingBoxAscent;\n  let descent = Math.abs(metrics.fontBoundingBoxDescent);\n  if (ascent) {\n    ctx.restore();\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n\n  // Try basic heuristic to guess ascent/descent.\n  // Draw a g with baseline at 0,0 and then get the line\n  // number where a pixel has non-null red component (starting\n  // from bottom).\n  ctx.strokeStyle = \"red\";\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"g\", 0, 0);\n  let pixels = ctx.getImageData(\n    0,\n    0,\n    DEFAULT_FONT_SIZE,\n    DEFAULT_FONT_SIZE\n  ).data;\n  descent = 0;\n  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {\n    if (pixels[i] > 0) {\n      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n\n  // Draw an A with baseline at 0,DEFAULT_FONT_SIZE and then get the line\n  // number where a pixel has non-null red component (starting\n  // from top).\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  ascent = 0;\n  for (let i = 0, ii = pixels.length; i < ii; i += 4) {\n    if (pixels[i] > 0) {\n      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n\n  ctx.restore();\n\n  if (ascent) {\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n\n  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n  return DEFAULT_FONT_ASCENT;\n}\n\nfunction appendText(task, geom, styles, ctx) {\n  // Initialize all used properties to keep the caches monomorphic.\n  const textDiv = document.createElement(\"span\");\n  const textDivProperties = task._enhanceTextSelection\n    ? {\n        angle: 0,\n        canvasWidth: 0,\n        hasText: geom.str !== \"\",\n        hasEOL: geom.hasEOL,\n        originalTransform: null,\n        paddingBottom: 0,\n        paddingLeft: 0,\n        paddingRight: 0,\n        paddingTop: 0,\n        scale: 1,\n      }\n    : {\n        angle: 0,\n        canvasWidth: 0,\n        hasText: geom.str !== \"\",\n        hasEOL: geom.hasEOL,\n      };\n\n  task._textDivs.push(textDiv);\n\n  const tx = Util.transform(task._viewport.transform, geom.transform);\n  let angle = Math.atan2(tx[1], tx[0]);\n  const style = styles[geom.fontName];\n  if (style.vertical) {\n    angle += Math.PI / 2;\n  }\n  const fontHeight = Math.hypot(tx[2], tx[3]);\n  const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);\n\n  let left, top;\n  if (angle === 0) {\n    left = tx[4];\n    top = tx[5] - fontAscent;\n  } else {\n    left = tx[4] + fontAscent * Math.sin(angle);\n    top = tx[5] - fontAscent * Math.cos(angle);\n  }\n  // Setting the style properties individually, rather than all at once,\n  // should be OK since the `textDiv` isn't appended to the document yet.\n  textDiv.style.left = `${left}px`;\n  textDiv.style.top = `${top}px`;\n  textDiv.style.fontSize = `${fontHeight}px`;\n  textDiv.style.fontFamily = style.fontFamily;\n\n  // Keeps screen readers from pausing on every new text span.\n  textDiv.setAttribute(\"role\", \"presentation\");\n\n  textDiv.textContent = geom.str;\n  // geom.dir may be 'ttb' for vertical texts.\n  textDiv.dir = geom.dir;\n\n  // `fontName` is only used by the FontInspector, and we only use `dataset`\n  // here to make the font name available in the debugger.\n  if (task._fontInspectorEnabled) {\n    textDiv.dataset.fontName = geom.fontName;\n  }\n  if (angle !== 0) {\n    textDivProperties.angle = angle * (180 / Math.PI);\n  }\n  // We don't bother scaling single-char text divs, because it has very\n  // little effect on text highlighting. This makes scrolling on docs with\n  // lots of such divs a lot faster.\n  let shouldScaleText = false;\n  if (\n    geom.str.length > 1 ||\n    (task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str))\n  ) {\n    shouldScaleText = true;\n  } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n    const absScaleX = Math.abs(geom.transform[0]),\n      absScaleY = Math.abs(geom.transform[3]);\n    // When the horizontal/vertical scaling differs significantly, also scale\n    // even single-char text to improve highlighting (fixes issue11713.pdf).\n    if (\n      absScaleX !== absScaleY &&\n      Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5\n    ) {\n      shouldScaleText = true;\n    }\n  }\n  if (shouldScaleText) {\n    if (style.vertical) {\n      textDivProperties.canvasWidth = geom.height * task._viewport.scale;\n    } else {\n      textDivProperties.canvasWidth = geom.width * task._viewport.scale;\n    }\n  }\n  task._textDivProperties.set(textDiv, textDivProperties);\n  if (task._textContentStream) {\n    task._layoutText(textDiv);\n  }\n\n  if (task._enhanceTextSelection && textDivProperties.hasText) {\n    let angleCos = 1,\n      angleSin = 0;\n    if (angle !== 0) {\n      angleCos = Math.cos(angle);\n      angleSin = Math.sin(angle);\n    }\n    const divWidth =\n      (style.vertical ? geom.height : geom.width) * task._viewport.scale;\n    const divHeight = fontHeight;\n\n    let m, b;\n    if (angle !== 0) {\n      m = [angleCos, angleSin, -angleSin, angleCos, left, top];\n      b = Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\n    } else {\n      b = [left, top, left + divWidth, top + divHeight];\n    }\n\n    task._bounds.push({\n      left: b[0],\n      top: b[1],\n      right: b[2],\n      bottom: b[3],\n      div: textDiv,\n      size: [divWidth, divHeight],\n      m,\n    });\n  }\n}\n\nfunction render(task) {\n  if (task._canceled) {\n    return;\n  }\n  const textDivs = task._textDivs;\n  const capability = task._capability;\n  const textDivsLength = textDivs.length;\n\n  // No point in rendering many divs as it would make the browser\n  // unusable even after the divs are rendered.\n  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n    task._renderingDone = true;\n    capability.resolve();\n    return;\n  }\n\n  if (!task._textContentStream) {\n    for (let i = 0; i < textDivsLength; i++) {\n      task._layoutText(textDivs[i]);\n    }\n  }\n\n  task._renderingDone = true;\n  capability.resolve();\n}\n\nfunction findPositiveMin(ts, offset, count) {\n  let result = 0;\n  for (let i = 0; i < count; i++) {\n    const t = ts[offset++];\n    if (t > 0) {\n      result = result ? Math.min(t, result) : t;\n    }\n  }\n  return result;\n}\n\nfunction expand(task) {\n  const bounds = task._bounds;\n  const viewport = task._viewport;\n\n  const expanded = expandBounds(viewport.width, viewport.height, bounds);\n  for (let i = 0; i < expanded.length; i++) {\n    const div = bounds[i].div;\n    const divProperties = task._textDivProperties.get(div);\n    if (divProperties.angle === 0) {\n      divProperties.paddingLeft = bounds[i].left - expanded[i].left;\n      divProperties.paddingTop = bounds[i].top - expanded[i].top;\n      divProperties.paddingRight = expanded[i].right - bounds[i].right;\n      divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\n      task._textDivProperties.set(div, divProperties);\n      continue;\n    }\n    // Box is rotated -- trying to find padding so rotated div will not\n    // exceed its expanded bounds.\n    const e = expanded[i],\n      b = bounds[i];\n    const m = b.m,\n      c = m[0],\n      s = m[1];\n    // Finding intersections with expanded box.\n    const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\n    const ts = new Float64Array(64);\n    for (let j = 0, jj = points.length; j < jj; j++) {\n      const t = Util.applyTransform(points[j], m);\n      ts[j + 0] = c && (e.left - t[0]) / c;\n      ts[j + 4] = s && (e.top - t[1]) / s;\n      ts[j + 8] = c && (e.right - t[0]) / c;\n      ts[j + 12] = s && (e.bottom - t[1]) / s;\n\n      ts[j + 16] = s && (e.left - t[0]) / -s;\n      ts[j + 20] = c && (e.top - t[1]) / c;\n      ts[j + 24] = s && (e.right - t[0]) / -s;\n      ts[j + 28] = c && (e.bottom - t[1]) / c;\n\n      ts[j + 32] = c && (e.left - t[0]) / -c;\n      ts[j + 36] = s && (e.top - t[1]) / -s;\n      ts[j + 40] = c && (e.right - t[0]) / -c;\n      ts[j + 44] = s && (e.bottom - t[1]) / -s;\n\n      ts[j + 48] = s && (e.left - t[0]) / s;\n      ts[j + 52] = c && (e.top - t[1]) / -c;\n      ts[j + 56] = s && (e.right - t[0]) / s;\n      ts[j + 60] = c && (e.bottom - t[1]) / -c;\n    }\n    // Not based on math, but to simplify calculations, using cos and sin\n    // absolute values to not exceed the box (it can but insignificantly).\n    const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\n    divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\n    divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\n    divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\n    divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\n    task._textDivProperties.set(div, divProperties);\n  }\n}\n\nfunction expandBounds(width, height, boxes) {\n  const bounds = boxes.map(function (box, i) {\n    return {\n      x1: box.left,\n      y1: box.top,\n      x2: box.right,\n      y2: box.bottom,\n      index: i,\n      x1New: undefined,\n      x2New: undefined,\n    };\n  });\n  expandBoundsLTR(width, bounds);\n\n  const expanded = new Array(boxes.length);\n  for (const b of bounds) {\n    const i = b.index;\n    expanded[i] = {\n      left: b.x1New,\n      top: 0,\n      right: b.x2New,\n      bottom: 0,\n    };\n  }\n\n  // Rotating on 90 degrees and extending extended boxes. Reusing the bounds\n  // array and objects.\n  boxes.map(function (box, i) {\n    const e = expanded[i],\n      b = bounds[i];\n    b.x1 = box.top;\n    b.y1 = width - e.right;\n    b.x2 = box.bottom;\n    b.y2 = width - e.left;\n    b.index = i;\n    b.x1New = undefined;\n    b.x2New = undefined;\n  });\n  expandBoundsLTR(height, bounds);\n\n  for (const b of bounds) {\n    const i = b.index;\n    expanded[i].top = b.x1New;\n    expanded[i].bottom = b.x2New;\n  }\n  return expanded;\n}\n\nfunction expandBoundsLTR(width, bounds) {\n  // Sorting by x1 coordinate and walk by the bounds in the same order.\n  bounds.sort(function (a, b) {\n    return a.x1 - b.x1 || a.index - b.index;\n  });\n\n  // First we see on the horizon is a fake boundary.\n  const fakeBoundary = {\n    x1: -Infinity,\n    y1: -Infinity,\n    x2: 0,\n    y2: Infinity,\n    index: -1,\n    x1New: 0,\n    x2New: 0,\n  };\n  const horizon = [\n    {\n      start: -Infinity,\n      end: Infinity,\n      boundary: fakeBoundary,\n    },\n  ];\n\n  for (const boundary of bounds) {\n    // Searching for the affected part of horizon.\n    // TODO red-black tree or simple binary search\n    let i = 0;\n    while (i < horizon.length && horizon[i].end <= boundary.y1) {\n      i++;\n    }\n    let j = horizon.length - 1;\n    while (j >= 0 && horizon[j].start >= boundary.y2) {\n      j--;\n    }\n\n    let horizonPart, affectedBoundary;\n    let q,\n      k,\n      maxXNew = -Infinity;\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      let xNew;\n      if (affectedBoundary.x2 > boundary.x1) {\n        // In the middle of the previous element, new x shall be at the\n        // boundary start. Extending if further if the affected boundary\n        // placed on top of the current one.\n        xNew =\n          affectedBoundary.index > boundary.index\n            ? affectedBoundary.x1New\n            : boundary.x1;\n      } else if (affectedBoundary.x2New === undefined) {\n        // We have some space in between, new x in middle will be a fair\n        // choice.\n        xNew = (affectedBoundary.x2 + boundary.x1) / 2;\n      } else {\n        // Affected boundary has x2new set, using it as new x.\n        xNew = affectedBoundary.x2New;\n      }\n      if (xNew > maxXNew) {\n        maxXNew = xNew;\n      }\n    }\n\n    // Set new x1 for current boundary.\n    boundary.x1New = maxXNew;\n\n    // Adjusts new x2 for the affected boundaries.\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      if (affectedBoundary.x2New === undefined) {\n        // Was not set yet, choosing new x if possible.\n        if (affectedBoundary.x2 > boundary.x1) {\n          // Current and affected boundaries intersect. If affected boundary\n          // is placed on top of the current, shrinking the affected.\n          if (affectedBoundary.index > boundary.index) {\n            affectedBoundary.x2New = affectedBoundary.x2;\n          }\n        } else {\n          affectedBoundary.x2New = maxXNew;\n        }\n      } else if (affectedBoundary.x2New > maxXNew) {\n        // Affected boundary is touching new x, pushing it back.\n        affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\n      }\n    }\n\n    // Fixing the horizon.\n    const changedHorizon = [];\n    let lastBoundary = null;\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      // Checking which boundary will be visible.\n      const useBoundary =\n        affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\n      if (lastBoundary === useBoundary) {\n        // Merging with previous.\n        changedHorizon[changedHorizon.length - 1].end = horizonPart.end;\n      } else {\n        changedHorizon.push({\n          start: horizonPart.start,\n          end: horizonPart.end,\n          boundary: useBoundary,\n        });\n        lastBoundary = useBoundary;\n      }\n    }\n    if (horizon[i].start < boundary.y1) {\n      changedHorizon[0].start = boundary.y1;\n      changedHorizon.unshift({\n        start: horizon[i].start,\n        end: boundary.y1,\n        boundary: horizon[i].boundary,\n      });\n    }\n    if (boundary.y2 < horizon[j].end) {\n      changedHorizon[changedHorizon.length - 1].end = boundary.y2;\n      changedHorizon.push({\n        start: boundary.y2,\n        end: horizon[j].end,\n        boundary: horizon[j].boundary,\n      });\n    }\n\n    // Set x2 new of boundary that is no longer visible (see overlapping case\n    // above).\n    // TODO more efficient, e.g. via reference counting.\n    for (q = i; q <= j; q++) {\n      horizonPart = horizon[q];\n      affectedBoundary = horizonPart.boundary;\n      if (affectedBoundary.x2New !== undefined) {\n        continue;\n      }\n      let used = false;\n      for (\n        k = i - 1;\n        !used && k >= 0 && horizon[k].start >= affectedBoundary.y1;\n        k--\n      ) {\n        used = horizon[k].boundary === affectedBoundary;\n      }\n      for (\n        k = j + 1;\n        !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2;\n        k++\n      ) {\n        used = horizon[k].boundary === affectedBoundary;\n      }\n      for (k = 0; !used && k < changedHorizon.length; k++) {\n        used = changedHorizon[k].boundary === affectedBoundary;\n      }\n      if (!used) {\n        affectedBoundary.x2New = maxXNew;\n      }\n    }\n\n    Array.prototype.splice.apply(\n      horizon,\n      [i, j - i + 1].concat(changedHorizon)\n    );\n  }\n\n  // Set new x2 for all unset boundaries.\n  for (const horizonPart of horizon) {\n    const affectedBoundary = horizonPart.boundary;\n    if (affectedBoundary.x2New === undefined) {\n      affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\n    }\n  }\n}\n\nclass TextLayerRenderTask {\n  constructor({\n    textContent,\n    textContentStream,\n    container,\n    viewport,\n    textDivs,\n    textContentItemsStr,\n    enhanceTextSelection,\n  }) {\n    this._textContent = textContent;\n    this._textContentStream = textContentStream;\n    this._container = container;\n    this._document = container.ownerDocument;\n    this._viewport = viewport;\n    this._textDivs = textDivs || [];\n    this._textContentItemsStr = textContentItemsStr || [];\n    this._enhanceTextSelection = !!enhanceTextSelection;\n    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n\n    this._reader = null;\n    this._layoutTextLastFontSize = null;\n    this._layoutTextLastFontFamily = null;\n    this._layoutTextCtx = null;\n    this._textDivProperties = new WeakMap();\n    this._renderingDone = false;\n    this._canceled = false;\n    this._capability = createPromiseCapability();\n    this._renderTimer = null;\n    this._bounds = [];\n\n    // Always clean-up the temporary canvas once rendering is no longer pending.\n    this._capability.promise\n      .finally(() => {\n        if (!this._enhanceTextSelection) {\n          // The `textDiv` properties are no longer needed.\n          this._textDivProperties = null;\n        }\n\n        if (this._layoutTextCtx) {\n          // Zeroing the width and height cause Firefox to release graphics\n          // resources immediately, which can greatly reduce memory consumption.\n          this._layoutTextCtx.canvas.width = 0;\n          this._layoutTextCtx.canvas.height = 0;\n          this._layoutTextCtx = null;\n        }\n      })\n      .catch(() => {\n        // Avoid \"Uncaught promise\" messages in the console.\n      });\n  }\n\n  /**\n   * Promise for textLayer rendering task completion.\n   * @type {Promise<void>}\n   */\n  get promise() {\n    return this._capability.promise;\n  }\n\n  /**\n   * Cancel rendering of the textLayer.\n   */\n  cancel() {\n    this._canceled = true;\n    if (this._reader) {\n      this._reader\n        .cancel(new AbortException(\"TextLayer task cancelled.\"))\n        .catch(() => {\n          // Avoid \"Uncaught promise\" messages in the console.\n        });\n      this._reader = null;\n    }\n    if (this._renderTimer !== null) {\n      clearTimeout(this._renderTimer);\n      this._renderTimer = null;\n    }\n    this._capability.reject(new Error(\"TextLayer task cancelled.\"));\n  }\n\n  /**\n   * @private\n   */\n  _processItems(items, styleCache) {\n    for (let i = 0, len = items.length; i < len; i++) {\n      if (items[i].str === undefined) {\n        if (\n          items[i].type === \"beginMarkedContentProps\" ||\n          items[i].type === \"beginMarkedContent\"\n        ) {\n          const parent = this._container;\n          this._container = document.createElement(\"span\");\n          this._container.classList.add(\"markedContent\");\n          if (items[i].id !== null) {\n            this._container.setAttribute(\"id\", `${items[i].id}`);\n          }\n          parent.appendChild(this._container);\n        } else if (items[i].type === \"endMarkedContent\") {\n          this._container = this._container.parentNode;\n        }\n        continue;\n      }\n      this._textContentItemsStr.push(items[i].str);\n      appendText(this, items[i], styleCache, this._layoutTextCtx);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _layoutText(textDiv) {\n    const textDivProperties = this._textDivProperties.get(textDiv);\n\n    let transform = \"\";\n    if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {\n      const { fontSize, fontFamily } = textDiv.style;\n\n      // Only build font string and set to context if different from last.\n      if (\n        fontSize !== this._layoutTextLastFontSize ||\n        fontFamily !== this._layoutTextLastFontFamily\n      ) {\n        this._layoutTextCtx.font = `${fontSize} ${fontFamily}`;\n        this._layoutTextLastFontSize = fontSize;\n        this._layoutTextLastFontFamily = fontFamily;\n      }\n      // Only measure the width for multi-char text divs, see `appendText`.\n      const { width } = this._layoutTextCtx.measureText(textDiv.textContent);\n\n      if (width > 0) {\n        const scale = textDivProperties.canvasWidth / width;\n        if (this._enhanceTextSelection) {\n          textDivProperties.scale = scale;\n        }\n        transform = `scaleX(${scale})`;\n      }\n    }\n    if (textDivProperties.angle !== 0) {\n      transform = `rotate(${textDivProperties.angle}deg) ${transform}`;\n    }\n    if (transform.length > 0) {\n      if (this._enhanceTextSelection) {\n        textDivProperties.originalTransform = transform;\n      }\n      textDiv.style.transform = transform;\n    }\n\n    if (textDivProperties.hasText) {\n      this._container.appendChild(textDiv);\n    }\n    if (textDivProperties.hasEOL) {\n      const br = document.createElement(\"br\");\n      br.setAttribute(\"role\", \"presentation\");\n      this._container.appendChild(br);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _render(timeout = 0) {\n    const capability = createPromiseCapability();\n    let styleCache = Object.create(null);\n\n    // The temporary canvas is used to measure text length in the DOM.\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.height = canvas.width = DEFAULT_FONT_SIZE;\n\n    if (\n      typeof PDFJSDev === \"undefined\" ||\n      PDFJSDev.test(\"MOZCENTRAL || GENERIC\")\n    ) {\n      canvas.mozOpaque = true;\n    }\n    this._layoutTextCtx = canvas.getContext(\"2d\", { alpha: false });\n\n    if (this._textContent) {\n      const textItems = this._textContent.items;\n      const textStyles = this._textContent.styles;\n      this._processItems(textItems, textStyles);\n      capability.resolve();\n    } else if (this._textContentStream) {\n      const pump = () => {\n        this._reader.read().then(({ value, done }) => {\n          if (done) {\n            capability.resolve();\n            return;\n          }\n\n          Object.assign(styleCache, value.styles);\n          this._processItems(value.items, styleCache);\n          pump();\n        }, capability.reject);\n      };\n\n      this._reader = this._textContentStream.getReader();\n      pump();\n    } else {\n      throw new Error(\n        'Neither \"textContent\" nor \"textContentStream\" parameters specified.'\n      );\n    }\n\n    capability.promise.then(() => {\n      styleCache = null;\n      if (!timeout) {\n        // Render right away\n        render(this);\n      } else {\n        // Schedule\n        this._renderTimer = setTimeout(() => {\n          render(this);\n          this._renderTimer = null;\n        }, timeout);\n      }\n    }, this._capability.reject);\n  }\n\n  /**\n   * @param {boolean} [expandDivs]\n   */\n  expandTextDivs(expandDivs = false) {\n    if (!this._enhanceTextSelection || !this._renderingDone) {\n      return;\n    }\n    if (this._bounds !== null) {\n      expand(this);\n      this._bounds = null;\n    }\n    const transformBuf = [],\n      paddingBuf = [];\n\n    for (let i = 0, ii = this._textDivs.length; i < ii; i++) {\n      const div = this._textDivs[i];\n      const divProps = this._textDivProperties.get(div);\n\n      if (!divProps.hasText) {\n        continue;\n      }\n      if (expandDivs) {\n        transformBuf.length = 0;\n        paddingBuf.length = 0;\n\n        if (divProps.originalTransform) {\n          transformBuf.push(divProps.originalTransform);\n        }\n        if (divProps.paddingTop > 0) {\n          paddingBuf.push(`${divProps.paddingTop}px`);\n          transformBuf.push(`translateY(${-divProps.paddingTop}px)`);\n        } else {\n          paddingBuf.push(0);\n        }\n        if (divProps.paddingRight > 0) {\n          paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);\n        } else {\n          paddingBuf.push(0);\n        }\n        if (divProps.paddingBottom > 0) {\n          paddingBuf.push(`${divProps.paddingBottom}px`);\n        } else {\n          paddingBuf.push(0);\n        }\n        if (divProps.paddingLeft > 0) {\n          paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);\n          transformBuf.push(\n            `translateX(${-divProps.paddingLeft / divProps.scale}px)`\n          );\n        } else {\n          paddingBuf.push(0);\n        }\n\n        div.style.padding = paddingBuf.join(\" \");\n        if (transformBuf.length) {\n          div.style.transform = transformBuf.join(\" \");\n        }\n      } else {\n        div.style.padding = null;\n        div.style.transform = divProps.originalTransform;\n      }\n    }\n  }\n}\n\n/**\n * @param {TextLayerRenderParameters} renderParameters\n * @returns {TextLayerRenderTask}\n */\nfunction renderTextLayer(renderParameters) {\n  const task = new TextLayerRenderTask({\n    textContent: renderParameters.textContent,\n    textContentStream: renderParameters.textContentStream,\n    container: renderParameters.container,\n    viewport: renderParameters.viewport,\n    textDivs: renderParameters.textDivs,\n    textContentItemsStr: renderParameters.textContentItemsStr,\n    enhanceTextSelection: renderParameters.enhanceTextSelection,\n  });\n  task._render(renderParameters.timeout);\n  return task;\n}\n\nexport { renderTextLayer };\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* globals __non_webpack_require__ */\n\nimport {\n  createObjectURL,\n  FONT_IDENTITY_MATRIX,\n  IDENTITY_MATRIX,\n  ImageKind,\n  isNum,\n  OPS,\n  TextRenderingMode,\n  unreachable,\n  Util,\n  warn,\n} from \"../shared/util.js\";\nimport { DOMSVGFactory } from \"./display_utils.js\";\nimport { isNodeJS } from \"../shared/is_node.js\";\n\n/** @type {any} */\nlet SVGGraphics = class {\n  constructor() {\n    unreachable(\"Not implemented: SVGGraphics\");\n  }\n};\n\nif (\n  typeof PDFJSDev === \"undefined\" ||\n  PDFJSDev.test(\"!PRODUCTION || GENERIC\")\n) {\n  const SVG_DEFAULTS = {\n    fontStyle: \"normal\",\n    fontWeight: \"normal\",\n    fillColor: \"#000000\",\n  };\n  const XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n  const XLINK_NS = \"http://www.w3.org/1999/xlink\";\n  const LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n  const LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n\n  const convertImgDataToPng = (function () {\n    const PNG_HEADER = new Uint8Array([\n      0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,\n    ]);\n    const CHUNK_WRAPPER_SIZE = 12;\n\n    const crcTable = new Int32Array(256);\n    for (let i = 0; i < 256; i++) {\n      let c = i;\n      for (let h = 0; h < 8; h++) {\n        if (c & 1) {\n          c = 0xedb88320 ^ ((c >> 1) & 0x7fffffff);\n        } else {\n          c = (c >> 1) & 0x7fffffff;\n        }\n      }\n      crcTable[i] = c;\n    }\n\n    function crc32(data, start, end) {\n      let crc = -1;\n      for (let i = start; i < end; i++) {\n        const a = (crc ^ data[i]) & 0xff;\n        const b = crcTable[a];\n        crc = (crc >>> 8) ^ b;\n      }\n      return crc ^ -1;\n    }\n\n    function writePngChunk(type, body, data, offset) {\n      let p = offset;\n      const len = body.length;\n\n      data[p] = (len >> 24) & 0xff;\n      data[p + 1] = (len >> 16) & 0xff;\n      data[p + 2] = (len >> 8) & 0xff;\n      data[p + 3] = len & 0xff;\n      p += 4;\n\n      data[p] = type.charCodeAt(0) & 0xff;\n      data[p + 1] = type.charCodeAt(1) & 0xff;\n      data[p + 2] = type.charCodeAt(2) & 0xff;\n      data[p + 3] = type.charCodeAt(3) & 0xff;\n      p += 4;\n\n      data.set(body, p);\n      p += body.length;\n\n      const crc = crc32(data, offset + 4, p);\n      data[p] = (crc >> 24) & 0xff;\n      data[p + 1] = (crc >> 16) & 0xff;\n      data[p + 2] = (crc >> 8) & 0xff;\n      data[p + 3] = crc & 0xff;\n    }\n\n    function adler32(data, start, end) {\n      let a = 1;\n      let b = 0;\n      for (let i = start; i < end; ++i) {\n        a = (a + (data[i] & 0xff)) % 65521;\n        b = (b + a) % 65521;\n      }\n      return (b << 16) | a;\n    }\n\n    /**\n     * @param {Uint8Array} literals The input data.\n     * @returns {Uint8Array} The DEFLATE-compressed data stream in zlib format.\n     *   This is the required format for compressed streams in the PNG format:\n     *   http://www.libpng.org/pub/png/spec/1.2/PNG-Compression.html\n     */\n    function deflateSync(literals) {\n      if (!isNodeJS) {\n        // zlib is certainly not available outside of Node.js. We can either use\n        // the pako library for client-side DEFLATE compression, or use the\n        // canvas API of the browser to obtain a more optimal PNG file.\n        return deflateSyncUncompressed(literals);\n      }\n      try {\n        // NOTE: This implementation is far from perfect, but already way better\n        // than not applying any compression.\n        //\n        // A better algorithm will try to choose a good predictor/filter and\n        // then choose a suitable zlib compression strategy (e.g. 3,Z_RLE).\n        //\n        // Node v0.11.12 zlib.deflateSync is introduced (and returns a Buffer).\n        // Node v3.0.0   Buffer inherits from Uint8Array.\n        // Node v8.0.0   zlib.deflateSync accepts Uint8Array as input.\n        let input;\n        // eslint-disable-next-line no-undef\n        if (parseInt(process.versions.node) >= 8) {\n          input = literals;\n        } else {\n          // eslint-disable-next-line no-undef\n          input = Buffer.from(literals);\n        }\n        const output = __non_webpack_require__(\"zlib\").deflateSync(input, {\n          level: 9,\n        });\n        return output instanceof Uint8Array ? output : new Uint8Array(output);\n      } catch (e) {\n        warn(\n          \"Not compressing PNG because zlib.deflateSync is unavailable: \" + e\n        );\n      }\n\n      return deflateSyncUncompressed(literals);\n    }\n\n    // An implementation of DEFLATE with compression level 0 (Z_NO_COMPRESSION).\n    function deflateSyncUncompressed(literals) {\n      let len = literals.length;\n      const maxBlockLength = 0xffff;\n\n      const deflateBlocks = Math.ceil(len / maxBlockLength);\n      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n      let pi = 0;\n      idat[pi++] = 0x78; // compression method and flags\n      idat[pi++] = 0x9c; // flags\n\n      let pos = 0;\n      while (len > maxBlockLength) {\n        // writing non-final DEFLATE blocks type 0 and length of 65535\n        idat[pi++] = 0x00;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0x00;\n        idat[pi++] = 0x00;\n        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n        pi += maxBlockLength;\n        pos += maxBlockLength;\n        len -= maxBlockLength;\n      }\n\n      // writing non-final DEFLATE blocks type 0\n      idat[pi++] = 0x01;\n      idat[pi++] = len & 0xff;\n      idat[pi++] = (len >> 8) & 0xff;\n      idat[pi++] = ~len & 0xffff & 0xff;\n      idat[pi++] = ((~len & 0xffff) >> 8) & 0xff;\n      idat.set(literals.subarray(pos), pi);\n      pi += literals.length - pos;\n\n      const adler = adler32(literals, 0, literals.length); // checksum\n      idat[pi++] = (adler >> 24) & 0xff;\n      idat[pi++] = (adler >> 16) & 0xff;\n      idat[pi++] = (adler >> 8) & 0xff;\n      idat[pi++] = adler & 0xff;\n      return idat;\n    }\n\n    function encode(imgData, kind, forceDataSchema, isMask) {\n      const width = imgData.width;\n      const height = imgData.height;\n      let bitDepth, colorType, lineSize;\n      const bytes = imgData.data;\n\n      switch (kind) {\n        case ImageKind.GRAYSCALE_1BPP:\n          colorType = 0;\n          bitDepth = 1;\n          lineSize = (width + 7) >> 3;\n          break;\n        case ImageKind.RGB_24BPP:\n          colorType = 2;\n          bitDepth = 8;\n          lineSize = width * 3;\n          break;\n        case ImageKind.RGBA_32BPP:\n          colorType = 6;\n          bitDepth = 8;\n          lineSize = width * 4;\n          break;\n        default:\n          throw new Error(\"invalid format\");\n      }\n\n      // prefix every row with predictor 0\n      const literals = new Uint8Array((1 + lineSize) * height);\n      let offsetLiterals = 0,\n        offsetBytes = 0;\n      for (let y = 0; y < height; ++y) {\n        literals[offsetLiterals++] = 0; // no prediction\n        literals.set(\n          bytes.subarray(offsetBytes, offsetBytes + lineSize),\n          offsetLiterals\n        );\n        offsetBytes += lineSize;\n        offsetLiterals += lineSize;\n      }\n\n      if (kind === ImageKind.GRAYSCALE_1BPP && isMask) {\n        // inverting for image masks\n        offsetLiterals = 0;\n        for (let y = 0; y < height; y++) {\n          offsetLiterals++; // skipping predictor\n          for (let i = 0; i < lineSize; i++) {\n            literals[offsetLiterals++] ^= 0xff;\n          }\n        }\n      }\n\n      const ihdr = new Uint8Array([\n        (width >> 24) & 0xff,\n        (width >> 16) & 0xff,\n        (width >> 8) & 0xff,\n        width & 0xff,\n        (height >> 24) & 0xff,\n        (height >> 16) & 0xff,\n        (height >> 8) & 0xff,\n        height & 0xff,\n        bitDepth, // bit depth\n        colorType, // color type\n        0x00, // compression method\n        0x00, // filter method\n        0x00, // interlace method\n      ]);\n      const idat = deflateSync(literals);\n\n      // PNG consists of: header, IHDR+data, IDAT+data, and IEND.\n      const pngLength =\n        PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n      const data = new Uint8Array(pngLength);\n      let offset = 0;\n      data.set(PNG_HEADER, offset);\n      offset += PNG_HEADER.length;\n      writePngChunk(\"IHDR\", ihdr, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n      writePngChunk(\"IDATA\", idat, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + idat.length;\n      writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n\n      return createObjectURL(data, \"image/png\", forceDataSchema);\n    }\n\n    // eslint-disable-next-line no-shadow\n    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n      const kind =\n        imgData.kind === undefined ? ImageKind.GRAYSCALE_1BPP : imgData.kind;\n      return encode(imgData, kind, forceDataSchema, isMask);\n    };\n  })();\n\n  class SVGExtraState {\n    constructor() {\n      this.fontSizeScale = 1;\n      this.fontWeight = SVG_DEFAULTS.fontWeight;\n      this.fontSize = 0;\n\n      this.textMatrix = IDENTITY_MATRIX;\n      this.fontMatrix = FONT_IDENTITY_MATRIX;\n      this.leading = 0;\n      this.textRenderingMode = TextRenderingMode.FILL;\n      this.textMatrixScale = 1;\n\n      // Current point (in user coordinates)\n      this.x = 0;\n      this.y = 0;\n\n      // Start of text line (in text coordinates)\n      this.lineX = 0;\n      this.lineY = 0;\n\n      // Character and word spacing\n      this.charSpacing = 0;\n      this.wordSpacing = 0;\n      this.textHScale = 1;\n      this.textRise = 0;\n\n      // Default foreground and background colors\n      this.fillColor = SVG_DEFAULTS.fillColor;\n      this.strokeColor = \"#000000\";\n\n      this.fillAlpha = 1;\n      this.strokeAlpha = 1;\n      this.lineWidth = 1;\n      this.lineJoin = \"\";\n      this.lineCap = \"\";\n      this.miterLimit = 0;\n\n      this.dashArray = [];\n      this.dashPhase = 0;\n\n      this.dependencies = [];\n\n      // Clipping\n      this.activeClipUrl = null;\n      this.clipGroup = null;\n\n      this.maskId = \"\";\n    }\n\n    clone() {\n      return Object.create(this);\n    }\n\n    setCurrentPoint(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n  }\n\n  // eslint-disable-next-line no-inner-declarations\n  function opListToTree(opList) {\n    let opTree = [];\n    const tmp = [];\n\n    for (const opListElement of opList) {\n      if (opListElement.fn === \"save\") {\n        opTree.push({ fnId: 92, fn: \"group\", items: [] });\n        tmp.push(opTree);\n        opTree = opTree[opTree.length - 1].items;\n        continue;\n      }\n\n      if (opListElement.fn === \"restore\") {\n        opTree = tmp.pop();\n      } else {\n        opTree.push(opListElement);\n      }\n    }\n    return opTree;\n  }\n\n  /**\n   * Format a float number as a string.\n   *\n   * @param value {number} - The float number to format.\n   * @returns {string}\n   */\n  // eslint-disable-next-line no-inner-declarations\n  function pf(value) {\n    if (Number.isInteger(value)) {\n      return value.toString();\n    }\n    const s = value.toFixed(10);\n    let i = s.length - 1;\n    if (s[i] !== \"0\") {\n      return s;\n    }\n\n    // Remove trailing zeros.\n    do {\n      i--;\n    } while (s[i] === \"0\");\n    return s.substring(0, s[i] === \".\" ? i : i + 1);\n  }\n\n  /**\n   * Format a transform matrix as a string. The standard rotation, scale and\n   * translation matrices are replaced by their shorter forms, and for\n   * identity matrices an empty string is returned to save memory.\n   *\n   * @param m {Array} - The transform matrix to format.\n   * @returns {string}\n   */\n  // eslint-disable-next-line no-inner-declarations\n  function pm(m) {\n    if (m[4] === 0 && m[5] === 0) {\n      if (m[1] === 0 && m[2] === 0) {\n        if (m[0] === 1 && m[3] === 1) {\n          return \"\";\n        }\n        return `scale(${pf(m[0])} ${pf(m[3])})`;\n      }\n      if (m[0] === m[3] && m[1] === -m[2]) {\n        const a = (Math.acos(m[0]) * 180) / Math.PI;\n        return `rotate(${pf(a)})`;\n      }\n    } else {\n      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n        return `translate(${pf(m[4])} ${pf(m[5])})`;\n      }\n    }\n    return (\n      `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` +\n      `${pf(m[5])})`\n    );\n  }\n\n  // The counts below are relevant for all pages, so they have to be global\n  // instead of being members of `SVGGraphics` (which is recreated for\n  // each page).\n  let clipCount = 0;\n  let maskCount = 0;\n  let shadingCount = 0;\n\n  SVGGraphics = class {\n    constructor(commonObjs, objs, forceDataSchema = false) {\n      this.svgFactory = new DOMSVGFactory();\n\n      this.current = new SVGExtraState();\n      this.transformMatrix = IDENTITY_MATRIX; // Graphics state matrix\n      this.transformStack = [];\n      this.extraStack = [];\n      this.commonObjs = commonObjs;\n      this.objs = objs;\n      this.pendingClip = null;\n      this.pendingEOFill = false;\n\n      this.embedFonts = false;\n      this.embeddedFonts = Object.create(null);\n      this.cssStyle = null;\n      this.forceDataSchema = !!forceDataSchema;\n\n      // In `src/shared/util.js` the operator names are mapped to IDs.\n      // The list below represents the reverse of that, i.e., it maps IDs\n      // to operator names.\n      this._operatorIdMapping = [];\n      for (const op in OPS) {\n        this._operatorIdMapping[OPS[op]] = op;\n      }\n    }\n\n    save() {\n      this.transformStack.push(this.transformMatrix);\n      const old = this.current;\n      this.extraStack.push(old);\n      this.current = old.clone();\n    }\n\n    restore() {\n      this.transformMatrix = this.transformStack.pop();\n      this.current = this.extraStack.pop();\n      this.pendingClip = null;\n      this.tgrp = null;\n    }\n\n    group(items) {\n      this.save();\n      this.executeOpTree(items);\n      this.restore();\n    }\n\n    loadDependencies(operatorList) {\n      const fnArray = operatorList.fnArray;\n      const argsArray = operatorList.argsArray;\n\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        if (fnArray[i] !== OPS.dependency) {\n          continue;\n        }\n\n        for (const obj of argsArray[i]) {\n          const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\n          const promise = new Promise(resolve => {\n            objsPool.get(obj, resolve);\n          });\n          this.current.dependencies.push(promise);\n        }\n      }\n      return Promise.all(this.current.dependencies);\n    }\n\n    transform(a, b, c, d, e, f) {\n      const transformMatrix = [a, b, c, d, e, f];\n      this.transformMatrix = Util.transform(\n        this.transformMatrix,\n        transformMatrix\n      );\n      this.tgrp = null;\n    }\n\n    getSVG(operatorList, viewport) {\n      this.viewport = viewport;\n\n      const svgElement = this._initialize(viewport);\n      return this.loadDependencies(operatorList).then(() => {\n        this.transformMatrix = IDENTITY_MATRIX;\n        this.executeOpTree(this.convertOpList(operatorList));\n        return svgElement;\n      });\n    }\n\n    convertOpList(operatorList) {\n      const operatorIdMapping = this._operatorIdMapping;\n      const argsArray = operatorList.argsArray;\n      const fnArray = operatorList.fnArray;\n      const opList = [];\n      for (let i = 0, ii = fnArray.length; i < ii; i++) {\n        const fnId = fnArray[i];\n        opList.push({\n          fnId,\n          fn: operatorIdMapping[fnId],\n          args: argsArray[i],\n        });\n      }\n      return opListToTree(opList);\n    }\n\n    executeOpTree(opTree) {\n      for (const opTreeElement of opTree) {\n        const fn = opTreeElement.fn;\n        const fnId = opTreeElement.fnId;\n        const args = opTreeElement.args;\n\n        switch (fnId | 0) {\n          case OPS.beginText:\n            this.beginText();\n            break;\n          case OPS.dependency:\n            // Handled in `loadDependencies`, so no warning should be shown.\n            break;\n          case OPS.setLeading:\n            this.setLeading(args);\n            break;\n          case OPS.setLeadingMoveText:\n            this.setLeadingMoveText(args[0], args[1]);\n            break;\n          case OPS.setFont:\n            this.setFont(args);\n            break;\n          case OPS.showText:\n            this.showText(args[0]);\n            break;\n          case OPS.showSpacedText:\n            this.showText(args[0]);\n            break;\n          case OPS.endText:\n            this.endText();\n            break;\n          case OPS.moveText:\n            this.moveText(args[0], args[1]);\n            break;\n          case OPS.setCharSpacing:\n            this.setCharSpacing(args[0]);\n            break;\n          case OPS.setWordSpacing:\n            this.setWordSpacing(args[0]);\n            break;\n          case OPS.setHScale:\n            this.setHScale(args[0]);\n            break;\n          case OPS.setTextMatrix:\n            this.setTextMatrix(\n              args[0],\n              args[1],\n              args[2],\n              args[3],\n              args[4],\n              args[5]\n            );\n            break;\n          case OPS.setTextRise:\n            this.setTextRise(args[0]);\n            break;\n          case OPS.setTextRenderingMode:\n            this.setTextRenderingMode(args[0]);\n            break;\n          case OPS.setLineWidth:\n            this.setLineWidth(args[0]);\n            break;\n          case OPS.setLineJoin:\n            this.setLineJoin(args[0]);\n            break;\n          case OPS.setLineCap:\n            this.setLineCap(args[0]);\n            break;\n          case OPS.setMiterLimit:\n            this.setMiterLimit(args[0]);\n            break;\n          case OPS.setFillRGBColor:\n            this.setFillRGBColor(args[0], args[1], args[2]);\n            break;\n          case OPS.setStrokeRGBColor:\n            this.setStrokeRGBColor(args[0], args[1], args[2]);\n            break;\n          case OPS.setStrokeColorN:\n            this.setStrokeColorN(args);\n            break;\n          case OPS.setFillColorN:\n            this.setFillColorN(args);\n            break;\n          case OPS.shadingFill:\n            this.shadingFill(args[0]);\n            break;\n          case OPS.setDash:\n            this.setDash(args[0], args[1]);\n            break;\n          case OPS.setRenderingIntent:\n            this.setRenderingIntent(args[0]);\n            break;\n          case OPS.setFlatness:\n            this.setFlatness(args[0]);\n            break;\n          case OPS.setGState:\n            this.setGState(args[0]);\n            break;\n          case OPS.fill:\n            this.fill();\n            break;\n          case OPS.eoFill:\n            this.eoFill();\n            break;\n          case OPS.stroke:\n            this.stroke();\n            break;\n          case OPS.fillStroke:\n            this.fillStroke();\n            break;\n          case OPS.eoFillStroke:\n            this.eoFillStroke();\n            break;\n          case OPS.clip:\n            this.clip(\"nonzero\");\n            break;\n          case OPS.eoClip:\n            this.clip(\"evenodd\");\n            break;\n          case OPS.paintSolidColorImageMask:\n            this.paintSolidColorImageMask();\n            break;\n          case OPS.paintImageXObject:\n            this.paintImageXObject(args[0]);\n            break;\n          case OPS.paintInlineImageXObject:\n            this.paintInlineImageXObject(args[0]);\n            break;\n          case OPS.paintImageMaskXObject:\n            this.paintImageMaskXObject(args[0]);\n            break;\n          case OPS.paintFormXObjectBegin:\n            this.paintFormXObjectBegin(args[0], args[1]);\n            break;\n          case OPS.paintFormXObjectEnd:\n            this.paintFormXObjectEnd();\n            break;\n          case OPS.closePath:\n            this.closePath();\n            break;\n          case OPS.closeStroke:\n            this.closeStroke();\n            break;\n          case OPS.closeFillStroke:\n            this.closeFillStroke();\n            break;\n          case OPS.closeEOFillStroke:\n            this.closeEOFillStroke();\n            break;\n          case OPS.nextLine:\n            this.nextLine();\n            break;\n          case OPS.transform:\n            this.transform(\n              args[0],\n              args[1],\n              args[2],\n              args[3],\n              args[4],\n              args[5]\n            );\n            break;\n          case OPS.constructPath:\n            this.constructPath(args[0], args[1]);\n            break;\n          case OPS.endPath:\n            this.endPath();\n            break;\n          case 92:\n            this.group(opTreeElement.items);\n            break;\n          default:\n            warn(`Unimplemented operator ${fn}`);\n            break;\n        }\n      }\n    }\n\n    setWordSpacing(wordSpacing) {\n      this.current.wordSpacing = wordSpacing;\n    }\n\n    setCharSpacing(charSpacing) {\n      this.current.charSpacing = charSpacing;\n    }\n\n    nextLine() {\n      this.moveText(0, this.current.leading);\n    }\n\n    setTextMatrix(a, b, c, d, e, f) {\n      const current = this.current;\n      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n      current.textMatrixScale = Math.hypot(a, b);\n\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(\n        null,\n        \"font-size\",\n        `${pf(current.fontSize)}px`\n      );\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\n      current.txtElement.appendChild(current.tspan);\n    }\n\n    beginText() {\n      const current = this.current;\n      current.x = current.lineX = 0;\n      current.y = current.lineY = 0;\n      current.textMatrix = IDENTITY_MATRIX;\n      current.lineMatrix = IDENTITY_MATRIX;\n      current.textMatrixScale = 1;\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.txtElement = this.svgFactory.createElement(\"svg:text\");\n      current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    moveText(x, y) {\n      const current = this.current;\n      current.x = current.lineX += x;\n      current.y = current.lineY += y;\n\n      current.xcoords = [];\n      current.ycoords = [];\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(\n        null,\n        \"font-size\",\n        `${pf(current.fontSize)}px`\n      );\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n    }\n\n    showText(glyphs) {\n      const current = this.current;\n      const font = current.font;\n      const fontSize = current.fontSize;\n      if (fontSize === 0) {\n        return;\n      }\n\n      const fontSizeScale = current.fontSizeScale;\n      const charSpacing = current.charSpacing;\n      const wordSpacing = current.wordSpacing;\n      const fontDirection = current.fontDirection;\n      const textHScale = current.textHScale * fontDirection;\n      const vertical = font.vertical;\n      const spacingDir = vertical ? 1 : -1;\n      const defaultVMetrics = font.defaultVMetrics;\n      const widthAdvanceScale = fontSize * current.fontMatrix[0];\n\n      let x = 0;\n      for (const glyph of glyphs) {\n        if (glyph === null) {\n          // Word break\n          x += fontDirection * wordSpacing;\n          continue;\n        } else if (isNum(glyph)) {\n          x += (spacingDir * glyph * fontSize) / 1000;\n          continue;\n        }\n\n        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        const character = glyph.fontChar;\n        let scaledX, scaledY;\n        let width = glyph.width;\n        if (vertical) {\n          let vx;\n          const vmetric = glyph.vmetric || defaultVMetrics;\n          vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n          vx = -vx * widthAdvanceScale;\n          const vy = vmetric[2] * widthAdvanceScale;\n\n          width = vmetric ? -vmetric[0] : width;\n          scaledX = vx / fontSizeScale;\n          scaledY = (x + vy) / fontSizeScale;\n        } else {\n          scaledX = x / fontSizeScale;\n          scaledY = 0;\n        }\n\n        if (glyph.isInFont || font.missingFile) {\n          current.xcoords.push(current.x + scaledX);\n          if (vertical) {\n            current.ycoords.push(-current.y + scaledY);\n          }\n          current.tspan.textContent += character;\n        } else {\n          // TODO: To assist with text selection, we should replace the missing\n          // character with a space character if charWidth is not zero.\n          // But we cannot just do \"character = ' '\", because the ' ' character\n          // might actually map to a different glyph.\n        }\n\n        let charWidth;\n        if (vertical) {\n          charWidth = width * widthAdvanceScale - spacing * fontDirection;\n        } else {\n          charWidth = width * widthAdvanceScale + spacing * fontDirection;\n        }\n\n        x += charWidth;\n      }\n      current.tspan.setAttributeNS(\n        null,\n        \"x\",\n        current.xcoords.map(pf).join(\" \")\n      );\n      if (vertical) {\n        current.tspan.setAttributeNS(\n          null,\n          \"y\",\n          current.ycoords.map(pf).join(\" \")\n        );\n      } else {\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      }\n\n      if (vertical) {\n        current.y -= x;\n      } else {\n        current.x += x * textHScale;\n      }\n\n      current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n      current.tspan.setAttributeNS(\n        null,\n        \"font-size\",\n        `${pf(current.fontSize)}px`\n      );\n      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n        current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n      }\n      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n        current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n      }\n\n      const fillStrokeMode =\n        current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n      if (\n        fillStrokeMode === TextRenderingMode.FILL ||\n        fillStrokeMode === TextRenderingMode.FILL_STROKE\n      ) {\n        if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n          current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n        }\n        if (current.fillAlpha < 1) {\n          current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n        }\n      } else if (current.textRenderingMode === TextRenderingMode.ADD_TO_PATH) {\n        // Workaround for Firefox: We must set fill=\"transparent\" because\n        // fill=\"none\" would generate an empty clipping path.\n        current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n      } else {\n        current.tspan.setAttributeNS(null, \"fill\", \"none\");\n      }\n\n      if (\n        fillStrokeMode === TextRenderingMode.STROKE ||\n        fillStrokeMode === TextRenderingMode.FILL_STROKE\n      ) {\n        const lineWidthScale = 1 / (current.textMatrixScale || 1);\n        this._setStrokeAttributes(current.tspan, lineWidthScale);\n      }\n\n      // Include the text rise in the text matrix since the `pm` function\n      // creates the SVG element's `translate` entry (work on a copy to avoid\n      // altering the original text matrix).\n      let textMatrix = current.textMatrix;\n      if (current.textRise !== 0) {\n        textMatrix = textMatrix.slice();\n        textMatrix[5] += current.textRise;\n      }\n\n      current.txtElement.setAttributeNS(\n        null,\n        \"transform\",\n        `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`\n      );\n      current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n      current.txtElement.appendChild(current.tspan);\n      current.txtgrp.appendChild(current.txtElement);\n\n      this._ensureTransformGroup().appendChild(current.txtElement);\n    }\n\n    setLeadingMoveText(x, y) {\n      this.setLeading(-y);\n      this.moveText(x, y);\n    }\n\n    addFontStyle(fontObj) {\n      if (!fontObj.data) {\n        throw new Error(\n          \"addFontStyle: No font data available, \" +\n            'ensure that the \"fontExtraProperties\" API parameter is set.'\n        );\n      }\n      if (!this.cssStyle) {\n        this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n        this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n        this.defs.appendChild(this.cssStyle);\n      }\n\n      const url = createObjectURL(\n        fontObj.data,\n        fontObj.mimetype,\n        this.forceDataSchema\n      );\n      this.cssStyle.textContent +=\n        `@font-face { font-family: \"${fontObj.loadedName}\";` +\n        ` src: url(${url}); }\\n`;\n    }\n\n    setFont(details) {\n      const current = this.current;\n      const fontObj = this.commonObjs.get(details[0]);\n      let size = details[1];\n      current.font = fontObj;\n\n      if (\n        this.embedFonts &&\n        !fontObj.missingFile &&\n        !this.embeddedFonts[fontObj.loadedName]\n      ) {\n        this.addFontStyle(fontObj);\n        this.embeddedFonts[fontObj.loadedName] = fontObj;\n      }\n      current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n\n      let bold = \"normal\";\n      if (fontObj.black) {\n        bold = \"900\";\n      } else if (fontObj.bold) {\n        bold = \"bold\";\n      }\n      const italic = fontObj.italic ? \"italic\" : \"normal\";\n\n      if (size < 0) {\n        size = -size;\n        current.fontDirection = -1;\n      } else {\n        current.fontDirection = 1;\n      }\n      current.fontSize = size;\n      current.fontFamily = fontObj.loadedName;\n      current.fontWeight = bold;\n      current.fontStyle = italic;\n\n      current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      current.xcoords = [];\n      current.ycoords = [];\n    }\n\n    endText() {\n      const current = this.current;\n      if (\n        current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG &&\n        current.txtElement?.hasChildNodes()\n      ) {\n        // If no glyphs are shown (i.e. no child nodes), no clipping occurs.\n        current.element = current.txtElement;\n        this.clip(\"nonzero\");\n        this.endPath();\n      }\n    }\n\n    // Path properties\n    setLineWidth(width) {\n      if (width > 0) {\n        this.current.lineWidth = width;\n      }\n    }\n\n    setLineCap(style) {\n      this.current.lineCap = LINE_CAP_STYLES[style];\n    }\n\n    setLineJoin(style) {\n      this.current.lineJoin = LINE_JOIN_STYLES[style];\n    }\n\n    setMiterLimit(limit) {\n      this.current.miterLimit = limit;\n    }\n\n    setStrokeAlpha(strokeAlpha) {\n      this.current.strokeAlpha = strokeAlpha;\n    }\n\n    setStrokeRGBColor(r, g, b) {\n      this.current.strokeColor = Util.makeHexColor(r, g, b);\n    }\n\n    setFillAlpha(fillAlpha) {\n      this.current.fillAlpha = fillAlpha;\n    }\n\n    setFillRGBColor(r, g, b) {\n      this.current.fillColor = Util.makeHexColor(r, g, b);\n      this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n      this.current.xcoords = [];\n      this.current.ycoords = [];\n    }\n\n    setStrokeColorN(args) {\n      this.current.strokeColor = this._makeColorN_Pattern(args);\n    }\n\n    setFillColorN(args) {\n      this.current.fillColor = this._makeColorN_Pattern(args);\n    }\n\n    shadingFill(args) {\n      const width = this.viewport.width;\n      const height = this.viewport.height;\n      const inv = Util.inverseTransform(this.transformMatrix);\n      const bl = Util.applyTransform([0, 0], inv);\n      const br = Util.applyTransform([0, height], inv);\n      const ul = Util.applyTransform([width, 0], inv);\n      const ur = Util.applyTransform([width, height], inv);\n      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", x0);\n      rect.setAttributeNS(null, \"y\", y0);\n      rect.setAttributeNS(null, \"width\", x1 - x0);\n      rect.setAttributeNS(null, \"height\", y1 - y0);\n      rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n      if (this.current.fillAlpha < 1) {\n        rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n      }\n      this._ensureTransformGroup().appendChild(rect);\n    }\n\n    /**\n     * @private\n     */\n    _makeColorN_Pattern(args) {\n      if (args[0] === \"TilingPattern\") {\n        return this._makeTilingPattern(args);\n      }\n      return this._makeShadingPattern(args);\n    }\n\n    /**\n     * @private\n     */\n    _makeTilingPattern(args) {\n      const color = args[1];\n      const operatorList = args[2];\n      const matrix = args[3] || IDENTITY_MATRIX;\n      const [x0, y0, x1, y1] = args[4];\n      const xstep = args[5];\n      const ystep = args[6];\n      const paintType = args[7];\n\n      const tilingId = `shading${shadingCount++}`;\n      const [tx0, ty0, tx1, ty1] = Util.normalizeRect([\n        ...Util.applyTransform([x0, y0], matrix),\n        ...Util.applyTransform([x1, y1], matrix),\n      ]);\n      const [xscale, yscale] = Util.singularValueDecompose2dScale(matrix);\n      const txstep = xstep * xscale;\n      const tystep = ystep * yscale;\n\n      const tiling = this.svgFactory.createElement(\"svg:pattern\");\n      tiling.setAttributeNS(null, \"id\", tilingId);\n      tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n      tiling.setAttributeNS(null, \"width\", txstep);\n      tiling.setAttributeNS(null, \"height\", tystep);\n      tiling.setAttributeNS(null, \"x\", `${tx0}`);\n      tiling.setAttributeNS(null, \"y\", `${ty0}`);\n\n      // Save current state.\n      const svg = this.svg;\n      const transformMatrix = this.transformMatrix;\n      const fillColor = this.current.fillColor;\n      const strokeColor = this.current.strokeColor;\n\n      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n      this.svg = bbox;\n      this.transformMatrix = matrix;\n      if (paintType === 2) {\n        const cssColor = Util.makeHexColor(...color);\n        this.current.fillColor = cssColor;\n        this.current.strokeColor = cssColor;\n      }\n      this.executeOpTree(this.convertOpList(operatorList));\n\n      // Restore saved state.\n      this.svg = svg;\n      this.transformMatrix = transformMatrix;\n      this.current.fillColor = fillColor;\n      this.current.strokeColor = strokeColor;\n\n      tiling.appendChild(bbox.childNodes[0]);\n      this.defs.appendChild(tiling);\n      return `url(#${tilingId})`;\n    }\n\n    /**\n     * @private\n     */\n    _makeShadingPattern(args) {\n      if (typeof args === \"string\") {\n        args = this.objs.get(args);\n      }\n      switch (args[0]) {\n        case \"RadialAxial\":\n          const shadingId = `shading${shadingCount++}`;\n          const colorStops = args[3];\n          let gradient;\n\n          switch (args[1]) {\n            case \"axial\":\n              const point0 = args[4];\n              const point1 = args[5];\n              gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n              gradient.setAttributeNS(null, \"id\", shadingId);\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n              gradient.setAttributeNS(null, \"x1\", point0[0]);\n              gradient.setAttributeNS(null, \"y1\", point0[1]);\n              gradient.setAttributeNS(null, \"x2\", point1[0]);\n              gradient.setAttributeNS(null, \"y2\", point1[1]);\n              break;\n            case \"radial\":\n              const focalPoint = args[4];\n              const circlePoint = args[5];\n              const focalRadius = args[6];\n              const circleRadius = args[7];\n              gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n              gradient.setAttributeNS(null, \"id\", shadingId);\n              gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n              gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n              gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n              gradient.setAttributeNS(null, \"r\", circleRadius);\n              gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n              gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n              gradient.setAttributeNS(null, \"fr\", focalRadius);\n              break;\n            default:\n              throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n          }\n          for (const colorStop of colorStops) {\n            const stop = this.svgFactory.createElement(\"svg:stop\");\n            stop.setAttributeNS(null, \"offset\", colorStop[0]);\n            stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n            gradient.appendChild(stop);\n          }\n          this.defs.appendChild(gradient);\n          return `url(#${shadingId})`;\n        case \"Mesh\":\n          warn(\"Unimplemented pattern Mesh\");\n          return null;\n        case \"Dummy\":\n          return \"hotpink\";\n        default:\n          throw new Error(`Unknown IR type: ${args[0]}`);\n      }\n    }\n\n    setDash(dashArray, dashPhase) {\n      this.current.dashArray = dashArray;\n      this.current.dashPhase = dashPhase;\n    }\n\n    constructPath(ops, args) {\n      const current = this.current;\n      let x = current.x,\n        y = current.y;\n      let d = [];\n      let j = 0;\n\n      for (const op of ops) {\n        switch (op | 0) {\n          case OPS.rectangle:\n            x = args[j++];\n            y = args[j++];\n            const width = args[j++];\n            const height = args[j++];\n            const xw = x + width;\n            const yh = y + height;\n            d.push(\n              \"M\",\n              pf(x),\n              pf(y),\n              \"L\",\n              pf(xw),\n              pf(y),\n              \"L\",\n              pf(xw),\n              pf(yh),\n              \"L\",\n              pf(x),\n              pf(yh),\n              \"Z\"\n            );\n            break;\n          case OPS.moveTo:\n            x = args[j++];\n            y = args[j++];\n            d.push(\"M\", pf(x), pf(y));\n            break;\n          case OPS.lineTo:\n            x = args[j++];\n            y = args[j++];\n            d.push(\"L\", pf(x), pf(y));\n            break;\n          case OPS.curveTo:\n            x = args[j + 4];\n            y = args[j + 5];\n            d.push(\n              \"C\",\n              pf(args[j]),\n              pf(args[j + 1]),\n              pf(args[j + 2]),\n              pf(args[j + 3]),\n              pf(x),\n              pf(y)\n            );\n            j += 6;\n            break;\n          case OPS.curveTo2:\n            d.push(\n              \"C\",\n              pf(x),\n              pf(y),\n              pf(args[j]),\n              pf(args[j + 1]),\n              pf(args[j + 2]),\n              pf(args[j + 3])\n            );\n            x = args[j + 2];\n            y = args[j + 3];\n            j += 4;\n            break;\n          case OPS.curveTo3:\n            x = args[j + 2];\n            y = args[j + 3];\n            d.push(\n              \"C\",\n              pf(args[j]),\n              pf(args[j + 1]),\n              pf(x),\n              pf(y),\n              pf(x),\n              pf(y)\n            );\n            j += 4;\n            break;\n          case OPS.closePath:\n            d.push(\"Z\");\n            break;\n        }\n      }\n\n      d = d.join(\" \");\n\n      if (\n        current.path &&\n        ops.length > 0 &&\n        ops[0] !== OPS.rectangle &&\n        ops[0] !== OPS.moveTo\n      ) {\n        // If a path does not start with an OPS.rectangle or OPS.moveTo, it has\n        // probably been divided into two OPS.constructPath operators by\n        // OperatorList. Append the commands to the previous path element.\n        d = current.path.getAttributeNS(null, \"d\") + d;\n      } else {\n        current.path = this.svgFactory.createElement(\"svg:path\");\n        this._ensureTransformGroup().appendChild(current.path);\n      }\n\n      current.path.setAttributeNS(null, \"d\", d);\n      current.path.setAttributeNS(null, \"fill\", \"none\");\n\n      // Saving a reference in current.element so that it can be addressed\n      // in 'fill' and 'stroke'\n      current.element = current.path;\n      current.setCurrentPoint(x, y);\n    }\n\n    endPath() {\n      const current = this.current;\n\n      // Painting operators end a path.\n      current.path = null;\n\n      if (!this.pendingClip) {\n        return;\n      }\n      if (!current.element) {\n        this.pendingClip = null;\n        return;\n      }\n\n      // Add the current path to a clipping path.\n      const clipId = `clippath${clipCount++}`;\n      const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n      clipPath.setAttributeNS(null, \"id\", clipId);\n      clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n\n      // A deep clone is needed when text is used as a clipping path.\n      const clipElement = current.element.cloneNode(true);\n      if (this.pendingClip === \"evenodd\") {\n        clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n      } else {\n        clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n      }\n      this.pendingClip = null;\n      clipPath.appendChild(clipElement);\n      this.defs.appendChild(clipPath);\n\n      if (current.activeClipUrl) {\n        // The previous clipping group content can go out of order -- resetting\n        // cached clipGroups.\n        current.clipGroup = null;\n        for (const prev of this.extraStack) {\n          prev.clipGroup = null;\n        }\n        // Intersect with the previous clipping path.\n        clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n      }\n      current.activeClipUrl = `url(#${clipId})`;\n\n      this.tgrp = null;\n    }\n\n    clip(type) {\n      this.pendingClip = type;\n    }\n\n    closePath() {\n      const current = this.current;\n      if (current.path) {\n        const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\n        current.path.setAttributeNS(null, \"d\", d);\n      }\n    }\n\n    setLeading(leading) {\n      this.current.leading = -leading;\n    }\n\n    setTextRise(textRise) {\n      this.current.textRise = textRise;\n    }\n\n    setTextRenderingMode(textRenderingMode) {\n      this.current.textRenderingMode = textRenderingMode;\n    }\n\n    setHScale(scale) {\n      this.current.textHScale = scale / 100;\n    }\n\n    setRenderingIntent(intent) {\n      // This operation is ignored since we haven't found a use case for it yet.\n    }\n\n    setFlatness(flatness) {\n      // This operation is ignored since we haven't found a use case for it yet.\n    }\n\n    setGState(states) {\n      for (const [key, value] of states) {\n        switch (key) {\n          case \"LW\":\n            this.setLineWidth(value);\n            break;\n          case \"LC\":\n            this.setLineCap(value);\n            break;\n          case \"LJ\":\n            this.setLineJoin(value);\n            break;\n          case \"ML\":\n            this.setMiterLimit(value);\n            break;\n          case \"D\":\n            this.setDash(value[0], value[1]);\n            break;\n          case \"RI\":\n            this.setRenderingIntent(value);\n            break;\n          case \"FL\":\n            this.setFlatness(value);\n            break;\n          case \"Font\":\n            this.setFont(value);\n            break;\n          case \"CA\":\n            this.setStrokeAlpha(value);\n            break;\n          case \"ca\":\n            this.setFillAlpha(value);\n            break;\n          default:\n            warn(`Unimplemented graphic state operator ${key}`);\n            break;\n        }\n      }\n    }\n\n    fill() {\n      const current = this.current;\n      if (current.element) {\n        current.element.setAttributeNS(null, \"fill\", current.fillColor);\n        current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n        this.endPath();\n      }\n    }\n\n    stroke() {\n      const current = this.current;\n      if (current.element) {\n        this._setStrokeAttributes(current.element);\n        current.element.setAttributeNS(null, \"fill\", \"none\");\n        this.endPath();\n      }\n    }\n\n    /**\n     * @private\n     */\n    _setStrokeAttributes(element, lineWidthScale = 1) {\n      const current = this.current;\n      let dashArray = current.dashArray;\n      if (lineWidthScale !== 1 && dashArray.length > 0) {\n        dashArray = dashArray.map(function (value) {\n          return lineWidthScale * value;\n        });\n      }\n      element.setAttributeNS(null, \"stroke\", current.strokeColor);\n      element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n      element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n      element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n      element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n      element.setAttributeNS(\n        null,\n        \"stroke-width\",\n        pf(lineWidthScale * current.lineWidth) + \"px\"\n      );\n      element.setAttributeNS(\n        null,\n        \"stroke-dasharray\",\n        dashArray.map(pf).join(\" \")\n      );\n      element.setAttributeNS(\n        null,\n        \"stroke-dashoffset\",\n        pf(lineWidthScale * current.dashPhase) + \"px\"\n      );\n    }\n\n    eoFill() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n      }\n      this.fill();\n    }\n\n    fillStroke() {\n      // Order is important since stroke wants fill to be none.\n      // First stroke, then if fill needed, it will be overwritten.\n      this.stroke();\n      this.fill();\n    }\n\n    eoFillStroke() {\n      if (this.current.element) {\n        this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n      }\n      this.fillStroke();\n    }\n\n    closeStroke() {\n      this.closePath();\n      this.stroke();\n    }\n\n    closeFillStroke() {\n      this.closePath();\n      this.fillStroke();\n    }\n\n    closeEOFillStroke() {\n      this.closePath();\n      this.eoFillStroke();\n    }\n\n    paintSolidColorImageMask() {\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", \"0\");\n      rect.setAttributeNS(null, \"y\", \"0\");\n      rect.setAttributeNS(null, \"width\", \"1px\");\n      rect.setAttributeNS(null, \"height\", \"1px\");\n      rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n\n      this._ensureTransformGroup().appendChild(rect);\n    }\n\n    paintImageXObject(objId) {\n      const imgData = objId.startsWith(\"g_\")\n        ? this.commonObjs.get(objId)\n        : this.objs.get(objId);\n      if (!imgData) {\n        warn(`Dependent image with object ID ${objId} is not ready yet`);\n        return;\n      }\n      this.paintInlineImageXObject(imgData);\n    }\n\n    paintInlineImageXObject(imgData, mask) {\n      const width = imgData.width;\n      const height = imgData.height;\n\n      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n      const cliprect = this.svgFactory.createElement(\"svg:rect\");\n      cliprect.setAttributeNS(null, \"x\", \"0\");\n      cliprect.setAttributeNS(null, \"y\", \"0\");\n      cliprect.setAttributeNS(null, \"width\", pf(width));\n      cliprect.setAttributeNS(null, \"height\", pf(height));\n      this.current.element = cliprect;\n      this.clip(\"nonzero\");\n\n      const imgEl = this.svgFactory.createElement(\"svg:image\");\n      imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n      imgEl.setAttributeNS(null, \"x\", \"0\");\n      imgEl.setAttributeNS(null, \"y\", pf(-height));\n      imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n      imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n      imgEl.setAttributeNS(\n        null,\n        \"transform\",\n        `scale(${pf(1 / width)} ${pf(-1 / height)})`\n      );\n      if (mask) {\n        mask.appendChild(imgEl);\n      } else {\n        this._ensureTransformGroup().appendChild(imgEl);\n      }\n    }\n\n    paintImageMaskXObject(imgData) {\n      const current = this.current;\n      const width = imgData.width;\n      const height = imgData.height;\n      const fillColor = current.fillColor;\n\n      current.maskId = `mask${maskCount++}`;\n      const mask = this.svgFactory.createElement(\"svg:mask\");\n      mask.setAttributeNS(null, \"id\", current.maskId);\n\n      const rect = this.svgFactory.createElement(\"svg:rect\");\n      rect.setAttributeNS(null, \"x\", \"0\");\n      rect.setAttributeNS(null, \"y\", \"0\");\n      rect.setAttributeNS(null, \"width\", pf(width));\n      rect.setAttributeNS(null, \"height\", pf(height));\n      rect.setAttributeNS(null, \"fill\", fillColor);\n      rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\n\n      this.defs.appendChild(mask);\n      this._ensureTransformGroup().appendChild(rect);\n\n      this.paintInlineImageXObject(imgData, mask);\n    }\n\n    paintFormXObjectBegin(matrix, bbox) {\n      if (Array.isArray(matrix) && matrix.length === 6) {\n        this.transform(\n          matrix[0],\n          matrix[1],\n          matrix[2],\n          matrix[3],\n          matrix[4],\n          matrix[5]\n        );\n      }\n\n      if (bbox) {\n        const width = bbox[2] - bbox[0];\n        const height = bbox[3] - bbox[1];\n\n        const cliprect = this.svgFactory.createElement(\"svg:rect\");\n        cliprect.setAttributeNS(null, \"x\", bbox[0]);\n        cliprect.setAttributeNS(null, \"y\", bbox[1]);\n        cliprect.setAttributeNS(null, \"width\", pf(width));\n        cliprect.setAttributeNS(null, \"height\", pf(height));\n        this.current.element = cliprect;\n        this.clip(\"nonzero\");\n        this.endPath();\n      }\n    }\n\n    paintFormXObjectEnd() {}\n\n    /**\n     * @private\n     */\n    _initialize(viewport) {\n      const svg = this.svgFactory.create(viewport.width, viewport.height);\n\n      // Create the definitions element.\n      const definitions = this.svgFactory.createElement(\"svg:defs\");\n      svg.appendChild(definitions);\n      this.defs = definitions;\n\n      // Create the root group element, which acts a container for all other\n      // groups and applies the viewport transform.\n      const rootGroup = this.svgFactory.createElement(\"svg:g\");\n      rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n      svg.appendChild(rootGroup);\n\n      // For the construction of the SVG image we are only interested in the\n      // root group, so we expose it as the entry point of the SVG image for\n      // the other code in this class.\n      this.svg = rootGroup;\n\n      return svg;\n    }\n\n    /**\n     * @private\n     */\n    _ensureClipGroup() {\n      if (!this.current.clipGroup) {\n        const clipGroup = this.svgFactory.createElement(\"svg:g\");\n        clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n        this.svg.appendChild(clipGroup);\n        this.current.clipGroup = clipGroup;\n      }\n      return this.current.clipGroup;\n    }\n\n    /**\n     * @private\n     */\n    _ensureTransformGroup() {\n      if (!this.tgrp) {\n        this.tgrp = this.svgFactory.createElement(\"svg:g\");\n        this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n        if (this.current.activeClipUrl) {\n          this._ensureClipGroup().appendChild(this.tgrp);\n        } else {\n          this.svg.appendChild(this.tgrp);\n        }\n      }\n      return this.tgrp;\n    }\n  };\n}\n\nexport { SVGGraphics };\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* globals __non_webpack_require__ */\n\nimport {\n  AbortException,\n  assert,\n  createPromiseCapability,\n  MissingPDFException,\n} from \"../shared/util.js\";\nimport {\n  extractFilenameFromHeader,\n  validateRangeRequestCapabilities,\n} from \"./network_utils.js\";\n\nif (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\n  throw new Error(\n    'Module \"./node_stream.js\" shall not be used with MOZCENTRAL builds.'\n  );\n}\n\nconst fs = __non_webpack_require__(\"fs\");\nconst http = __non_webpack_require__(\"http\");\nconst https = __non_webpack_require__(\"https\");\nconst url = __non_webpack_require__(\"url\");\n\nconst fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n\nfunction parseUrl(sourceUrl) {\n  const parsedUrl = url.parse(sourceUrl);\n  if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n    return parsedUrl;\n  }\n  // Prepending 'file:///' to Windows absolute path.\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n    return url.parse(`file:///${sourceUrl}`);\n  }\n  // Changes protocol to 'file:' if url refers to filesystem.\n  if (!parsedUrl.host) {\n    parsedUrl.protocol = \"file:\";\n  }\n  return parsedUrl;\n}\n\nclass PDFNodeStream {\n  constructor(source) {\n    this.source = source;\n    this.url = parseUrl(source.url);\n    this.isHttp =\n      this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n    // Check if url refers to filesystem.\n    this.isFsUrl = this.url.protocol === \"file:\";\n    this.httpHeaders = (this.isHttp && source.httpHeaders) || {};\n\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  getFullReader() {\n    assert(\n      !this._fullRequestReader,\n      \"PDFNodeStream.getFullReader can only be called once.\"\n    );\n    this._fullRequestReader = this.isFsUrl\n      ? new PDFNodeStreamFsFullReader(this)\n      : new PDFNodeStreamFullReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(start, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const rangeReader = this.isFsUrl\n      ? new PDFNodeStreamFsRangeReader(this, start, end)\n      : new PDFNodeStreamRangeReader(this, start, end);\n    this._rangeRequestReaders.push(rangeReader);\n    return rangeReader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\n\nclass BaseFullReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    const source = stream.source;\n    this._contentLength = source.length; // optional\n    this._loaded = 0;\n    this._filename = null;\n\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n\n    this._readableStream = null;\n    this._readCapability = createPromiseCapability();\n    this._headersCapability = createPromiseCapability();\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return { value: undefined, done: true };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = createPromiseCapability();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength,\n      });\n    }\n    // Ensure that `read()` method returns ArrayBuffer.\n    const buffer = new Uint8Array(chunk).buffer;\n    return { value: buffer, done: false };\n  }\n\n  cancel(reason) {\n    // Call `this._error()` method when cancel is called\n    // before _readableStream is set.\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n\n    readableStream.on(\"end\", () => {\n      // Destroy readable to minimize resource usage.\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n\n    // We need to stop reading when range is supported and streaming is\n    // disabled.\n    if (!this._isStreamingSupported && this._isRangeSupported) {\n      this._error(new AbortException(\"streaming is disabled\"));\n    }\n\n    // Destroy ReadableStream if already in errored state.\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\n\nclass BaseRangeReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = createPromiseCapability();\n    const source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return { value: undefined, done: true };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = createPromiseCapability();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    if (this.onProgress) {\n      this.onProgress({ loaded: this._loaded });\n    }\n    // Ensure that `read()` method returns ArrayBuffer.\n    const buffer = new Uint8Array(chunk).buffer;\n    return { value: buffer, done: false };\n  }\n\n  cancel(reason) {\n    // Call `this._error()` method when cancel is called\n    // before _readableStream is set.\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n\n    readableStream.on(\"end\", () => {\n      // Destroy readableStream to minimize resource usage.\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n\n    // Destroy readableStream if already in errored state.\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\n\nfunction createRequestOptions(parsedUrl, headers) {\n  return {\n    protocol: parsedUrl.protocol,\n    auth: parsedUrl.auth,\n    host: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.path,\n    method: \"GET\",\n    headers,\n  };\n}\n\nclass PDFNodeStreamFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        this._headersCapability.reject(error);\n        return;\n      }\n      this._headersCapability.resolve();\n      this._setReadableStream(response);\n\n      const getResponseHeader = name => {\n        // Make sure that headers name are in lower case, as mentioned\n        // here: https://nodejs.org/api/http.html#http_message_headers.\n        return this._readableStream.headers[name.toLowerCase()];\n      };\n      const { allowRangeRequests, suggestedLength } =\n        validateRangeRequestCapabilities({\n          getResponseHeader,\n          isHttp: stream.isHttp,\n          rangeChunkSize: this._rangeChunkSize,\n          disableRange: this._disableRange,\n        });\n\n      this._isRangeSupported = allowRangeRequests;\n      // Setting right content length.\n      this._contentLength = suggestedLength || this._contentLength;\n\n      this._filename = extractFilenameFromHeader(getResponseHeader);\n    };\n\n    this._request = null;\n    if (this._url.protocol === \"http:\") {\n      this._request = http.request(\n        createRequestOptions(this._url, stream.httpHeaders),\n        handleResponse\n      );\n    } else {\n      this._request = https.request(\n        createRequestOptions(this._url, stream.httpHeaders),\n        handleResponse\n      );\n    }\n\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n      this._headersCapability.reject(reason);\n    });\n    // Note: `request.end(data)` is used to write `data` to request body\n    // and notify end of request. But one should always call `request.end()`\n    // even if there is no data to write -- (to notify the end of request).\n    this._request.end();\n  }\n}\n\nclass PDFNodeStreamRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n\n    this._httpHeaders = {};\n    for (const property in stream.httpHeaders) {\n      const value = stream.httpHeaders[property];\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n      this._httpHeaders[property] = value;\n    }\n    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        return;\n      }\n      this._setReadableStream(response);\n    };\n\n    this._request = null;\n    if (this._url.protocol === \"http:\") {\n      this._request = http.request(\n        createRequestOptions(this._url, this._httpHeaders),\n        handleResponse\n      );\n    } else {\n      this._request = https.request(\n        createRequestOptions(this._url, this._httpHeaders),\n        handleResponse\n      );\n    }\n\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n    });\n    this._request.end();\n  }\n}\n\nclass PDFNodeStreamFsFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n\n    let path = decodeURIComponent(this._url.path);\n\n    // Remove the extra slash to get right path from url like `file:///C:/`\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    fs.lstat(path, (error, stat) => {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          error = new MissingPDFException(`Missing PDF \"${path}\".`);\n        }\n        this._storedError = error;\n        this._headersCapability.reject(error);\n        return;\n      }\n      // Setting right content length.\n      this._contentLength = stat.size;\n\n      this._setReadableStream(fs.createReadStream(path));\n      this._headersCapability.resolve();\n    });\n  }\n}\n\nclass PDFNodeStreamFsRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n\n    let path = decodeURIComponent(this._url.path);\n\n    // Remove the extra slash to get right path from url like `file:///C:/`\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    this._setReadableStream(fs.createReadStream(path, { start, end: end - 1 }));\n  }\n}\n\nexport { PDFNodeStream };\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  assert,\n  MissingPDFException,\n  UnexpectedResponseException,\n} from \"../shared/util.js\";\nimport { getFilenameFromContentDispositionHeader } from \"./content_disposition.js\";\nimport { isPdfFile } from \"./display_utils.js\";\n\nfunction validateRangeRequestCapabilities({\n  getResponseHeader,\n  isHttp,\n  rangeChunkSize,\n  disableRange,\n}) {\n  assert(rangeChunkSize > 0, \"Range chunk size must be larger than zero\");\n  const returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined,\n  };\n\n  const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n\n  returnValues.suggestedLength = length;\n\n  if (length <= 2 * rangeChunkSize) {\n    // The file size is smaller than the size of two chunks, so it does not\n    // make any sense to abort the request and retry with a range request.\n    return returnValues;\n  }\n\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n  if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n\n  const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\n\nfunction extractFilenameFromHeader(getResponseHeader) {\n  const contentDisposition = getResponseHeader(\"Content-Disposition\");\n  if (contentDisposition) {\n    let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch (ex) {}\n    }\n    if (isPdfFile(filename)) {\n      return filename;\n    }\n  }\n  return null;\n}\n\nfunction createResponseStatusError(status, url) {\n  if (status === 404 || (status === 0 && url.startsWith(\"file:\"))) {\n    return new MissingPDFException('Missing PDF \"' + url + '\".');\n  }\n  return new UnexpectedResponseException(\n    `Unexpected server response (${status}) while retrieving PDF \"${url}\".`,\n    status\n  );\n}\n\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\nexport {\n  createResponseStatusError,\n  extractFilenameFromHeader,\n  validateRangeRequestCapabilities,\n  validateResponseStatus,\n};\n","/* Copyright 2017 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { stringToBytes } from \"../shared/util.js\";\n\n// This getFilenameFromContentDispositionHeader function is adapted from\n// https://github.com/Rob--W/open-in-browser/blob/7e2e35a38b8b4e981b11da7b2f01df0149049e92/extension/content-disposition.js\n// with the following changes:\n// - Modified to conform to PDF.js's coding style.\n// - Support UTF-8 decoding when TextDecoder is unsupported.\n// - Move return to the end of the function to prevent Babel from dropping the\n//   function declarations.\n\n/**\n * Extract file name from the Content-Disposition HTTP response header.\n *\n * @param {string} contentDisposition\n * @returns {string} Filename, if found in the Content-Disposition header.\n */\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  let needsEncodingFixup = true;\n\n  // filename*=ext-value (\"ext-value\" from RFC 5987, referenced by RFC 6266).\n  let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  // Continuations (RFC 2231 section 3, referenced by RFC 5987 section 3.1).\n  // filename*n*=part\n  // filename*n=part\n  tmp = rfc2231getparam(contentDisposition);\n  if (tmp) {\n    // RFC 2047, section\n    const filename = rfc2047decode(tmp);\n    return fixupEncoding(filename);\n  }\n\n  // filename=value (RFC 5987, section 4.1).\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  // After this line there are only function declarations. We cannot put\n  // \"return\" here for readability because babel would then drop the function\n  // declarations...\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\n      \"(?:^|;)\\\\s*\" +\n        attributePattern +\n        \"\\\\s*=\\\\s*\" +\n        // Captures: value = token | quoted-string\n        // (RFC 2616, section 3.6 and referenced by RFC 6266 4.1)\n        \"(\" +\n        '[^\";\\\\s][^;\\\\s]*' +\n        \"|\" +\n        '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' +\n        \")\",\n      flags\n    );\n  }\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n      try {\n        const decoder = new TextDecoder(encoding, { fatal: true });\n        const buffer = stringToBytes(value);\n        value = decoder.decode(buffer);\n        needsEncodingFixup = false;\n      } catch (e) {\n        // TextDecoder constructor threw - unrecognized encoding.\n        // Or TextDecoder API is not available (in IE / Edge).\n        if (/^utf-?8$/i.test(encoding)) {\n          // UTF-8 is commonly used, try to support it in another way:\n          try {\n            value = decodeURIComponent(escape(value));\n            needsEncodingFixup = false;\n          } catch (err) {}\n        }\n      }\n    }\n    return value;\n  }\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      // Maybe multi-byte UTF-8.\n      value = textdecode(\"utf-8\", value);\n      if (needsEncodingFixup) {\n        // Try iso-8859-1 encoding.\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n    return value;\n  }\n  function rfc2231getparam(contentDispositionStr) {\n    const matches = [];\n    let match;\n    // Iterate over all filename*n= and filename*n*= with n being an integer\n    // of at least zero. Any non-zero number must not start with '0'.\n    const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      let [, n, quot, part] = match; // eslint-disable-line prefer-const\n      n = parseInt(n, 10);\n      if (n in matches) {\n        // Ignore anything after the invalid second filename*0.\n        if (n === 0) {\n          break;\n        }\n        continue;\n      }\n      matches[n] = [quot, part];\n    }\n    const parts = [];\n    for (let n = 0; n < matches.length; ++n) {\n      if (!(n in matches)) {\n        // Numbers must be consecutive. Truncate when there is a hole.\n        break;\n      }\n      let [quot, part] = matches[n]; // eslint-disable-line prefer-const\n      part = rfc2616unquote(part);\n      if (quot) {\n        part = unescape(part);\n        if (n === 0) {\n          part = rfc5987decode(part);\n        }\n      }\n      parts.push(part);\n    }\n    return parts.join(\"\");\n  }\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      const parts = value.slice(1).split('\\\\\"');\n      // Find the first unescaped \" and terminate there.\n      for (let i = 0; i < parts.length; ++i) {\n        const quotindex = parts[i].indexOf('\"');\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1; // Truncates and stop the iteration.\n        }\n        parts[i] = parts[i].replace(/\\\\(.)/g, \"$1\");\n      }\n      value = parts.join('\"');\n    }\n    return value;\n  }\n  function rfc5987decode(extvalue) {\n    // Decodes \"ext-value\" from RFC 5987.\n    const encodingend = extvalue.indexOf(\"'\");\n    if (encodingend === -1) {\n      // Some servers send \"filename*=\" without encoding 'language' prefix,\n      // e.g. in https://github.com/Rob--W/open-in-browser/issues/26\n      // Let's accept the value like Firefox (57) (Chrome 62 rejects it).\n      return extvalue;\n    }\n    const encoding = extvalue.slice(0, encodingend);\n    const langvalue = extvalue.slice(encodingend + 1);\n    // Ignore language (RFC 5987 section 3.2.1, and RFC 6266 section 4.1 ).\n    const value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n  function rfc2047decode(value) {\n    // RFC 2047-decode the result. Firefox tried to drop support for it, but\n    // backed out because some servers use it - https://bugzil.la/875615\n    // Firefox's condition for decoding is here: https://searchfox.org/mozilla-central/rev/4a590a5a15e35d88a3b23dd6ac3c471cf85b04a8/netwerk/mime/nsMIMEHeaderParamImpl.cpp#742-748\n\n    // We are more strict and only recognize RFC 2047-encoding if the value\n    // starts with \"=?\", since then it is likely that the full value is\n    // RFC 2047-encoded.\n\n    // Firefox also decodes words even where RFC 2047 section 5 states:\n    // \"An 'encoded-word' MUST NOT appear within a 'quoted-string'.\"\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n    // RFC 2047, section 2.4\n    // encoded-word = \"=?\" charset \"?\" encoding \"?\" encoded-text \"?=\"\n    // charset = token (but let's restrict to characters that denote a\n    //       possibly valid encoding).\n    // encoding = q or b\n    // encoded-text = any printable ASCII character other than ? or space.\n    //        ... but Firefox permits ? and space.\n    return value.replace(\n      /=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g,\n      function (matches, charset, encoding, text) {\n        if (encoding === \"q\" || encoding === \"Q\") {\n          // RFC 2047 section 4.2.\n          text = text.replace(/_/g, \" \");\n          text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n            return String.fromCharCode(parseInt(hex, 16));\n          });\n          return textdecode(charset, text);\n        } // else encoding is b or B - base64 (RFC 2047 section 4.1)\n        try {\n          text = atob(text);\n        } catch (e) {}\n        return textdecode(charset, text);\n      }\n    );\n  }\n\n  return \"\";\n}\n\nexport { getFilenameFromContentDispositionHeader };\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  assert,\n  createPromiseCapability,\n  stringToBytes,\n} from \"../shared/util.js\";\nimport {\n  createResponseStatusError,\n  extractFilenameFromHeader,\n  validateRangeRequestCapabilities,\n} from \"./network_utils.js\";\n\nif (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\n  throw new Error(\n    'Module \"./network.js\" shall not be used with MOZCENTRAL builds.'\n  );\n}\n\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\n\nfunction getArrayBuffer(xhr) {\n  const data = xhr.response;\n  if (typeof data !== \"string\") {\n    return data;\n  }\n  const array = stringToBytes(data);\n  return array.buffer;\n}\n\nclass NetworkManager {\n  constructor(url, args = {}) {\n    this.url = url;\n    this.isHttp = /^https?:/i.test(url);\n    this.httpHeaders = (this.isHttp && args.httpHeaders) || Object.create(null);\n    this.withCredentials = args.withCredentials || false;\n    this.getXhr =\n      args.getXhr ||\n      function NetworkManager_getXhr() {\n        return new XMLHttpRequest();\n      };\n\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n\n  requestRange(begin, end, listeners) {\n    const args = {\n      begin,\n      end,\n    };\n    for (const prop in listeners) {\n      args[prop] = listeners[prop];\n    }\n    return this.request(args);\n  }\n\n  requestFull(listeners) {\n    return this.request(listeners);\n  }\n\n  request(args) {\n    const xhr = this.getXhr();\n    const xhrId = this.currXhrId++;\n    const pendingRequest = (this.pendingRequests[xhrId] = { xhr });\n\n    xhr.open(\"GET\", this.url);\n    xhr.withCredentials = this.withCredentials;\n    for (const property in this.httpHeaders) {\n      const value = this.httpHeaders[property];\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n      xhr.setRequestHeader(property, value);\n    }\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n    } else {\n      pendingRequest.expectedStatus = OK_RESPONSE;\n    }\n    xhr.responseType = \"arraybuffer\";\n\n    if (args.onError) {\n      xhr.onerror = function (evt) {\n        args.onError(xhr.status);\n      };\n    }\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\n\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\n    pendingRequest.onDone = args.onDone;\n    pendingRequest.onError = args.onError;\n    pendingRequest.onProgress = args.onProgress;\n\n    xhr.send(null);\n\n    return xhrId;\n  }\n\n  onProgress(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return; // Maybe abortRequest was called...\n    }\n    pendingRequest.onProgress?.(evt);\n  }\n\n  onStateChange(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return; // Maybe abortRequest was called...\n    }\n\n    const xhr = pendingRequest.xhr;\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n      pendingRequest.onHeadersReceived();\n      delete pendingRequest.onHeadersReceived;\n    }\n\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    if (!(xhrId in this.pendingRequests)) {\n      // The XHR request might have been aborted in onHeadersReceived()\n      // callback, in which case we should abort request.\n      return;\n    }\n\n    delete this.pendingRequests[xhrId];\n\n    // Success status == 0 can be on ftp, file and other protocols.\n    if (xhr.status === 0 && this.isHttp) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n    const xhrStatus = xhr.status || OK_RESPONSE;\n\n    // From http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.2:\n    // \"A server MAY ignore the Range header\". This means it's possible to\n    // get a 200 rather than a 206 response from a range request.\n    const ok_response_on_range_request =\n      xhrStatus === OK_RESPONSE &&\n      pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n\n    if (\n      !ok_response_on_range_request &&\n      xhrStatus !== pendingRequest.expectedStatus\n    ) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n\n    const chunk = getArrayBuffer(xhr);\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n      pendingRequest.onDone({\n        begin: parseInt(matches[1], 10),\n        chunk,\n      });\n    } else if (chunk) {\n      pendingRequest.onDone({\n        begin: 0,\n        chunk,\n      });\n    } else {\n      pendingRequest.onError?.(xhr.status);\n    }\n  }\n\n  getRequestXhr(xhrId) {\n    return this.pendingRequests[xhrId].xhr;\n  }\n\n  isPendingRequest(xhrId) {\n    return xhrId in this.pendingRequests;\n  }\n\n  abortRequest(xhrId) {\n    const xhr = this.pendingRequests[xhrId].xhr;\n    delete this.pendingRequests[xhrId];\n    xhr.abort();\n  }\n}\n\n/** @implements {IPDFStream} */\nclass PDFNetworkStream {\n  constructor(source) {\n    this._source = source;\n    this._manager = new NetworkManager(source.url, {\n      httpHeaders: source.httpHeaders,\n      withCredentials: source.withCredentials,\n    });\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _onRangeRequestReaderClosed(reader) {\n    const i = this._rangeRequestReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeRequestReaders.splice(i, 1);\n    }\n  }\n\n  getFullReader() {\n    assert(\n      !this._fullRequestReader,\n      \"PDFNetworkStream.getFullReader can only be called once.\"\n    );\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(\n      this._manager,\n      this._source\n    );\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    const reader = new PDFNetworkStreamRangeRequestReader(\n      this._manager,\n      begin,\n      end\n    );\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\n\n/** @implements {IPDFStreamReader} */\nclass PDFNetworkStreamFullRequestReader {\n  constructor(manager, source) {\n    this._manager = manager;\n\n    const args = {\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this),\n    };\n    this._url = source.url;\n    this._fullRequestId = manager.requestFull(args);\n    this._headersReceivedCapability = createPromiseCapability();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length; // Optional\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n\n    this.onProgress = null;\n  }\n\n  _onHeadersReceived() {\n    const fullRequestXhrId = this._fullRequestId;\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n\n    const getResponseHeader = name => {\n      return fullRequestXhr.getResponseHeader(name);\n    };\n    const { allowRangeRequests, suggestedLength } =\n      validateRangeRequestCapabilities({\n        getResponseHeader,\n        isHttp: this._manager.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange,\n      });\n\n    if (allowRangeRequests) {\n      this._isRangeSupported = true;\n    }\n    // Setting right content length.\n    this._contentLength = suggestedLength || this._contentLength;\n\n    this._filename = extractFilenameFromHeader(getResponseHeader);\n\n    if (this._isRangeSupported) {\n      // NOTE: by cancelling the full request, and then issuing range\n      // requests, there will be an issue for sites where you can only\n      // request the pdf once. However, if this is the case, then the\n      // server should not be returning that it can support range requests.\n      this._manager.abortRequest(fullRequestXhrId);\n    }\n\n    this._headersReceivedCapability.resolve();\n  }\n\n  _onDone(data) {\n    if (data) {\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n        requestCapability.resolve({ value: data.chunk, done: false });\n      } else {\n        this._cachedChunks.push(data.chunk);\n      }\n    }\n    this._done = true;\n    if (this._cachedChunks.length > 0) {\n      return;\n    }\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({ value: undefined, done: true });\n    }\n    this._requests.length = 0;\n  }\n\n  _onError(status) {\n    this._storedError = createResponseStatusError(status, this._url);\n    this._headersReceivedCapability.reject(this._storedError);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._cachedChunks.length = 0;\n  }\n\n  _onProgress(evt) {\n    this.onProgress?.({\n      loaded: evt.loaded,\n      total: evt.lengthComputable ? evt.total : this._contentLength,\n    });\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get headersReady() {\n    return this._headersReceivedCapability.promise;\n  }\n\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._cachedChunks.length > 0) {\n      const chunk = this._cachedChunks.shift();\n      return { value: chunk, done: false };\n    }\n    if (this._done) {\n      return { value: undefined, done: true };\n    }\n    const requestCapability = createPromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n    this._headersReceivedCapability.reject(reason);\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({ value: undefined, done: true });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\n      this._manager.abortRequest(this._fullRequestId);\n    }\n    this._fullRequestReader = null;\n  }\n}\n\n/** @implements {IPDFStreamRangeReader} */\nclass PDFNetworkStreamRangeRequestReader {\n  constructor(manager, begin, end) {\n    this._manager = manager;\n\n    const args = {\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this),\n    };\n    this._url = manager.url;\n    this._requestId = manager.requestRange(begin, end, args);\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this._storedError = undefined;\n\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n\n  _close() {\n    this.onClosed?.(this);\n  }\n\n  _onDone(data) {\n    const chunk = data.chunk;\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({ value: chunk, done: false });\n    } else {\n      this._queuedChunk = chunk;\n    }\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({ value: undefined, done: true });\n    }\n    this._requests.length = 0;\n    this._close();\n  }\n\n  _onError(status) {\n    this._storedError = createResponseStatusError(status, this._url);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._queuedChunk = null;\n  }\n\n  _onProgress(evt) {\n    if (!this.isStreamingSupported) {\n      this.onProgress?.({ loaded: evt.loaded });\n    }\n  }\n\n  get isStreamingSupported() {\n    return false;\n  }\n\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._queuedChunk !== null) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return { value: chunk, done: false };\n    }\n    if (this._done) {\n      return { value: undefined, done: true };\n    }\n    const requestCapability = createPromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({ value: undefined, done: true });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._requestId)) {\n      this._manager.abortRequest(this._requestId);\n    }\n    this._close();\n  }\n}\n\nexport { PDFNetworkStream };\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbortException,\n  assert,\n  createPromiseCapability,\n} from \"../shared/util.js\";\nimport {\n  createResponseStatusError,\n  extractFilenameFromHeader,\n  validateRangeRequestCapabilities,\n  validateResponseStatus,\n} from \"./network_utils.js\";\n\nif (typeof PDFJSDev !== \"undefined\" && PDFJSDev.test(\"MOZCENTRAL\")) {\n  throw new Error(\n    'Module \"./fetch_stream.js\" shall not be used with MOZCENTRAL builds.'\n  );\n}\n\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers,\n    signal: abortController?.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\",\n  };\n}\n\nfunction createHeaders(httpHeaders) {\n  const headers = new Headers();\n  for (const property in httpHeaders) {\n    const value = httpHeaders[property];\n    if (typeof value === \"undefined\") {\n      continue;\n    }\n    headers.append(property, value);\n  }\n  return headers;\n}\n\n/** @implements {IPDFStream} */\nclass PDFFetchStream {\n  constructor(source) {\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.httpHeaders = (this.isHttp && source.httpHeaders) || {};\n\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n\n  getFullReader() {\n    assert(\n      !this._fullRequestReader,\n      \"PDFFetchStream.getFullReader can only be called once.\"\n    );\n    this._fullRequestReader = new PDFFetchStreamReader(this);\n    return this._fullRequestReader;\n  }\n\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n\n  cancelAllRequests(reason) {\n    if (this._fullRequestReader) {\n      this._fullRequestReader.cancel(reason);\n    }\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\n\n/** @implements {IPDFStreamReader} */\nclass PDFFetchStreamReader {\n  constructor(stream) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = createPromiseCapability();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    if (typeof AbortController !== \"undefined\") {\n      this._abortController = new AbortController();\n    }\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n\n    this._headers = createHeaders(this._stream.httpHeaders);\n\n    const url = source.url;\n    fetch(\n      url,\n      createFetchOptions(\n        this._headers,\n        this._withCredentials,\n        this._abortController\n      )\n    )\n      .then(response => {\n        if (!validateResponseStatus(response.status)) {\n          throw createResponseStatusError(response.status, url);\n        }\n        this._reader = response.body.getReader();\n        this._headersCapability.resolve();\n\n        const getResponseHeader = name => {\n          return response.headers.get(name);\n        };\n        const { allowRangeRequests, suggestedLength } =\n          validateRangeRequestCapabilities({\n            getResponseHeader,\n            isHttp: this._stream.isHttp,\n            rangeChunkSize: this._rangeChunkSize,\n            disableRange: this._disableRange,\n          });\n\n        this._isRangeSupported = allowRangeRequests;\n        // Setting right content length.\n        this._contentLength = suggestedLength || this._contentLength;\n\n        this._filename = extractFilenameFromHeader(getResponseHeader);\n\n        // We need to stop reading when range is supported and streaming is\n        // disabled.\n        if (!this._isStreamingSupported && this._isRangeSupported) {\n          this.cancel(new AbortException(\"Streaming is disabled.\"));\n        }\n      })\n      .catch(this._headersCapability.reject);\n\n    this.onProgress = null;\n  }\n\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n\n  get filename() {\n    return this._filename;\n  }\n\n  get contentLength() {\n    return this._contentLength;\n  }\n\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._headersCapability.promise;\n    const { value, done } = await this._reader.read();\n    if (done) {\n      return { value, done };\n    }\n    this._loaded += value.byteLength;\n    if (this.onProgress) {\n      this.onProgress({\n        loaded: this._loaded,\n        total: this._contentLength,\n      });\n    }\n    const buffer = new Uint8Array(value).buffer;\n    return { value: buffer, done: false };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n    if (this._abortController) {\n      this._abortController.abort();\n    }\n  }\n}\n\n/** @implements {IPDFStreamRangeReader} */\nclass PDFFetchStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = createPromiseCapability();\n    this._isStreamingSupported = !source.disableStream;\n\n    if (typeof AbortController !== \"undefined\") {\n      this._abortController = new AbortController();\n    }\n\n    this._headers = createHeaders(this._stream.httpHeaders);\n    this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n\n    const url = source.url;\n    fetch(\n      url,\n      createFetchOptions(\n        this._headers,\n        this._withCredentials,\n        this._abortController\n      )\n    )\n      .then(response => {\n        if (!validateResponseStatus(response.status)) {\n          throw createResponseStatusError(response.status, url);\n        }\n        this._readCapability.resolve();\n        this._reader = response.body.getReader();\n      })\n      .catch(this._readCapability.reject);\n\n    this.onProgress = null;\n  }\n\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n\n  async read() {\n    await this._readCapability.promise;\n    const { value, done } = await this._reader.read();\n    if (done) {\n      return { value, done };\n    }\n    this._loaded += value.byteLength;\n    if (this.onProgress) {\n      this.onProgress({ loaded: this._loaded });\n    }\n    const buffer = new Uint8Array(value).buffer;\n    return { value: buffer, done: false };\n  }\n\n  cancel(reason) {\n    if (this._reader) {\n      this._reader.cancel(reason);\n    }\n    if (this._abortController) {\n      this._abortController.abort();\n    }\n  }\n}\n\nexport { PDFFetchStream };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __w_pdfjs_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable sort-exports/sort-exports */\n\n// eslint-disable-next-line max-len\n/** @typedef {import(\"./display/api\").PDFDocumentLoadingTask} PDFDocumentLoadingTask */\n/** @typedef {import(\"./display/api\").PDFDocumentProxy} PDFDocumentProxy */\n/** @typedef {import(\"./display/api\").PDFPageProxy} PDFPageProxy */\n/** @typedef {import(\"./display/api\").RenderTask} RenderTask */\n\nimport {\n  addLinkAttributes,\n  getFilenameFromUrl,\n  getPdfFilenameFromUrl,\n  getXfaPageViewport,\n  isPdfFile,\n  isValidFetchUrl,\n  LinkTarget,\n  loadScript,\n  PDFDateString,\n  PixelsPerInch,\n  RenderingCancelledException,\n} from \"./display/display_utils.js\";\nimport {\n  AnnotationMode,\n  CMapCompressionType,\n  createObjectURL,\n  createPromiseCapability,\n  createValidAbsoluteUrl,\n  InvalidPDFException,\n  MissingPDFException,\n  OPS,\n  PasswordResponses,\n  PermissionFlag,\n  removeNullCharacters,\n  shadow,\n  UnexpectedResponseException,\n  UNSUPPORTED_FEATURES,\n  Util,\n  VerbosityLevel,\n} from \"./shared/util.js\";\nimport {\n  build,\n  getDocument,\n  LoopbackPort,\n  PDFDataRangeTransport,\n  PDFWorker,\n  setPDFNetworkStreamFactory,\n  version,\n} from \"./display/api.js\";\nimport { AnnotationLayer } from \"./display/annotation_layer.js\";\nimport { GlobalWorkerOptions } from \"./display/worker_options.js\";\nimport { isNodeJS } from \"./shared/is_node.js\";\nimport { renderTextLayer } from \"./display/text_layer.js\";\nimport { SVGGraphics } from \"./display/svg.js\";\nimport { XfaLayer } from \"./display/xfa_layer.js\";\n\n/* eslint-disable-next-line no-unused-vars */\nconst pdfjsVersion =\n  typeof PDFJSDev !== \"undefined\" ? PDFJSDev.eval(\"BUNDLE_VERSION\") : void 0;\n/* eslint-disable-next-line no-unused-vars */\nconst pdfjsBuild =\n  typeof PDFJSDev !== \"undefined\" ? PDFJSDev.eval(\"BUNDLE_BUILD\") : void 0;\n\nif (typeof PDFJSDev === \"undefined\" || !PDFJSDev.test(\"PRODUCTION\")) {\n  const streamsPromise = Promise.all([\n    import(\"pdfjs/display/network.js\"),\n    import(\"pdfjs/display/fetch_stream.js\"),\n  ]);\n\n  setPDFNetworkStreamFactory(async params => {\n    const [{ PDFNetworkStream }, { PDFFetchStream }] = await streamsPromise;\n    if (isValidFetchUrl(params.url)) {\n      return new PDFFetchStream(params);\n    }\n    return new PDFNetworkStream(params);\n  });\n} else if (PDFJSDev.test(\"GENERIC || CHROME\")) {\n  if (PDFJSDev.test(\"GENERIC\") && isNodeJS) {\n    const { PDFNodeStream } = require(\"./display/node_stream.js\");\n\n    setPDFNetworkStreamFactory(params => {\n      return new PDFNodeStream(params);\n    });\n  } else {\n    const { PDFNetworkStream } = require(\"./display/network.js\");\n    const { PDFFetchStream } = require(\"./display/fetch_stream.js\");\n\n    setPDFNetworkStreamFactory(params => {\n      if (isValidFetchUrl(params.url)) {\n        return new PDFFetchStream(params);\n      }\n      return new PDFNetworkStream(params);\n    });\n  }\n}\n\nexport {\n  // From \"./display/display_utils.js\":\n  addLinkAttributes,\n  getFilenameFromUrl,\n  getPdfFilenameFromUrl,\n  isPdfFile,\n  LinkTarget,\n  loadScript,\n  PDFDateString,\n  PixelsPerInch,\n  RenderingCancelledException,\n  getXfaPageViewport,\n  // From \"./shared/util.js\":\n  AnnotationMode,\n  CMapCompressionType,\n  createObjectURL,\n  createPromiseCapability,\n  createValidAbsoluteUrl,\n  InvalidPDFException,\n  MissingPDFException,\n  OPS,\n  PasswordResponses,\n  PermissionFlag,\n  removeNullCharacters,\n  shadow,\n  UnexpectedResponseException,\n  UNSUPPORTED_FEATURES,\n  Util,\n  VerbosityLevel,\n  // From \"./display/api.js\":\n  build,\n  getDocument,\n  LoopbackPort,\n  PDFDataRangeTransport,\n  PDFWorker,\n  version,\n  // From \"./display/annotation_layer.js\":\n  AnnotationLayer,\n  // From \"./display/worker_options.js\":\n  GlobalWorkerOptions,\n  // From \"./display/text_layer.js\":\n  renderTextLayer,\n  // From \"./display/svg.js\":\n  SVGGraphics,\n  // From \"./display/xfa_layer.js\":\n  XfaLayer,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}